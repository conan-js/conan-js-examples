import { Flows } from "../conan-flow/factories/flows";
import { FlowEventNature } from "../conan-flow/domain/flowRuntimeEvents";
import { Strings } from "./strings";
export var AsapType;
(function (AsapType) {
    AsapType["NOW"] = "NOW";
    AsapType["LATER"] = "LATER";
})(AsapType || (AsapType = {}));
function isPromise(toParse) {
    if (toParse == null)
        return false;
    if (typeof toParse != "object")
        return false;
    return ('then' in toParse) && typeof (toParse.then) === 'function';
}
export function isAsap(toParse) {
    return (toParse instanceof NowImpl) || (toParse instanceof LaterImpl);
}
class NowImpl {
    constructor(rawValue) {
        this.rawValue = rawValue;
        this.type = AsapType.NOW;
    }
    cancel() {
        return false;
    }
    then(consumer) {
        consumer(this.rawValue);
        return this;
    }
    map(mapper) {
        return Asaps.now(mapper(this.rawValue));
    }
    chain(mapper) {
        const [next, asap] = Asaps.next('map', FlowEventNature.AUX);
        this.then(value => mapper(value).then(toMerge => next(toMerge)));
        return asap;
    }
    catch(error) {
        //Since is not async, it would never fail
        return this;
    }
    onCancel(consumer) {
        //Since is not async, it would never cancel
        return this;
    }
}
class LaterImpl {
    constructor(flow) {
        this.flow = flow;
        this.type = AsapType.LATER;
    }
    map(mapper) {
        let [setNext, nextAsap] = Asaps.next('map', FlowEventNature.AUX);
        this.then(value => setNext(mapper(value)));
        this.onCancel(() => nextAsap.cancel());
        return nextAsap;
    }
    then(consumer) {
        if (this.flow.getCurrentStatusName() === 'resolved') {
            consumer(this.flow.on('resolved').getLastData());
        }
        else {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { then: [...current.then, consumer] })));
        }
        return this;
    }
    resolve(value) {
        if (this.flow.getCurrentStatusName() === 'cancelled')
            return;
        try {
            this.flow.assertOn('resolving', (onResolving) => {
                onResolving.getData().then.forEach(subscriber => {
                    subscriber(value);
                });
                this.flow.on('resolving').transitions.$toStatus({
                    name: "resolved",
                    data: value
                });
            });
        }
        catch (e) {
            console.error(e);
            this.flow.assertOn('resolving', (onResolving) => {
                onResolving.getData().catch.forEach(subscriber => {
                    subscriber(e, value);
                });
                onResolving.do.$toStatus({ name: "errored", data: value });
            });
        }
    }
    onCancel(consumer) {
        if (this.flow.getCurrentStatusName() === 'cancelled') {
            consumer();
            return;
        }
        if (this.flow.getCurrentStatusName() === 'resolving') {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { onCancel: [...current.onCancel, consumer] })));
        }
        return this;
    }
    cancel() {
        if (this.flow.getCurrentStatusName() !== 'resolving') {
            return false;
        }
        this.flow.assertOn('resolving', onResolving => {
            onResolving.getData().onCancel.forEach(subscriber => {
                subscriber();
            });
            this.flow.on('resolving').transitions.$toStatus({ name: "cancelled", });
        });
        return true;
    }
    chain(chainProducer) {
        const [next, asap] = Asaps.next('merge', FlowEventNature.AUX);
        this.then(value => chainProducer(value)
            .then(toMerge => next(toMerge))
            .onCancel(() => asap.cancel())).onCancel(() => asap.cancel());
        return asap;
    }
    catch(consumer) {
        if (this.flow.getCurrentStatusName() === 'resolving') {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { catch: [...current.catch, consumer] })));
        }
        return this;
    }
}
class ProxyThen {
    constructor(baseAsap, beforeThen, afterThen) {
        this.baseAsap = baseAsap;
        this.beforeThen = beforeThen;
        this.afterThen = afterThen;
    }
    cancel() {
        return this.baseAsap.cancel();
    }
    catch(error) {
        this.baseAsap.catch(error);
        return this;
    }
    chain(chainProducer) {
        let chained = this.baseAsap.chain(chainProducer);
        return Asaps.proxyThen(chained, this.beforeThen, this.afterThen);
    }
    map(mapper) {
        let mapped = this.baseAsap.map(mapper);
        return Asaps.proxyThen(mapped, this.beforeThen, this.afterThen);
    }
    onCancel(consumer) {
        this.baseAsap.onCancel(consumer);
        return this;
    }
    then(consumer) {
        this.beforeThen();
        this.baseAsap.then(consumer);
        this.baseAsap.then(this.afterThen);
        return this;
    }
    get type() {
        return this.baseAsap.type;
    }
}
export class AsapParser {
    static from(toParse) {
        return isAsap(toParse) ?
            toParse :
            isPromise(toParse) ?
                Asaps.fromPromise(toParse) :
                Asaps.now(toParse);
    }
}
export class Asaps {
    static now(value) {
        return new NowImpl(value);
    }
    static fromPromise(promise, name) {
        let promiseImpl = new LaterImpl(Flows.createController({
            name: `future[${name ? name : 'anonymous'}]`,
            statuses: {
                resolving: {},
                resolved: {},
                errored: {},
                cancelled: {}
            },
            initialStatus: {
                name: 'resolving',
                data: {
                    then: [],
                    catch: [],
                    onCancel: [],
                }
            },
            nature: FlowEventNature.ASAP
        }).start());
        promise.then(value => promiseImpl.resolve(value));
        promise.catch(e => promiseImpl.catch(e));
        return promiseImpl;
    }
    static delayed(value, ms, name) {
        return Asaps.fromPromise(new Promise((done) => setTimeout(() => {
            if (typeof value === "function") {
                done(value());
            }
            else {
                done(value);
            }
        }, ms)), `delay[${name ? name : 'anonymous'}]`);
    }
    static fetch(url) {
        return Asaps.fromPromise(new Promise((done) => {
            fetch(url)
                .then((resp) => resp.json()) // Transform the data into json
                .then(function (data) {
                done(data);
            });
        }), `fetch[${Strings.padEnd(url, 15)}]`);
    }
    static next(name, nature) {
        let laterImpl = new LaterImpl(Flows.createController({
            name: `asap-${name ? name : 'anonymous'}`,
            statuses: {
                resolving: {},
                resolved: {},
                errored: {},
                cancelled: {}
            },
            initialStatus: {
                name: 'resolving',
                data: {
                    then: [],
                    catch: [],
                    onCancel: []
                }
            },
            nature: nature ? nature : FlowEventNature.ASAP
        }).start());
        return [(value) => laterImpl.resolve(value), laterImpl];
    }
    static proxyThen(toProxy, beforeThen, afterThen) {
        return new ProxyThen(toProxy, beforeThen, afterThen);
    }
}
//# sourceMappingURL=asap.js.map