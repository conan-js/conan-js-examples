import { ReactionType } from "../../conan-flow/domain/reactions";
export class ThreadImpl {
    constructor(flow, def) {
        this.flow = flow;
        this.def = def;
    }
    start(initialData) {
        this.flow.start(initialData ? { name: 'nextData', data: initialData } : undefined);
        return this;
    }
    next(cb) {
        this.flow.onceOn("nextData", cb);
    }
    stop(eventsConsumer) {
        this.flow.stop(eventsConsumer);
    }
    chain(mutatorsCb, name) {
        return this.flow.chainInto('nextData', 'nextData', mutatorsCb, name).map(context => context.getData());
    }
    monitor(toMonitor, thenCallback, name, payload) {
        let mutatorsCbAsap = toMonitor.map(data => reducers => thenCallback(data, reducers));
        let defer = {
            payload: payload,
            name: name == null ? 'anonymous' : name,
            action: mutatorsCbAsap
        };
        return this.flow.deferInto('nextData', 'nextData', defer).map(context => context.getData());
    }
    get isRunning() {
        return this.flow.isRunning;
    }
    get reducers() {
        return this.flow.on('nextData').steps;
    }
    addReaction(def) {
        let reactionDef = {
            name: def.name,
            reactionType: ReactionType.ALWAYS,
            action: oNextData => def.dataConsumer(oNextData.getData()),
        };
        this.flow.addReaction('nextData', reactionDef);
        return {
            release: () => {
                this.flow.removeReaction('nextData', reactionDef);
            }
        };
    }
    getData() {
        return this.flow.getStatusData()['nextData'];
    }
    getEvents() {
        return this.flow.getEvents();
    }
    getName() {
        return this.flow.getName();
    }
    changeLoggingNature(nature) {
        this.flow.changeLoggingNature(nature);
    }
    log(msg) {
        this.flow.log(msg);
    }
    once(reaction, name) {
        this.flow.onceOn('nextData', onNextData => reaction(onNextData.getData()), name);
        return this;
    }
    createRuntimeTracker(runtimeEvent, payload) {
        return this.flow.createRuntimeTracker(runtimeEvent, payload);
    }
    addReactionNext(def) {
        this.flow.addReactionNext(this.flow.on('nextData'), {
            name: def.name,
            reactionType: ReactionType.ALWAYS,
            action: (onNextData) => def.dataConsumer(onNextData.getData())
        });
        return this;
    }
    getDefinition() {
        return this.def;
    }
}
//# sourceMappingURL=thread.js.map