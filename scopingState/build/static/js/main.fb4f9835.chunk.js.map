{"version":3,"sources":["app.tsx","index.tsx"],"names":["ScopingStateApp","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oMAaO,SAASA,IACZ,OAAQ,2BACJ,qCACA,oCACA,gLAEA,mCACA,mIACA,qCACA,kIACA,qCACA,+U,OCpBRC,EAASC,OACL,kBAAC,IAAMC,WAAP,KACI,kBAACH,EAAD,OAEJI,SAASC,eAAe,W","file":"static/js/main.fb4f9835.chunk.js","sourcesContent":["import * as React from \"react\";\nimport {Reducers} from \"conan-js-core\";\n\nexport interface ProductPriceReducers extends Reducers<ProductUnitPrice>{\n    $incrementPriceBy10(): ProductUnitPrice;\n    $decrementPriceBy10(): ProductUnitPrice;\n}\ninterface ProductUnitPrice {\n    priceUsd: number;\n    id: string;\n}\n\n\nexport function ScopingStateApp(): React.ReactElement {\n    return (<div>\n        <h1>SCOPING</h1>\n        <h2>Global</h2>\n        <p>You can have global state just by exporting it and then importing it, or in a simmilar fashion by adding your state\n         to you application context (DI)</p>\n        <h2>Local</h2>\n        <p>You can have local state to your component by just declaring it and using it locally to your component</p>\n        <h2>Context</h2>\n        <p>The moment you connect state, is stored in the context, this means that you can use the context state</p>\n        <h2>Runtime</h2>\n        <p>Many times you wil find that you want to generate state not statically but based on the actual context of the app. When this happens, you have different mechanisms\n            For instance you could generate a new state as pass it as props to a component. Or you could leverage a derived DI context (to be documented)\n        </p>\n    </div>)\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {ScopingStateApp} from \"./app\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <ScopingStateApp/>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}