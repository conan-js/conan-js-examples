import { FlowEventLevel, FlowEventNature } from "../domain/flowRuntimeEvents";
import { Strings } from "../../conan-utils/strings";
import { BaseRules } from "../../conan-utils/rules/baseRules";
export class FlowLogger {
    constructor(Rule$) {
        this.Rule$ = Rule$;
    }
    log(event) {
        if (!this.Rule$().test(event)) {
            let customRule = event.flowController.flowDef.loggingRule;
            if (customRule) {
                if (!customRule.test(event)) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        let currentStatusName = event.flowController.getCurrentStatusName();
        currentStatusName = currentStatusName ? currentStatusName : '<stopped>';
        if (event.payload != null) {
            console.log(Strings.padEnd(`${event.type}`, 30), Strings.padEnd(`${event.flowController.getName()}`, 50), Strings.padEnd(`${currentStatusName}`, 30), Strings.padEnd(`${event.nature}`, 10), Strings.padEnd(`${event.level}`, 10), Strings.padEnd(`${event.timing}`, 12));
            if (event.payload != null || event.shortDesc != null) {
                if (event.shortDesc != null && event.payload != null) {
                    console.log(`  =>${event.shortDesc}`);
                    console.log(' ', event.payload);
                }
                else if (event.shortDesc != null && !event.payload != null) {
                    console.log(`  =>${event.shortDesc}`);
                }
                else {
                    console.log(`  =>${event.payload}`);
                }
            }
            console.log('------------------------------------------------------------------------------------------------------------------------------------------------');
        }
        else if (event.shortDesc != null) {
            console.log(Strings.padEnd(`${event.type}`, 30), Strings.padEnd(`${event.flowController.getName()}`, 50), Strings.padEnd(`${currentStatusName}`, 30), Strings.padEnd(`${event.level}`, 10), Strings.padEnd(`${event.nature}`, 10), Strings.padEnd(`${event.timing}`, 10));
            console.log(`  =>${event.shortDesc}`);
        }
        return true;
    }
}
export class LoggerFilters {
    static trace() {
        return BaseRules.if('ifTrace', (flowEvent) => flowEvent.level === FlowEventLevel.TRACE);
    }
    static debug() {
        return BaseRules.if('ifDebug', (flowEvent) => flowEvent.level === FlowEventLevel.DEBUG);
    }
    static milestone() {
        return BaseRules.if('ifMilestone', (flowEvent) => flowEvent.level === FlowEventLevel.MILESTONE);
    }
    static info() {
        return BaseRules.if('ifInfo', (flowEvent) => flowEvent.level === FlowEventLevel.INFO);
    }
    static logName(logName) {
        return BaseRules.combineOr(`main/async/meta[${logName}]`, LoggerFilters.mainLogName(logName), LoggerFilters.asyncLogName(logName), LoggerFilters.metaLogName(logName));
    }
    static mainLogName(logName) {
        return BaseRules.if(`ifLogName={${logName}`, (flowEvent) => flowEvent.flowController.getName() === logName);
    }
    static asyncLogName(logName) {
        return BaseRules.if(`ifLogName={${logName}`, (flowEvent) => flowEvent.flowController.getName() === `${logName}=>[async]`);
    }
    static metaLogName(logName) {
        return BaseRules.if(`ifLogName={${logName}`, (flowEvent) => flowEvent.flowController.getName() === `${logName}=>[meta]`);
    }
    static eventType(eventType) {
        return BaseRules.combineAnd(`eventType[${eventType}]`, LoggerFilters.trace().inverse(), BaseRules.if(`ifEventType={${eventType}`, (flowEvent) => flowEvent.type === eventType));
    }
    static statusName(statusName) {
        return BaseRules.if(`ifStatusName={${statusName}`, (flowEvent) => flowEvent.flowController.getCurrentStatusName() === statusName);
    }
    static notInitialising() {
        return LoggerFilters.initialising().inverse();
    }
    static initialising() {
        return LoggerFilters.statusName('$init');
    }
    static nextData() {
        return LoggerFilters.statusName('nextData');
    }
    static aux() {
        return BaseRules.if(`ifAux`, (flowEvent) => flowEvent.nature === FlowEventNature.AUX);
    }
    static async() {
        return BaseRules.if(`ifAsync`, (flowEvent) => flowEvent.nature === FlowEventNature.ASYNC);
    }
    static helper() {
        return BaseRules.if(`ifHelper`, (flowEvent) => flowEvent.nature === FlowEventNature.HELPER);
    }
    static main() {
        return BaseRules.if(`ifMain`, (flowEvent) => flowEvent.nature === FlowEventNature.MAIN);
    }
    static all() {
        return BaseRules.if(`all`, () => true);
    }
    static fromInfo() {
        return BaseRules.combineOr(`info and milestone`, LoggerFilters.info(), LoggerFilters.milestone());
    }
    static allExceptTraces() {
        return BaseRules.combineOr(`all except traces`, LoggerFilters.debug(), LoggerFilters.info(), LoggerFilters.milestone());
    }
    static never() {
        return BaseRules.if(`never`, () => false);
    }
    static default() {
        return BaseRules.combineAnd('default filter', LoggerFilters.milestone(), LoggerFilters.main(), LoggerFilters.initialising().inverse());
    }
}
export const FLOW_LOGGER = new FlowLogger(() => CURRENT_LOG_FILTER.rule);
const CURRENT_LOG_FILTER = {
    rule: LoggerFilters.default()
};
export const updateLoggingFilter = (logFilterReducer) => {
    let rule = logFilterReducer(CURRENT_LOG_FILTER.rule);
    CURRENT_LOG_FILTER.rule = rule;
    return rule;
};
export const setLoggingFilter = (logFilter) => {
    CURRENT_LOG_FILTER.rule = logFilter;
};
export const getLoggingFilter = () => {
    return CURRENT_LOG_FILTER.rule;
};
//# sourceMappingURL=flowLogger.js.map