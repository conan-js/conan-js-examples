import { MonitorStatus } from "../domain/monitorInfo";
import { Asaps } from "../../index";
import { FlowEventNature, FlowEventType } from "../../conan-flow/domain/flowRuntimeEvents";
import { Pipes } from "../../conan-pipe/factories/pipes";
import { MetaStatus } from "../domain/metaInfo";
import { ConanFlow } from "../../conan-react/conanFlow";
export class MonitorImpl {
    constructor(mainThread, asyncThread, metaFlow) {
        this.mainThread = mainThread;
        this.asyncThread = asyncThread;
        this.metaFlow = metaFlow;
    }
    start() {
        this.mainThread.start();
        return this;
    }
    addReaction(def) {
        return this.mainThread.addReaction(def);
    }
    addAsyncReaction(def) {
        return this.asyncThread.addReaction(def);
    }
    get do() {
        return this.mainThread.do;
    }
    getEvents() {
        return this.mainThread.getEvents();
    }
    getName() {
        return this.mainThread.getName();
    }
    stop(eventsConsumer) {
        this.mainThread.stop(eventsConsumer);
    }
    getData() {
        return this.mainThread.getData();
    }
    next(cb) {
        this.mainThread.next(cb);
    }
    once(reaction, name) {
        this.mainThread.once(reaction, name);
        return this;
    }
    chain(operation, name) {
        return this.mainThread.chain(operation, name);
    }
    openTransaction(name) {
        if (this.currentTransaction == null) {
            this.currentTransaction = this.mainThread.createRuntimeTracker(FlowEventType.MONITOR_TRANSACTION).start();
            this.currentTransaction.info(`starting transaction: ${name == null ? `[anonymous]` : name}`);
        }
    }
    closeTransaction(callback) {
        let metaFlowStatuses$ = new ConanFlow(this.metaFlow).toStateAll().map(it => it.data);
        let unlockTupleNow = false;
        let unlockThreadNow = false;
        let tupleLock = undefined;
        tupleLock = Pipes.tupleCombine('idleChecker', this.asyncThread, metaFlowStatuses$.mainThread, {
            nature: FlowEventNature.AUX
        }).addReaction({
            name: `wait for both idle`,
            dataConsumer: ([monitorInfo, metaInfo]) => {
                if (monitorInfo.status === MonitorStatus.IDLE && (metaInfo.status === MetaStatus.IDLE_ON_TRANSACTION ||
                    metaInfo.status === MetaStatus.IDLE)) {
                    let mainThreadLock = undefined;
                    mainThreadLock = this.mainThread.addReaction({
                        name: 'wait for both idle',
                        dataConsumer: (data) => {
                            this.currentTransaction.info(`finishing transaction`);
                            this.currentTransaction.end();
                            this.currentTransaction = null;
                            if (mainThreadLock) {
                                mainThreadLock.release();
                            }
                            else {
                                unlockThreadNow = true;
                            }
                            if (tupleLock) {
                                tupleLock.release();
                            }
                            else {
                                unlockTupleNow = true;
                            }
                            if (callback) {
                                callback(data);
                            }
                        }
                    });
                    if (unlockThreadNow) {
                        mainThreadLock.release();
                    }
                }
            }
        });
        if (unlockTupleNow) {
            tupleLock.release();
        }
    }
    transaction(code, name) {
        let [next, asap] = Asaps.next(`transaction[${name}]`);
        this.openTransaction();
        code(this.do);
        this.closeTransaction(data => next(data));
        return asap;
    }
}
//# sourceMappingURL=monitorImpl.js.map