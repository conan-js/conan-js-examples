import { StatusLikeParser } from "../domain/status";
import { BindBackType } from "../logic/flowAnchor";
import { Proxyfier } from "../../conan-utils/proxyfier";
export class MutatorsFactory {
    static createDefaultStepsDef() {
        return (getData) => ({
            $update(reducer) {
                if (typeof reducer !== 'function')
                    return reducer;
                return reducer(getData());
            }
        });
    }
    static createDefaultTransitionDef() {
        return (() => ({
            $toStatus(toStatus) {
                return StatusLikeParser.parse(toStatus);
            }
        }));
    }
    static createDefaultSteps(statusName, flowAnchor) {
        return this.createSteps(statusName, flowAnchor, this.createDefaultStepsDef());
    }
    static createTransitions(statusName, flowAnchor, userTransitions) {
        let defaultTransitionDef = this.createDefaultTransitionDef();
        return this.doCreateTransitions(statusName, flowAnchor, userTransitions ? [userTransitions, defaultTransitionDef] : [defaultTransitionDef]);
    }
    static createSteps(statusName, flowAnchor, userStepsDef) {
        let defaultStepDef = this.createDefaultStepsDef();
        return this.doCreateSteps(statusName, flowAnchor, userStepsDef ? [userStepsDef, defaultStepDef] : [defaultStepDef]);
    }
    static doCreateSteps(statusName, flowAnchor, allStepsDef) {
        let dataProducerFn = flowAnchor.getDataFn(statusName);
        let allSteps = {};
        allStepsDef.forEach(it => {
            let thisStep = it(dataProducerFn);
            allSteps = Object.assign(Object.assign({}, allSteps), thisStep);
        });
        return this.bindToAnchor(statusName, flowAnchor, allSteps, BindBackType.STEP);
    }
    static doCreateTransitions(statusName, flowAnchor, allTransitionsDef) {
        let statusDataProducerFn = flowAnchor.getStatusDataProducerFn();
        let allTransitions = {};
        allTransitionsDef.forEach(it => {
            let thisTransitions = it(statusDataProducerFn);
            allTransitions = Object.assign(Object.assign({}, allTransitions), thisTransitions);
        });
        return this.bindToAnchor(statusName, flowAnchor, allTransitions, BindBackType.TRANSITION);
    }
    static bindToAnchor(expectedStatusName, flowAnchor, toBind, type) {
        return Proxyfier.proxy(toBind, (originalCall, metadata) => {
            let newState = originalCall();
            flowAnchor.bindBack(expectedStatusName, {
                statusName: flowAnchor.currentStatus.name,
                methodName: metadata.methodName,
                payload: metadata.payload,
                result: newState,
            }, type);
            return newState;
        });
    }
}
//# sourceMappingURL=mutatorsFactory.js.map