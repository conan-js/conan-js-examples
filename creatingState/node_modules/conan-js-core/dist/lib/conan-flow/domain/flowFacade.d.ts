import { Flow } from "./flow";
import { Mutators, VoidMutators } from "./mutators";
import { ReactionCb, ReactionDef } from "../def/reactionDef";
import { IConsumer } from "../..";
import { FlowEventsTracker } from "../logic/flowEventsTracker";
import { StatusDef } from "../def/status/statusDef";
import { Status, StatusLike } from "./status";
import { Context } from "./context";
import { Asap } from "../../conan-utils/asap";
import { DeferLike } from "./defer";
export interface FlowFacade<STATUSES, MUTATORS extends Mutators<STATUSES> = VoidMutators<STATUSES>, ACTIONS = void> extends Flow<STATUSES, MUTATORS> {
    do: ACTIONS;
}
export declare class FlowFacadeImpl<STATUSES, MUTATORS extends Mutators<STATUSES> = VoidMutators<STATUSES>, ACTIONS = void> implements FlowFacade<STATUSES, MUTATORS, ACTIONS> {
    private readonly flow;
    readonly actions: ACTIONS;
    constructor(flow: Flow<STATUSES, MUTATORS>, actions: ACTIONS);
    do: ACTIONS;
    addReaction<STATUS extends keyof STATUSES & MUTATORS>(statusName: STATUS, reaction: ReactionDef<STATUSES, STATUS, MUTATORS>): this;
    alwaysOn<STATUS extends keyof STATUSES & keyof MUTATORS>(stateName: STATUS, def: ReactionCb<STATUSES, STATUS, MUTATORS>): this;
    assertOn<STATUS extends keyof STATUSES>(status: STATUS, then?: IConsumer<Context<STATUSES, STATUS, MUTATORS>>): this;
    chainInto<STATUS_FROM extends keyof STATUSES, STATUS_TO extends keyof STATUSES>(statusFrom: STATUS_FROM, statusTo: STATUS_TO, mutatorsCb: IConsumer<MUTATORS[STATUS_FROM]>): Asap<Context<STATUSES, STATUS_TO, MUTATORS>>;
    getCurrentStatusName(): string;
    getEvents(): FlowEventsTracker<STATUSES>;
    getName(): string;
    getState(): any;
    getStatusData(): {
        [STATUS in keyof STATUSES]?: STATUSES[STATUS];
    };
    on<STATUS extends keyof STATUSES>(statusName: STATUS): StatusDef<STATUSES, STATUS>;
    onceOn<STATUS extends keyof STATUSES & keyof MUTATORS>(stateName: STATUS, def: ReactionCb<STATUSES, STATUS, MUTATORS>): this;
    onceOnInit(def: ReactionCb<STATUSES, any, MUTATORS>): this;
    onceOnStop(def: ReactionCb<STATUSES, any, MUTATORS>): this;
    start(initialStatus?: StatusLike<STATUSES>): this;
    stop(eventsCb?: IConsumer<FlowEventsTracker<STATUSES>>): this;
    get isRunning(): boolean;
    onInit(): StatusDef<STATUSES, any>;
    reactOnStatusChanged(customReaction: IConsumer<Status<STATUSES>>): this;
    deferInto<STATUS_FROM extends keyof STATUSES, STATUS_TO extends keyof STATUSES>(statusFrom: STATUS_FROM, statusTo: STATUS_TO, mutatorsCbAsap: DeferLike<MUTATORS[STATUS_FROM]>): Asap<Context<STATUSES, STATUS_TO, MUTATORS>>;
    removeReaction<STATUS extends keyof STATUSES & keyof MUTATORS>(statusName: STATUS, reactionToRemove: ReactionDef<STATUSES, STATUS, MUTATORS>): void;
}
