import { StatusLikeParser } from "../domain/status";
import { FlowRuntimeEventSource, FlowRuntimeEventTiming, FlowRuntimeEventType } from "../domain/flowRuntimeEvents";
import { ReactionType } from "../domain/reactions";
import { AsapParser, Asaps } from "../../conan-utils/asap";
import { $INIT, $STOP } from "../domain/flow";
import { deferParser } from "../domain/defer";
export class FlowImpl {
    constructor(flowDef, flowAnchor, flowOrchestrator) {
        this.flowDef = flowDef;
        this.flowAnchor = flowAnchor;
        this.flowOrchestrator = flowOrchestrator;
        this.isRunning = false;
    }
    start(initialStatus) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowRuntimeEventSource.FLOW_CONTROLLER, FlowRuntimeEventType.START, initialStatus).trace(FlowRuntimeEventTiming.REQUEST_START);
        if (this.isRunning) {
            throw new Error(`can't request a flow that it has been started to start again`);
        }
        this.flowThread = this.flowAnchor.createNewThread(this, this.flowOrchestrator);
        this.isRunning = true;
        if (initialStatus == null && this.flowDef.starter == null) {
            this.requestStatus($INIT);
            return this;
        }
        let actualStarter = initialStatus ? initialStatus : this.flowDef.starter();
        let doStart = (status) => {
            this.addReaction($INIT, {
                action: () => {
                    tracker.highlight(FlowRuntimeEventTiming.TRACE, 'initialStatus - resolved', status);
                    this.requestStatus(status);
                },
                reactionType: ReactionType.ONCE,
                name: 'to initial state'
            });
            this.addReaction($STOP, {
                name: `onStop=>notifyEvents`,
                reactionType: ReactionType.ONCE,
                action: onStop => {
                    onStop.chain(() => {
                        tracker.highlight(FlowRuntimeEventTiming.TRACE, 'state machine stopped');
                        this.flowThread = null;
                        this.isRunning = false;
                    });
                }
            });
            this.requestStatus($INIT);
        };
        AsapParser.from(actualStarter).then(status => doStart(status));
        tracker.trace(FlowRuntimeEventTiming.REQUEST_END);
        return this;
    }
    requestStatus(statusLike) {
        let statusName = StatusLikeParser.parse(statusLike).name;
        if (!this.isRunning)
            return;
        if (this.on(statusName) == null) {
            throw new Error(`unable to request non existing status [${statusName}]`);
        }
        this.flowThread.requestStatus(statusLike, false);
    }
    requestState(statusName, data) {
        if (!this.isRunning)
            return;
        this.flowThread.requestState(statusName, data);
    }
    requestTransition(transition) {
        if (!this.isRunning)
            return;
        this.flowThread.requestTransition(transition, false);
        return this;
    }
    requestStep(statusName, reducerName, payload, data) {
        if (!this.isRunning)
            return;
        this.flowThread.requestStep(statusName, reducerName, payload, data);
    }
    stop(eventsCb) {
        if (!this.isRunning) {
            throw new Error(`unexpected`);
        }
        this.addReaction($STOP, {
            name: `onStop=>notifyEvents`,
            reactionType: ReactionType.ONCE,
            action: () => {
                if (eventsCb) {
                    eventsCb(this.flowAnchor.getCurrentEvents());
                }
            }
        });
        this.requestStatus({
            name: $STOP
        });
        return this;
    }
    alwaysOn(stateName, def) {
        return this.addReaction(stateName, {
            name: `-`,
            reactionType: ReactionType.ALWAYS,
            action: def
        });
    }
    onceOnInit(def) {
        return this.onceOn($INIT, def);
    }
    onceOnStop(def) {
        return this.onceOn($STOP, def);
    }
    onceOn(stateName, def) {
        return this.addReaction(stateName, {
            name: `-`,
            reactionType: ReactionType.ONCE,
            action: def
        });
    }
    addReaction(statusName, reaction) {
        let needsToBeAdded = true;
        if (this.isRunning) {
            if (this.flowThread.tryToQueue(statusName, reaction)) {
                return this;
            }
            this.runIf(statusName, {
                action: (context) => {
                    reaction.action(context);
                    if (reaction.reactionType === ReactionType.ONCE) {
                        needsToBeAdded = false;
                    }
                },
                reactionType: reaction.reactionType,
                name: reaction.name
            });
        }
        if (needsToBeAdded) {
            let statusDef = this.on(statusName);
            if (statusDef == null) {
                throw new Error(`unable to add reactions for unknown event [${statusName}]`);
            }
            this.addReactionNext(statusDef, reaction);
        }
        return this;
    }
    addReactionNext(statusDef, reaction) {
        statusDef.reactions.push(reaction);
        return this;
    }
    getReactions(statusName) {
        let statusDef = this.on(statusName);
        if (statusDef == null) {
            throw new Error(`can't getReactions for unknown status[${statusName}]`);
        }
        return statusDef.reactions;
    }
    getCurrentStatusName() {
        if (this.flowThread == undefined)
            return undefined;
        return this.flowThread.getCurrentStatusName();
    }
    getEvents() {
        return this.flowAnchor.getCurrentEvents();
    }
    getName() {
        return this.flowDef.name;
    }
    getState() {
        return this.flowThread.getCurrentState();
    }
    getStatusData() {
        return this.flowAnchor.getStatusData();
    }
    onInit() {
        return this.on($INIT);
    }
    on(statusName) {
        return this.flowDef.statusesByStatusName[statusName];
    }
    getStatusDefs() {
        return this.flowDef.statusesByStatusName;
    }
    removeReaction(statusName, reactionToRemove) {
        let statusDef = this.on(statusName);
        let previousReactions = statusDef.reactions;
        if (!previousReactions)
            return;
        statusDef.reactions = previousReactions.filter(it => it !== reactionToRemove);
    }
    processReactions(statusName) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowRuntimeEventSource.FLOW_CONTROLLER, FlowRuntimeEventType.PROCESS_REACTIONS, statusName).trace(FlowRuntimeEventTiming.REQUEST_START);
        let onAllReactionsCompleted;
        this.getReactions(statusName).forEach(reaction => {
            if (reaction.reactionType === ReactionType.ONCE) {
                this.removeReaction(statusName, reaction);
            }
            reaction.action(this.flowThread.createContext(statusName, (cb) => onAllReactionsCompleted = cb));
        });
        if (onAllReactionsCompleted) {
            onAllReactionsCompleted();
        }
        tracker.trace(FlowRuntimeEventTiming.REQUEST_END, statusName);
        return this;
    }
    getStateData() {
        throw new Error(`TBI`);
    }
    reactOnStatusChanged(customReaction) {
        Object.keys(this.getStatusDefs()).forEach(stateName => {
            this.addReaction(stateName, {
                name: `-`,
                reactionType: ReactionType.ALWAYS,
                action: context => customReaction({ name: stateName, data: context.getData() })
            });
        });
        return this;
    }
    runIf(statusName, reaction, elseIf) {
        if (!this.isRunning) {
            if (elseIf)
                elseIf();
            return;
        }
        let currentStatus = this.getCurrentStatusName();
        if (currentStatus == null) {
            if (elseIf) {
                elseIf();
            }
            return;
        }
        if (currentStatus === statusName) {
            this.doRun(reaction, statusName);
        }
        else {
            if (elseIf) {
                elseIf();
            }
        }
    }
    doRun(reaction, currentState) {
        reaction.action(this.flowThread.createContext(currentState, (cb) => cb()));
    }
    assertOn(status, then) {
        let currentStatusName = this.getCurrentStatusName();
        if (currentStatusName !== status) {
            throw new Error(`asserting that we are on the status [${status}]. But we are currently on [${currentStatusName}]`);
        }
        if (then) {
            this.onceOn(status, onAssertedStatus => then(onAssertedStatus));
        }
        return this;
    }
    chainInto(statusFrom, statusTo, mutatorsCb) {
        const [next, asap] = Asaps.next();
        this.assertOn(statusFrom);
        this.addReactionNext(this.on(statusTo), {
            name: `once on next`,
            reactionType: ReactionType.ONCE,
            action: onChain => next(onChain)
        });
        this.onceOn(statusFrom, onThisStatus => mutatorsCb(onThisStatus.do));
        return asap;
    }
    deferInto(statusFrom, statusTo, mutatorsCbAsapLike) {
        let mutatorsCbAsap = deferParser(mutatorsCbAsapLike, {
            name: `[${this.getName()}]::${statusFrom}=>${statusTo}`,
            payload: `[${this.getName()}]::${statusFrom}=>${statusTo}`
        });
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowRuntimeEventSource.FLOW_CONTROLLER, FlowRuntimeEventType.MONITOR, {
            asap: mutatorsCbAsap.action,
            name: mutatorsCbAsap.name,
            payload: mutatorsCbAsap.payload
        }).trace(FlowRuntimeEventTiming.REQUEST_START);
        return mutatorsCbAsap.action.merge(cb => {
            tracker.trace(FlowRuntimeEventTiming.REQUEST_END);
            return this.chainInto(statusFrom, statusTo, cb);
        }).onCancel(() => {
            tracker.trace(FlowRuntimeEventTiming.REQUEST_CANCEL);
        });
    }
}
//# sourceMappingURL=flowImpl.js.map