import { AsapType } from "../../index";
import { StatusLikeParser } from "../domain/status";
import { FlowEventNature, FlowEventSource, FlowEventType } from "../domain/flowRuntimeEvents";
import { ReactionType } from "../domain/reactions";
import { AsapParser, Asaps } from "../../conan-utils/asap";
import { $INIT, $STOP } from "../domain/flow";
import { deferParser } from "../domain/defer";
import { Threads } from "../../conan-thread/factories/threads";
export class FlowImpl {
    constructor(flowDef, flowAnchor, flowOrchestrator) {
        this.flowDef = flowDef;
        this.flowAnchor = flowAnchor;
        this.flowOrchestrator = flowOrchestrator;
        this.isRunning = false;
    }
    start(initialStatus) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.STARTING, initialStatus).start();
        if (this.isRunning) {
            throw new Error(`can't request a flow that it has been started to start again`);
        }
        this.flowThread = this.flowAnchor.createNewThread(this, this.flowOrchestrator);
        this.isRunning = true;
        if (initialStatus == null && this.flowDef.starter == null) {
            this.requestStatus($INIT);
            return this;
        }
        let actualStarter = initialStatus ? initialStatus : this.flowDef.starter();
        let doStart = (status) => {
            this.addReaction($INIT, {
                action: () => {
                    tracker.debug('initialStatus', status);
                    this.requestStatus(status);
                },
                reactionType: ReactionType.ONCE,
                name: 'to initial state'
            });
            this.addReaction($STOP, {
                name: `onStop=>notifyEvents`,
                reactionType: ReactionType.ONCE,
                action: onStop => {
                    onStop.chain(() => {
                        tracker.debug('state machine stopped');
                        this.flowThread = null;
                        this.isRunning = false;
                    });
                }
            });
            this.requestStatus($INIT);
        };
        AsapParser.from(actualStarter).then(status => doStart(status));
        tracker.end();
        return this;
    }
    requestStatus(statusLike) {
        let statusName = StatusLikeParser.parse(statusLike).name;
        if (!this.isRunning)
            return;
        if (this.on(statusName) == null) {
            throw new Error(`unable to request non existing status [${statusName}]`);
        }
        this.flowThread.requestStatus(statusLike, false);
    }
    requestState(statusName, data) {
        if (!this.isRunning)
            return;
        this.flowThread.requestState(statusName, data);
    }
    requestTransition(transition) {
        if (!this.isRunning)
            return;
        this.flowThread.requestTransition(transition, false);
        return this;
    }
    requestStep(statusName, reducerName, payload, data) {
        if (!this.isRunning)
            return;
        this.flowThread.requestStep(statusName, reducerName, payload, data);
    }
    stop(eventsCb) {
        if (!this.isRunning) {
            throw new Error(`unexpected`);
        }
        this.addReaction($STOP, {
            name: `onStop=>notifyEvents`,
            reactionType: ReactionType.ONCE,
            action: () => {
                if (eventsCb) {
                    eventsCb(this.flowAnchor.getCurrentEvents());
                }
            }
        });
        this.requestStatus({
            name: $STOP
        });
        return this;
    }
    alwaysOn(stateName, def) {
        return this.addReaction(stateName, {
            name: `-`,
            reactionType: ReactionType.ALWAYS,
            action: def
        });
    }
    onceOnInit(def) {
        return this.onceOn($INIT, def);
    }
    onceOnStop(def) {
        return this.onceOn($STOP, def);
    }
    onceOn(stateName, def, name) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.ONCE_ON, stateName).start();
        tracker.debug(`[onceOn(${stateName})`);
        let flow = this.addReaction(stateName, {
            name: name != null ? name : `[userCode]`,
            reactionType: ReactionType.ONCE,
            action: def
        });
        tracker.end();
        return flow;
    }
    addReaction(statusName, reaction) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.ADDING_REACTION).start();
        let needsToBeAdded = true;
        if (this.isRunning) {
            if (this.flowThread.tryToQueue(statusName, reaction)) {
                tracker.info([`queueing reaction: ${reaction.name}`]);
                tracker.end();
                return this;
            }
            this.runIf(statusName, {
                action: (context) => {
                    reaction.action(context);
                    if (reaction.reactionType === ReactionType.ONCE) {
                        needsToBeAdded = false;
                    }
                },
                reactionType: reaction.reactionType,
                name: reaction.name
            });
        }
        if (needsToBeAdded) {
            let statusDef = this.on(statusName);
            if (statusDef == null) {
                throw new Error(`unable to add reactions for unknown event [${statusName}]`);
            }
            this.addReactionNext(statusDef, reaction);
        }
        tracker.end();
        return this;
    }
    addReactionNext(statusDef, reaction) {
        statusDef.reactions.push(reaction);
        return this;
    }
    getReactions(statusName) {
        let statusDef = this.on(statusName);
        if (statusDef == null) {
            throw new Error(`can't getReactions for unknown status[${statusName}]`);
        }
        return statusDef.reactions;
    }
    getCurrentStatusName() {
        if (this.flowThread == undefined)
            return undefined;
        return this.flowThread.getCurrentStatusName();
    }
    getEvents() {
        return this.flowAnchor.getCurrentEvents();
    }
    getName() {
        return this.flowDef.name;
    }
    getState() {
        return this.flowThread.getCurrentState();
    }
    getStatusData() {
        return this.flowAnchor.getStatusData();
    }
    onInit() {
        return this.on($INIT);
    }
    on(statusName) {
        return this.flowDef.statusesByStatusName[statusName];
    }
    getStatusDefs() {
        return this.flowDef.statusesByStatusName;
    }
    removeReaction(statusName, reactionToRemove) {
        let statusDef = this.on(statusName);
        let previousReactions = statusDef.reactions;
        if (!previousReactions)
            return;
        statusDef.reactions = previousReactions.filter(it => it !== reactionToRemove);
    }
    processReactions(statusName) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.PROCESSING_REACTIONS).start();
        let reactions = this.getReactions(statusName);
        let reactionNames = reactions.map(it => it.name).join(',');
        tracker.info(`ABOUT TO PROCESS: ${reactionNames}`);
        let onAllReactionsCompleted;
        reactions.forEach(reaction => {
            tracker.info(`START: ${reaction.name}`);
            if (reaction.reactionType === ReactionType.ONCE) {
                this.removeReaction(statusName, reaction);
            }
            reaction.action(this.flowThread.createContext(statusName, (cb) => onAllReactionsCompleted = cb));
            tracker.info(`END:  ${reaction.name}`);
        });
        tracker.info(`REACTIONS PROCESSED${reactionNames}`);
        if (onAllReactionsCompleted) {
            onAllReactionsCompleted();
        }
        tracker.end(statusName);
        return this;
    }
    getStateData() {
        throw new Error(`TBI`);
    }
    reactOnStatusChanged(customReaction) {
        Object.keys(this.getStatusDefs()).forEach(stateName => {
            this.addReaction(stateName, {
                name: `-`,
                reactionType: ReactionType.ALWAYS,
                action: context => customReaction({ name: stateName, data: context.getData() })
            });
        });
        return this;
    }
    runIf(statusName, reaction, elseIf) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.RUN_IF, reaction.name).start();
        if (!this.isRunning) {
            if (elseIf)
                elseIf();
            tracker.end();
            return;
        }
        let currentStatus = this.getCurrentStatusName();
        if (currentStatus == null) {
            if (elseIf) {
                elseIf();
            }
            tracker.end();
            return;
        }
        if (currentStatus === statusName) {
            this.doRun(reaction, statusName);
        }
        else {
            if (elseIf) {
                elseIf();
            }
        }
        tracker.end();
    }
    doRun(reaction, currentState) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.RUN, reaction.name).start();
        tracker.debug(`${reaction.name}`);
        reaction.action(this.flowThread.createContext(currentState, (cb) => cb()));
        tracker.end();
    }
    assertOn(status, then) {
        let currentStatusName = this.getCurrentStatusName();
        if (currentStatusName !== status) {
            throw new Error(`asserting that we are on the status [${status}]. But we are currently on [${currentStatusName}]`);
        }
        if (then) {
            this.onceOn(status, onAssertedStatus => then(onAssertedStatus));
        }
        return this;
    }
    chainInto(statusFrom, statusTo, mutatorsCb, name) {
        let chainName = name != null ? name : `chainInto-${this.getName()}:${statusTo}`;
        const [next, asap] = Asaps.next(chainName, FlowEventNature.AUX);
        this.addReactionNext(this.on(statusTo), {
            name: chainName,
            reactionType: ReactionType.ONCE,
            action: onChain => next(onChain)
        });
        if (this.getCurrentStatusName() !== '$init') {
            this.assertOn(statusFrom);
            this.onceOn(statusFrom, onThisStatus => mutatorsCb(onThisStatus.do), 'chain-' + chainName);
        }
        else {
            let statusToDef = this.getStatusDefs()[statusTo];
            this.onceOn(`$init`, () => mutatorsCb(statusToDef.steps), 'chain-' + chainName);
        }
        return asap;
    }
    deferInto(statusFrom, statusTo, mutatorsCbAsapLike) {
        let description = `[${this.getName()}]::${statusFrom}=>${statusTo}`;
        let defer = deferParser(mutatorsCbAsapLike, {
            name: description,
            payload: description
        });
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.MONITORING, {
            asap: defer.action,
            name: defer.name,
            payload: defer.payload
        }).start();
        if (defer.action.type === AsapType.LATER) {
            tracker.milestone(`START monitoring - ${defer.name}`, defer.payload);
        }
        return defer.action.chain(cb => {
            if (defer.action.type === AsapType.LATER) {
                tracker.debug(`STOP monitoring - ${defer.name}`);
            }
            tracker.end();
            return this.chainInto(statusFrom, statusTo, cb);
        }).onCancel(() => {
            tracker.cancel();
        });
    }
    changeLoggingNature(nature) {
        this.flowDef.nature = nature;
    }
    log(msg) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.USER_MSG, FlowEventType.USER_CODE, msg).start();
        let flowRuntimeTracker = tracker.milestone(undefined, msg);
        tracker.end();
        return flowRuntimeTracker;
    }
    createRuntimeTracker(runtimeEvent, payload) {
        return this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, runtimeEvent, payload);
    }
    getDefinition() {
        return this.flowDef;
    }
    toStateAll() {
        let thread = Threads.create({
            name: `${this.getName()}=>[all statuses]`
        });
        this.reactOnStatusChanged(status => thread.do.$update(status));
        return thread;
    }
    toState(statusName) {
        let thread = Threads.create({ name: `${this.getName()}=>[states:${statusName}]` });
        this.alwaysOn(statusName, (state) => thread.do.$update(state.getData()));
        return thread;
    }
}
//# sourceMappingURL=flowImpl.js.map