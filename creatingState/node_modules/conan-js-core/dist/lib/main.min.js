"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var InjectableType,React=require("react");class DynamicOrStatics{static result(t,e){return"function"==typeof t?t(e):t}}class Strings{static firstCharToLowerCase(t){return t.substring(0,1).toLowerCase()+t.substring(1,t.length)}static firstCharToUpperCase(t){return t.substring(0,1).toUpperCase()+t.substring(1,t.length)}static camelCaseWithPrefix(t,e){return t+this.firstCharToUpperCase(e)}static repeat(t,e){let a="";for(let n=0;n<e;n++)a+=t;return a}static padEnd(t,e){if(null==t)return t;let a=e-t.length;if(a<1){let a="...",n=1,s=n+(t.length+a.length-e);return t.substring(0,n)+a+t.substring(s,t.length)}return t+" ".repeat(a)}}class DiUtils{static beanName(t){return Strings.firstCharToLowerCase(t.name)}}!function(t){t.DYNAMIC="dynamic",t.NAME="name",t.TYPE="type"}(InjectableType||(InjectableType={}));class MetadataCrudUtils{constructor(t,e){this.spaceName=t,this.defaultProvider=e}updateMetadata(t,e){let a=this.getOrCreateMetadata(t);if(null==a)throw Error("can't get or create metaData");return e(a),a}assignMetaDataToConstructor(t,e){let a=this.getPrototype(t);null==a.$a&&(a.$a={}),null==a.$a[this.spaceName]&&(a.$a[this.spaceName]={});let n=MetadataCrudUtils.extractName(t);a.$a[this.spaceName][n]=e}getAnnotationsMetaData(t){let e=t;e.$a||(e=this.getPrototype(t));let a=e.$a;if(null==a)return null;let n=a[this.spaceName];return null==n?null:n[MetadataCrudUtils.extractName(t)]}getOrCreateMetadata(t){if(null==this.getAnnotationsMetaData(t)){let e=this.defaultProvider();this.assignMetaDataToConstructor(t,e)}return this.getAnnotationsMetaData(t)}getPrototype(t){return"object"==typeof t?t:"object"==typeof t.prototype?t.prototype:this.getPrototype(Object.getPrototypeOf(t))}static extractName(t){let e=t.name;return null==e&&(e=t.constructor.name),e.substring(0,1).toLowerCase()+e.substring(1,e.length)}}let diAnnotationsCrud=new MetadataCrudUtils("$di",()=>({diAnnotations:[]}));function InjectByType(t,e){return(a,n,s)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:s,injectable:t,type:InjectableType.TYPE,cascadeProperties:e}))}}function InjectDynamic(t,e){return(a,n,s)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:s,injectable:t,type:InjectableType.DYNAMIC,cascadeProperties:e}))}}function InjectByName(t,e){return console.log("Inject by name",t),(a,n,s)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:s,injectable:t,type:InjectableType.NAME,cascadeProperties:e}))}}const STRIP_COMMENTS=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,ARGUMENT_NAMES=/([^\s,]+)/g;class Functions{static extractArgNames(t){if(0===t.length)return[];let e=t.toString().replace(STRIP_COMMENTS,""),a=e.slice(e.indexOf("(")+1,e.indexOf(")")).match(ARGUMENT_NAMES);return null===a&&(a=[]),a}}class DiAnnotationsMetadataFactory{create(t){let e=DiUtils.beanName(t),a=Functions.extractArgNames(t),n={},s=diAnnotationsCrud.getAnnotationsMetaData(t);return s&&s.diAnnotations.forEach(t=>{let e=a[t.onConstructorParamIndex];n[e]={name:e,type:t.type,payload:t.injectable,propsProvider:t.cascadeProperties}}),{dependencyName:e,argumentNames:a,diParams:n,constructor:t}}}class DiRuntime{constructor(t,e){this.diInvocationResolver=t,this.diInvocationBuilderFactory=e}invoke(t,e,a){if("object"==typeof t)return t;let n=this.diInvocationBuilderFactory.root(t).if(null!=e,t=>t.withTransitiveBeans(e)).build(),s=this.diInvocationResolver.resolve(n,a,this).result;if(null==s)throw Error("Can't invoke");return s}invokeWithProps(t,e,a,n){let s=this.diInvocationBuilderFactory.root(t).withProperties(e).if(null!=a,t=>t.withTransitiveBeans(a)).build(),r=this.diInvocationResolver.resolve(s,n,this).result;if(null==r)throw Error("Can't invoke");return r}}DiRuntime.PROPS_PROPERTY_NAME="$props";class DiInvocationResolver{constructor(t,e,a){this.diInvocationFactory=t,this.diCache=e,this.diEnricher=a}resolve(t,e,a){if(this.causesCircularDependency(t))return{circularDependencyEndOf:t.diMetadata.dependencyName,result:null,pendingDependencies:{}};let n=null,s=this.diCache.resolve(t.diMetadata.dependencyName,()=>(n=this.doCreate(t,e,a),this.diEnricher&&(n.result=this.diEnricher(t.diMetadata,n.result)),Object.keys(n.pendingDependencies).indexOf(t.diMetadata.dependencyName)>-1&&n.pendingDependencies[t.diMetadata.dependencyName].forEach(e=>{this.diCache.resolve(e,null)[t.diMetadata.dependencyName]=n.result}),n.result));return null==n?{result:s,pendingDependencies:{}}:n}causesCircularDependency(t){return t.inProcessDiInvocations.indexOf(t.diMetadata.dependencyName)>-1}doCreate(t,e,a){const n=(t,e)=>{let a=t.diMetadata.constructor;return a.prototype&&a.prototype.constructor.name?e?new a(...e):new a:e?a(...e):a()};if(0===t.diMetadata.argumentNames.length){return{result:n(t,void 0),pendingDependencies:{}}}let s=[],r={};return this.invokeChildren(t,e,a).forEach(e=>{s.push(e.result),null!=e.circularDependencyEndOf&&DiInvocationResolver.addValueToKeyValuePairs(r,e.circularDependencyEndOf,t.diMetadata.dependencyName),e.pendingDependencies&&Object.keys(e.pendingDependencies).forEach(t=>{DiInvocationResolver.addValuesToKeyValuePairs(r,t,e.pendingDependencies[t])})}),{result:n(t,s),pendingDependencies:r}}static addValueToKeyValuePairs(t,e,a){t[e]||(t[e]=[]),t[e].indexOf(a)>-1||t[e].push(a)}static addValuesToKeyValuePairs(t,e,a){t[e]?a.forEach(a=>DiInvocationResolver.addValueToKeyValuePairs(t,e,a)):t[e]=a}invokeChildren(t,e,a){let n=[];return t.diMetadata.argumentNames.forEach(s=>{let r=this.resolveParamDef(t,s);n.push(this.invokeChild(t,r,e,a))}),n}resolveParamDef(t,e){let a=t.diMetadata.diParams[e];return null==a?{name:e,propsProvider:null,payload:e,type:InjectableType.NAME}:a}invokeChild(t,e,a,n){return e.name===DiRuntime.PROPS_PROPERTY_NAME?this.resolveChildProps(t):e.type===InjectableType.TYPE?this.resolveChildByType(t,e,a,n):e.type===InjectableType.DYNAMIC?this.resolveDynamicChild(t,e,a,n):this.resolveChildByName(t,e,a,n)}resolveChildProps(t){if(null==t.properties)throw Error("can't resolve properties for $props - There are no properties passed to the beanRuntime");return{result:t.properties,pendingDependencies:{}}}resolveChildByType(t,e,a,n){return this.resolve(this.diInvocationFactory.childrenOf(t,e.payload,e.propsProvider),a,n)}resolveDynamicChild(t,e,a,n){return this.resolveChildByType(t,{payload:e.payload(),type:InjectableType.TYPE,propsProvider:e.propsProvider,name:e.name},a,n)}resolveChildByName(t,e,a,n){let s=e.payload;if(null==t.transitiveBeans||null==t.transitiveBeans[s]){if(null!=a[s]){return{result:n.invoke(a[s],t.transitiveBeans,a),pendingDependencies:{}}}throw Error(`can't resolve param '${s}' - There are no transitive beans passed into the runtime`)}return{result:t.transitiveBeans[s],pendingDependencies:{}}}}class DiInvocationBuilderFactory{constructor(t){this.diAnnotationsMetadataFactory=t}childrenOf(t,e,a){let n=t.inProcessDiInvocations.slice(0);return n.push(t.diMetadata.dependencyName),new DiInvocationBuilder(this.diAnnotationsMetadataFactory,e).withInProcessDiInvocations(n).withTransitiveBeans(t.transitiveBeans).if(null!=a,t=>t.withProperties(a()))}root(t){return new DiInvocationBuilder(this.diAnnotationsMetadataFactory,t)}}class DiInvocationFactory{constructor(t){this.diInvocationBuilderFactory=t}childrenOf(t,e,a){return this.diInvocationBuilderFactory.childrenOf(t,e,a).build()}}class DiInvocationBuilder{constructor(t,e){this.diAnnotationsMetadataFactory=t,this._constructor=e,this.inProcessDiInvocations=[],this.transitiveBeans={},this.properties=null}if(t,e){return t&&e(this),this}withInProcessDiInvocations(t){return this.inProcessDiInvocations=t,this}withTransitiveBeans(t){return this.transitiveBeans=t,this}withProperties(t){return this.properties=t,this}build(){return{diMetadata:this.diAnnotationsMetadataFactory.create(this._constructor),inProcessDiInvocations:this.inProcessDiInvocations,transitiveBeans:this.transitiveBeans,properties:this.properties}}}class KeyValueCache{constructor(){this.cache={}}resolve(t,e){if(this.cache[t])return this.cache[t];if(null==e)throw Error("Can't resolve cache");let a=e();return this.cache[t]=a,a}}class DiRuntimeFactory{static create(t){return new DiRuntime(DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER(new KeyValueCache,t||null),DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY)}}DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY=new DiInvocationBuilderFactory(new DiAnnotationsMetadataFactory),DiRuntimeFactory.cacheTBR=(()=>new KeyValueCache),DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER=((t,e)=>new DiInvocationResolver(new DiInvocationFactory(DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY),DiRuntimeFactory.cacheTBR(),e));class DiContextFactory{static createContext(t,e){let a,n=DiRuntimeFactory.create(),s=Object.assign(Object.assign({},t),e);a=e?[...Object.keys(t),...Object.keys(e)]:Object.keys(t);let r={},i=Object.assign(Object.assign({},t),e);return a.forEach(t=>{let e=s[t];r[t]=n.invoke(e,r,i)}),r}}!function(t){t.IDLE="IDLE",t.ASYNC_START="ASYNC_START",t.ASYNC_FULFILLED="ASYNC_FULFILLED",t.ASYNC_CANCELLED="ASYNC_CANCELLED"}(exports.MonitorStatus||(exports.MonitorStatus={}));const ReactStateContext=React.createContext(null);class StateMapConnect extends React.Component{constructor(t){super(t),this._isMounted=!1,this.lastMonitorInfo=void 0,this.lastState=void 0;let e=!0,a=this.props.into.prototype?this.props.into.prototype:this.props.into.name;this._mainDataReactionLock=this.props.from.addDataReaction({name:`connect | ${a}`,dataConsumer:t=>{this.lastState=t;let a=this.props.mapper(t,Object.assign({},this.props.from.actions),this.lastMonitorInfo);this._isMounted?this.setState(a):(e=!1,this.state=a)}}),this._asyncDataReactionLock=this.props.from.addAsyncReaction({name:`connect monitor| ${a}`,dataConsumer:t=>{this.lastMonitorInfo=t;let a=this.props.mapper(this.lastState,Object.assign({},this.props.from.actions),t);this._isMounted?this.setState(a):(e=!1,this.state=a)}}),e&&this.props.fallbackValue&&(this.state=this.props.fallbackValue(this.props.from.actions))}componentDidMount(){this._isMounted=!0}componentWillUnmount(){this._isMounted=!1,this._mainDataReactionLock.release(),this._asyncDataReactionLock&&this._asyncDataReactionLock.release()}render(){let t=this.props.into;return React.createElement(ReactStateContext.Provider,{value:this.props.from},React.createElement(t,Object.assign({},this.state)))}}const StateConnect=t=>React.createElement(StateMapConnect,{mapper:(t,e,a)=>({data:t,actions:e,monitorInfo:a}),into:t.into,from:t.from,fallbackValue:e=>({data:t.fallbackValue,actions:e,monitorInfo:{status:exports.MonitorStatus.IDLE}})}),stateConnect=(t,e,a)=>React.createElement(StateConnect,{from:t,into:e,fallbackValue:a}),stateMapConnect=(t,e,a,n)=>React.createElement(StateMapConnect,{from:t,into:e,fallbackValue:n,mapper:a});function useFlow(t,e,a){React.useEffect(()=>{t.reactOnStatusChanged(t=>{e(e=>a?a(t,e):t.name)})},[])}function useFlowStatus(t,e,a,n){React.useEffect(()=>{t.alwaysOn(e,t=>{a(e=>n?n(t.getData(),e):t.getData())})},[])}function useConantState(t,e){let a=t.getData();const[n,s]=React.useState(null==a?e:a);return React.useEffect(()=>{const e=t.addDataReaction({dataConsumer:s,name:`useConanState[${t.getName()}]`});return()=>e.release()},[]),[n,t.actions,({children:e})=>React.createElement(ReactStateContext.Provider,{value:t},e)]}function useContextConantState(){let t=useConantState(React.useContext(ReactStateContext));return[t[0],t[1]]}class ContextStateMapConnect extends React.Component{render(){return React.createElement(ReactStateContext.Consumer,null,t=>{if(null==t)throw new Error("trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?");return React.createElement(StateMapConnect,{from:t,into:this.props.into,mapper:this.props.mapper,fallbackValue:this.props.fallbackValue})})}}class ContextStateConnect extends React.Component{render(){return React.createElement(ReactStateContext.Consumer,null,t=>{if(null==t)throw new Error("trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?");return React.createElement(StateConnect,{from:t,into:this.props.into,fallbackValue:this.props.fallbackValue})})}}const contextStateConnect=(t,e)=>React.createElement(ContextStateConnect,{into:t,fallbackValue:e}),contextStateMapConnect=(t,e,a)=>React.createElement(ContextStateMapConnect,{into:t,fallbackValue:a,mapper:e}),ContextStateLive=t=>{return React.createElement(ContextStateConnect,{into:e=>t.renderer(e.data,e.actions),fallbackValue:t.fallbackValue})},StateLive=t=>{return React.createElement(StateConnect,{from:t.from,into:e=>{let a=t.renderer(e.data,e.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:t.fallbackValue})},contextStateLive=(t,e)=>{return React.createElement(ContextStateConnect,{into:e=>{let a=t(e.data,e.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:e})},stateLive=(t,e,a)=>{return React.createElement(StateConnect,{from:t,into:t=>{let a=e(t.data,t.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:a})};var ReactionType,FlowRuntimeEventSource,FlowRuntimeEventTiming,FlowRuntimeEventType,StatusEventType,BindBackType;!function(t){t.ONCE="ONCE",t.ALWAYS="ALWAYS"}(ReactionType||(ReactionType={}));class ThreadImpl{constructor(t){this.flow=t}start(t){return this.flow.start(t?{name:"nextData",data:t}:void 0),this}next(t){this.flow.onceOn("nextData",t)}stop(t){this.flow.stop(t)}chain(t){return this.flow.chainInto("nextData","nextData",t).map(t=>t.getData())}monitor(t,e,a,n){let s=t.map(t=>a=>e(t,a)),r={payload:n,name:null==a?"anonymous":a,action:s};return this.flow.deferInto("nextData","nextData",r).map(t=>t.getData())}get isRunning(){return this.flow.isRunning}get reducers(){return this.flow.on("nextData").steps}addReaction(t){let e={name:t.name,reactionType:ReactionType.ALWAYS,action:e=>t.dataConsumer(e.getData())};return this.flow.addReaction("nextData",e),{release:()=>{this.flow.removeReaction("nextData",e)}}}getData(){return this.flow.getStatusData().nextData}getEvents(){return this.flow.getEvents()}getName(){return this.flow.getName()}}class Objects{static mapKeys(t,e,a){let n={};return Object.keys(t).forEach(s=>{let r=a?a(s):s;n[r]=e(t[s])}),n}static foreachEntry(t,e){Object.keys(t).forEach(a=>{e(t[a],a)})}static keyfy(t,e){return t.reduce((t,a)=>Object.assign(Object.assign({},t),{[e(a)]:a}),{})}static navigate(t,e){let a=[],n=t;for(;n;)null!==(n=e(n))&&a.push(n);return a}static deepEqualsArrays(t,e){if(t.length!==e.length)return!1;for(let a of t)if(-1===e.indexOf(a))return!1;return!0}static deepEqualsObjects(t,e){for(let a of Object.keys(t))if(!Objects.deepEquals(t[a],e[a]))return!1;return!0}static deepEquals(t,e){return null==t&&null==e||(null!=t||null==e)&&((null==t||null!=e)&&("string"==typeof t&&"string"==typeof e?t===e:"number"==typeof t&&"number"==typeof e?t===e:"function"==typeof t&&"function"==typeof e?t===e:"boolean"==typeof t&&"boolean"==typeof e?t===e:void 0===t&&void 0===e?t===e:Array.isArray(t)&&Array.isArray(e)?Objects.deepEqualsArrays(t,e):!(Array.isArray(t)&&!Array.isArray(e))&&(!(!Array.isArray(t)&&Array.isArray(e))&&("object"==typeof t&&"object"==typeof e?Objects.deepEqualsObjects(t,e):t===e))))}}class StatusLikeParser{static parse(t){return"string"==typeof t?{name:t}:t}}class FlowRequest{constructor(t,e,a,n){this.flowThread=t,this.id=e,this.status=a,this.isStep=n,this.queuedReactions=[],this.queuedTransitions=[],this.queuedSteps=[],this.queuedStatuses=[],this.queuedStates=[],this.started=!1,this.processingStatus={id:this.id,status:this.status}}static statusRequest(t,e,a,n){return new FlowRequest(t,e,a,n)}static transitionRequest(t,e,a,n){return new FlowRequest(t,e,StatusLikeParser.parse(a.into),n)}start(){if(this.started)throw new Error("unexpected");this.started=!0,this.flowThread.processStateAndReactions(this.processingStatus,this.isStep),this.flowThread.flagAsSettled(this.processingStatus,this.isStep),this.flowThread.onStateRequestCompleted(this,this.queuedReactions,this.queuedStatuses,this.queuedStates,this.queuedTransitions,this.queuedSteps)}queueStatus(t){this.queuedStatuses.push(t)}queueTransition(t){return this.queuedTransitions.push(t),this}queueStep(t){return this.queuedSteps.push(t),this}queueState(t){this.queuedStates.push(t)}queueReaction(t,e){this.queuedReactions.push([t,e])}}!function(t){t.FLOW_CONTROLLER="FLOW_CONTROLLER",t.FLOW_THREAD="FLOW_THREAD",t.CONTEXT="CONTEXT",t.FLOW_FACTORY="FLOW_FACTORY"}(FlowRuntimeEventSource||(FlowRuntimeEventSource={})),function(t){t.REQUEST_START="REQUEST_START",t.REQUEST_END="REQUEST_END",t.REQUEST_CANCEL="REQUEST_CANCEL",t.USER_TRACE="USER_TRACE",t.TRACE="TRACE",t.INFO="INFO"}(FlowRuntimeEventTiming||(FlowRuntimeEventTiming={})),function(t){t.MONITOR="MONITOR",t.PROCESS_REACTIONS="PROCESS_REACTIONS",t.START="START",t.REQUEST_STATUS="REQUEST_STATUS",t.FLAG_AS_SETTLED="FLAG_AS_SETTLED",t.USER_MSG="USER_MSG",t.REQUEST_TRANSITION="REQUEST_TRANSITION",t.CREATE_FLOW="CREATE_FLOW"}(FlowRuntimeEventType||(FlowRuntimeEventType={}));class FlowThread{constructor(t,e,a){this.flowController=t,this.flowOrchestrator=e,this.flowEvents=a,this.ids={}}requestStatus(t,e){let a=StatusLikeParser.parse(t),n=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowRuntimeEventSource.FLOW_THREAD,FlowRuntimeEventType.REQUEST_STATUS,t).highlight(FlowRuntimeEventTiming.REQUEST_START,`${a.name}`);if(this.assertValidStatus(a.name),null!=this.currentRequest)return void(e?(n.trace(FlowRuntimeEventTiming.TRACE,`queueing state [${a.name}]`),this.currentRequest.queueState(a)):(n.trace(FlowRuntimeEventTiming.TRACE,`queueing status [${a.name}]`),this.currentRequest.queueStatus(a)));let s=this.getNextId(a);this.currentRequest=FlowRequest.statusRequest(this,s+"",a,e),this.currentRequest.start(),n.trace(FlowRuntimeEventTiming.REQUEST_END)}requestTransition(t,e){let a=StatusLikeParser.parse(t.into).name,n=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowRuntimeEventSource.FLOW_THREAD,FlowRuntimeEventType.REQUEST_TRANSITION,t).highlight(FlowRuntimeEventTiming.REQUEST_START,`${t.transitionName}`);if(n.highlight(FlowRuntimeEventTiming.INFO,e?"step":"Transition",t.transitionName),this.assertValidStatus(a),null!=this.currentRequest)return void(e?(n.trace(FlowRuntimeEventTiming.TRACE,`queueing step [${t.transitionName}]`),this.currentRequest.queueStep(t)):(n.trace(FlowRuntimeEventTiming.TRACE,`queueing transition [${t.transitionName}]`),this.currentRequest.queueTransition(t)));let s=this.getNextId(StatusLikeParser.parse(t.into));this.currentRequest=FlowRequest.transitionRequest(this,s+"",t,e),this.onTransitionRequested(t,e),this.currentRequest.start(),n.trace(FlowRuntimeEventTiming.REQUEST_END)}requestStep(t,e,a,n){this.assertValidStatus(t);let s=this.getCurrentStatusName();if(s!==t)throw new Error(`car't request step on [${t}] as the current status is[${s}]`);this.requestTransition({transitionName:e,payload:a,into:{name:t,data:n}},!0)}requestState(t,e){this.assertValidStatus(t);let a=this.getCurrentStatusName();if(a!==t)throw new Error(`car't request state on [${t}] as the current status is[${a}]`);this.requestStatus({name:t,data:e},!0)}tryToQueue(t,e){return null!=this.currentRequest&&(this.currentRequest.queueReaction(t,e),!0)}onTransitionRequested(t,e){this.flowEvents.addTransition(t,e)}getNextId(t,e=!1){null==this.ids[t.name]&&(this.ids[t.name]=0);let a=this.ids[t.name]+1;return e?a:(this.ids[t.name]=a,this.ids[t.name])}processStateAndReactions(t,e){this.flowEvents.addProcessingStatus(t,e),this.flowController.processReactions(t.status.name)}flagAsSettled(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowRuntimeEventSource.FLOW_THREAD,FlowRuntimeEventType.FLAG_AS_SETTLED,t).highlight(FlowRuntimeEventTiming.REQUEST_START,`${t.status.name}`);this.flowEvents.settleProcessingStatus(t,e),e?a.highlight(FlowRuntimeEventTiming.INFO,"STATE",t.status.data):a.highlight(FlowRuntimeEventTiming.INFO,"STATUS",t.status),a.trace(FlowRuntimeEventTiming.REQUEST_END)}onStateRequestCompleted(t,e,a,n,s,r){if(null==this.currentRequest)throw new Error(`can't complete the request for [${this.flowController.getName()} - ${t.status.name}] as is not flagged as currently in process`);if(this.currentRequest!=t)throw new Error(`can't complete the request for [${this.flowController.getName()} - ${t.status.name}] as it does not match [${this.currentRequest.status.name}]`);if(s.length>0&&a.length>0)throw new Error("can't have transitions and states forked at the same time!");if(this.currentRequest=void 0,s.length>1||a.length>1)throw new Error("TBI");s.forEach(t=>this.flowController.requestTransition(t)),a.forEach(t=>this.flowController.requestStatus(t)),n.forEach(t=>this.flowController.requestState(t.name,t.data)),r.forEach(t=>{let e=StatusLikeParser.parse(t.into);this.flowController.requestStep(e.name,t.transitionName,t.payload,e.data)}),e.forEach(t=>this.flowController.addReaction(t[0],t[1]))}createContext(t,e){let a=StatusLikeParser.parse(t);return{getData:this.flowController.getState.bind(this.flowController),getStatusData:this.flowController.getStatusData.bind(this.flowController),do:Object.assign(Object.assign({},this.flowController.on(a.name).transitions),this.flowController.on(a.name).steps),chain(t){e(t)},interruptFlow:()=>{this.flowController.stop()},trace:t=>{let e=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowRuntimeEventSource.CONTEXT,FlowRuntimeEventType.USER_MSG,t).highlight(FlowRuntimeEventTiming.REQUEST_START,`${t}`),a=e.highlight(FlowRuntimeEventTiming.USER_TRACE,void 0,t);return e.trace(FlowRuntimeEventTiming.REQUEST_END),a}}}getCurrentStatusName(){let t=this.flowEvents.currentStatus;return null==t?void 0:t.name}getCurrentState(){let t=this.flowEvents.currentStatus;return null==t?void 0:t.data}assertValidStatus(t){if(null==this.flowController.on(t))throw new Error(`error requesting a transition into [${t}] unknown status, valid statuses are: [${Object.keys(this.flowController.getStatusDefs()).join(", ")}]`)}}!function(t){t.TRANSITION="TRANSITION",t.STEP="STEP",t.STATUS="STATUS",t.PROCESSING_STATUS="PROCESSING_STATUS",t.STATE="STATE",t.PROCESSING_STATE="PROCESSING_STATE"}(StatusEventType||(StatusEventType={}));class FlowEventsTracker{constructor(){this.eventsByStatus={},this.events=[]}addTransition(t,e){let a,n=StatusLikeParser.parse(t.into);a=e?{type:StatusEventType.STEP,reducerName:t.transitionName,newData:n.data,reducerPayload:t.payload}:{type:StatusEventType.TRANSITION,fromStatus:this.currentStatus.name,intoStatus:n,transitionName:t.transitionName,transitionPayload:t.payload},this.lastEvent=a,this.process(a)}addStateFromStatus(t){this.lastEvent=t,this.process(t)}addProcessingStatus(t,e){let a;a=e?{type:StatusEventType.PROCESSING_STATE,data:t.status.data}:{type:StatusEventType.PROCESSING_STATUS,status:t.status},this.currentStatus=t.status,this.lastEvent=a,this.process(a)}settleProcessingStatus(t,e){if(e){if(this.lastEvent.data!==t.status.data)throw new Error("unexpected error settling events");this.lastEvent.type=StatusEventType.STATE,this.eventsByStatus[this.currentStatus.name].lastState=t.status.data}else{if(this.lastEvent.status!==t.status)throw new Error("unexpected error settling events");this.lastEvent.type=StatusEventType.STATUS,this.addStateFromStatus({data:t.status.data,type:StatusEventType.STATE})}}process(t){null==this.eventsByStatus[this.currentStatus.name]&&(this.eventsByStatus[this.currentStatus.name]={allEvents:[],statusName:this.currentStatus.name,lastState:void 0});let e={event:t,statusName:this.currentStatus.name};this.eventsByStatus[this.currentStatus.name].allEvents.push(e),t.type!==StatusEventType.STATE&&t.type!==StatusEventType.PROCESSING_STATE||(this.eventsByStatus[this.currentStatus.name].lastState=t.data),this.events.push(e)}serializeStatesWithStatus(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[StatusEventType.STATE]}))}serializeStates(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[StatusEventType.STATE]})).map(t=>t.event)}serializeStatuses(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[StatusEventType.STATUS]})).map(t=>t.event)}serialize(t){return this.serializeWithStatusInfo(t).map(t=>t.event)}serializeWithStatusInfo(t){if(!t)return this.events;let e=[];return this.events.forEach(a=>{let n=!0;n&&(t.excludeInit&&this.eventsByStatus.$init.allEvents.indexOf(a)>-1&&(n=!1),n&&(t.excludeStop&&this.eventsByStatus.$stop&&this.eventsByStatus.$stop.allEvents.indexOf(a)>-1&&(n=!1),n&&(t.statuses&&t.statuses.forEach(t=>{n||-1===this.eventsByStatus[t].allEvents.indexOf(a)&&(n=!1)}),n&&(t.eventTypes&&-1===t.eventTypes.indexOf(a.event.type)&&(n=!1),n&&e.push(a)))))}),e}getLastStates(){let t={};return Object.keys(this.eventsByStatus).forEach(e=>{t[e]=this.eventsByStatus[e].lastState}),t}getLastState(t){let e=this.eventsByStatus[t];if(null!=e)return e.lastState}}!function(t){t.STEP="STEP",t.TRANSITION="TRANSITION"}(BindBackType||(BindBackType={}));class FlowAnchor{createNewThread(t,e){let a=new FlowEventsTracker,n=new FlowThread(t,e,a);return this.currentThread={flowEvents:a,flowThread:n},n}getCurrentEvents(){return this.currentThread.flowEvents}get currentStatus(){if(this.currentThread)return this.currentThread.flowEvents.currentStatus}getStatusDataProducerFn(){return(t,e)=>{let a=this.currentThread.flowEvents.getLastStates();return-1===Object.keys(a).indexOf(t)?e:a[t]}}getDataFn(t){return()=>{let e=this.currentThread.flowEvents.currentStatus.name;if(t!==e)throw new Error(`unexpected error trying to retrieve the last status for [${t}, but the current status is [${e}]]`);return this.currentThread.flowEvents.getLastState(t)}}bindBack(t,e,a){if(this.currentThread.flowThread.flowController.isRunning){if("$stop"!=e.result.name&&(!this.currentStatus||this.currentStatus.name!==t))throw Error(`unable to request [${e.methodName}] as is meant for status [${t}], but the current status is [${this.currentStatus?this.currentStatus.name:"-"}]`);a===BindBackType.STEP?this.currentThread.flowThread.requestStep(e.statusName,e.methodName,e.payload,e.result):this.currentThread.flowThread.requestTransition({into:e.result,payload:e.payload,transitionName:e.methodName},!1)}}getStatusData(){return this.currentThread.flowEvents.getLastStates()}}class Proxyfier{static proxy(t,e){let a={},n=Object.getPrototypeOf(t),s="Object"===n.constructor.name?t:n;return Object.getOwnPropertyNames(s).forEach(n=>{if("constructor"===n)return;"function"==typeof s[n]&&(a[n]=((...a)=>{return e(()=>t[n](...a),{methodName:n,payload:a})}))}),a}}class MutatorsFactory{static createDefaultStepsDef(){return t=>({$update:e=>"function"!=typeof e?e:e(t())})}static createDefaultTransitionDef(){return()=>({$toStatus:t=>StatusLikeParser.parse(t)})}static createDefaultSteps(t,e){return this.createSteps(t,e,this.createDefaultStepsDef())}static createTransitions(t,e,a){let n=this.createDefaultTransitionDef();return this.doCreateTransitions(t,e,a?[a,n]:[n])}static createSteps(t,e,a){let n=this.createDefaultStepsDef();return this.doCreateSteps(t,e,a?[a,n]:[n])}static doCreateSteps(t,e,a){let n=e.getDataFn(t),s={};return a.forEach(t=>{let e=t(n);s=Object.assign(Object.assign({},s),e)}),this.bindToAnchor(t,e,s,BindBackType.STEP)}static doCreateTransitions(t,e,a){let n=e.getStatusDataProducerFn(),s={};return a.forEach(t=>{let e=t(n);s=Object.assign(Object.assign({},s),e)}),this.bindToAnchor(t,e,s,BindBackType.TRANSITION)}static bindToAnchor(t,e,a,n){return Proxyfier.proxy(a,(a,s)=>{let r=a();return e.bindBack(t,{statusName:e.currentStatus.name,methodName:s.methodName,payload:s.payload,result:r},n),r})}}const $INIT="$init",$STOP="$stop";class ReactionDefLikeParser{static parse(t,e,a){return"object"==typeof t?t:{name:a||"anonymous",reactionType:e,action:t}}}class FlowDefFactory{static create(t,e){let a=FlowDefFactory.statusesByName(t.statuses,e);return a[$INIT]={name:$INIT,steps:MutatorsFactory.createDefaultSteps($INIT,e),transitions:MutatorsFactory.createTransitions($INIT,e),reactions:t.$onInit?t.$onInit.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,"on init")):[]},a[$STOP]={name:$STOP,steps:MutatorsFactory.createDefaultSteps($STOP,e),transitions:MutatorsFactory.createTransitions($STOP,e),reactions:t.$onStop?t.$onStop.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,"on stop")):[]},Object.assign({statusesByStatusName:a,name:t.name},t.initialStatus?{starter:()=>t.initialStatus}:void 0)}static statusesByName(t,e){let a={};return Array.isArray(t)?t.forEach(t=>{a[t]={name:t,steps:[],reactions:[]}}):Objects.foreachEntry(t,(t,n)=>{a[n]={name:n,steps:MutatorsFactory.createSteps(n,e,t.steps),transitions:MutatorsFactory.createTransitions(n,e,t.transitions),reactions:t.reactions?t.reactions.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,`on[${n}]`)):[],getLastData:e.getDataFn(n)}}),a}}class FlowRuntimeTracker{constructor(t,e){this.orchestrator=t,this.event=e}trace(t,e,a){return this.doTick(t,e,a,{highlight:!1})}highlight(t,e,a){return this.doTick(t,e,a,{highlight:!0})}doTick(t,e,a,n){let s=Object.assign(Object.assign(Object.assign({},this.event),{shortDesc:e,timing:t}),a?{payload:a}:void 0);return this.orchestrator.onRuntimeEvent(this,s,n),this}}class FlowOrchestrator{constructor(t){this.eventsProcessor=t,this.pastTrackers=[]}onRuntimeEvent(t,e,a){e.timing===FlowRuntimeEventTiming.REQUEST_START?this.currentTracker=t:e.timing!==FlowRuntimeEventTiming.REQUEST_END&&e.timing!==FlowRuntimeEventTiming.REQUEST_CANCEL||(this.pastTrackers.push(t),this.currentTracker=void 0),this.eventsProcessor.forEach(t=>t(e,a))}createRuntimeTracker(t,e,a,n){return new FlowRuntimeTracker(this,{flowController:t,source:e,runtimeEvent:a,payload:n})}}class FlowLogger{constructor(t){this.filters=t}log(t,e){for(let e of this.filters)if(!e(t))return;let a=t.flowController.getCurrentStatusName();a=a||"-",e.highlight?(console.log(Strings.padEnd(`${t.flowController.getName()}`,30),Strings.padEnd(`${a}`,20),Strings.padEnd(`${t.runtimeEvent}`,20),Strings.padEnd(`${t.timing}`,20)),(t.payload||t.shortDesc)&&(t.shortDesc?(console.log(`  =>[${t.shortDesc}]`),t.payload&&console.log(" ",t.payload)):console.log(`  =>[${t.payload}]`)),console.log("------------------------------------------------------------------------------------------------------------------------------------------------")):t.shortDesc&&console.log(Strings.padEnd(`${t.flowController.getName()}`,30),Strings.padEnd(`${a}`,20),Strings.padEnd(`${t.runtimeEvent}`,20),Strings.padEnd(`${t.timing}`,20),Strings.padEnd(`=>${t.shortDesc}`,30))}}class LoggerFilters{static excludeByLogName(t){return e=>e.flowController.getName()!==t}static excludeByEventTiming(t){return e=>e.timing!==t}}const FLOW_LOGGER=new FlowLogger([LoggerFilters.excludeByEventTiming(FlowRuntimeEventTiming.REQUEST_END),LoggerFilters.excludeByEventTiming(FlowRuntimeEventTiming.REQUEST_START),LoggerFilters.excludeByLogName("next-promise")]);function isPromise(t){return null!=t&&("object"==typeof t&&("then"in t&&"function"==typeof t.then))}function isAsap(t){return t instanceof NowImpl||t instanceof LaterImpl}!function(t){t.NOW="NOW",t.LATER="LATER"}(exports.AsapType||(exports.AsapType={}));class NowImpl{constructor(t){this.rawValue=t,this.type=exports.AsapType.NOW}cancel(){return!1}then(t){return t(this.rawValue),this}map(t){return Asaps.now(t(this.rawValue))}merge(t){const[e,a]=Asaps.next();return this.then(a=>t(a).then(t=>e(t))),a}catch(t){return this}onCancel(t){return this}}class LaterImpl{constructor(t){this.flow=t,this.type=exports.AsapType.LATER}map(t){let[e,a]=Asaps.next();return this.then(a=>e(t(a))),this.onCancel(()=>a.cancel()),a}then(t){return"resolved"===this.flow.getCurrentStatusName()?t(this.flow.on("resolved").getLastData()):this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{then:[...e.then,t]})),this}resolve(t){if("cancelled"!==this.flow.getCurrentStatusName())try{this.flow.assertOn("resolving",e=>{e.getData().then.forEach(e=>{e(t)}),this.flow.on("resolving").transitions.$toStatus({name:"resolved",data:t})})}catch(e){console.error(e),this.flow.assertOn("resolving",a=>{a.getData().catch.forEach(a=>{a(e,t)}),a.do.$toStatus({name:"errored",data:t})})}}onCancel(t){if("cancelled"!==this.flow.getCurrentStatusName())return"resolving"===this.flow.getCurrentStatusName()&&this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{onCancel:[...e.onCancel,t]})),this;t()}cancel(){return"resolving"===this.flow.getCurrentStatusName()&&(this.flow.assertOn("resolving",t=>{t.getData().onCancel.forEach(t=>{t()}),this.flow.on("resolving").transitions.$toStatus({name:"cancelled"})}),!0)}merge(t){const[e,a]=Asaps.next();return this.then(n=>t(n).then(t=>e(t)).onCancel(()=>a.cancel())).onCancel(()=>a.cancel()),a}catch(t){return"resolving"===this.flow.getCurrentStatusName()&&this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{catch:[...e.catch,t]})),this}}class AsapParser{static from(t){return isAsap(t)?t:isPromise(t)?Asaps.fromPromise(t):Asaps.now(t)}}class Asaps{static now(t){return new NowImpl(t)}static fromPromise(t){let e=new LaterImpl(Flows.createController({name:"next-promise",statuses:{resolving:{},resolved:{},errored:{},cancelled:{}},initialStatus:{name:"resolving",data:{then:[],catch:[],onCancel:[]}}}).start());return t.then(t=>e.resolve(t)),t.catch(t=>e.catch(t)),e}static delayed(t,e){return Asaps.fromPromise(new Promise(a=>setTimeout(()=>a(t),e)))}static fetch(t){return Asaps.fromPromise(new Promise(e=>{fetch(t).then(t=>t.json()).then(function(t){e(t)})}))}static next(){let t=new LaterImpl(Flows.createController({name:"next-promise",statuses:{resolving:{},resolved:{},errored:{},cancelled:{}},initialStatus:{name:"resolving",data:{then:[],catch:[],onCancel:[]}}}).start());return[e=>t.resolve(e),t]}}function deferParser(t,e){return isAsap(t)?{action:t,name:e.name,payload:e.payload}:t}class FlowImpl{constructor(t,e,a){this.flowDef=t,this.flowAnchor=e,this.flowOrchestrator=a,this.isRunning=!1}start(t){let e=this.flowOrchestrator.createRuntimeTracker(this,FlowRuntimeEventSource.FLOW_CONTROLLER,FlowRuntimeEventType.START,t).trace(FlowRuntimeEventTiming.REQUEST_START);if(this.isRunning)throw new Error("can't request a flow that it has been started to start again");if(this.flowThread=this.flowAnchor.createNewThread(this,this.flowOrchestrator),this.isRunning=!0,null==t&&null==this.flowDef.starter)return this.requestStatus($INIT),this;let a=t||this.flowDef.starter(),n=t=>{this.addReaction($INIT,{action:()=>{e.highlight(FlowRuntimeEventTiming.TRACE,"initialStatus - resolved",t),this.requestStatus(t)},reactionType:ReactionType.ONCE,name:"to initial state"}),this.addReaction($STOP,{name:"onStop=>notifyEvents",reactionType:ReactionType.ONCE,action:t=>{t.chain(()=>{e.highlight(FlowRuntimeEventTiming.TRACE,"state machine stopped"),this.flowThread=null,this.isRunning=!1})}}),this.requestStatus($INIT)};return AsapParser.from(a).then(t=>n(t)),e.trace(FlowRuntimeEventTiming.REQUEST_END),this}requestStatus(t){let e=StatusLikeParser.parse(t).name;if(this.isRunning){if(null==this.on(e))throw new Error(`unable to request non existing status [${e}]`);this.flowThread.requestStatus(t,!1)}}requestState(t,e){this.isRunning&&this.flowThread.requestState(t,e)}requestTransition(t){if(this.isRunning)return this.flowThread.requestTransition(t,!1),this}requestStep(t,e,a,n){this.isRunning&&this.flowThread.requestStep(t,e,a,n)}stop(t){if(!this.isRunning)throw new Error("unexpected");return this.addReaction($STOP,{name:"onStop=>notifyEvents",reactionType:ReactionType.ONCE,action:()=>{t&&t(this.flowAnchor.getCurrentEvents())}}),this.requestStatus({name:$STOP}),this}alwaysOn(t,e){return this.addReaction(t,{name:"-",reactionType:ReactionType.ALWAYS,action:e})}onceOnInit(t){return this.onceOn($INIT,t)}onceOnStop(t){return this.onceOn($STOP,t)}onceOn(t,e){return this.addReaction(t,{name:"-",reactionType:ReactionType.ONCE,action:e})}addReaction(t,e){let a=!0;if(this.isRunning){if(this.flowThread.tryToQueue(t,e))return this;this.runIf(t,{action:t=>{e.action(t),e.reactionType===ReactionType.ONCE&&(a=!1)},reactionType:e.reactionType,name:e.name})}if(a){let a=this.on(t);if(null==a)throw new Error(`unable to add reactions for unknown event [${t}]`);this.addReactionNext(a,e)}return this}addReactionNext(t,e){return t.reactions.push(e),this}getReactions(t){let e=this.on(t);if(null==e)throw new Error(`can't getReactions for unknown status[${t}]`);return e.reactions}getCurrentStatusName(){if(void 0!=this.flowThread)return this.flowThread.getCurrentStatusName()}getEvents(){return this.flowAnchor.getCurrentEvents()}getName(){return this.flowDef.name}getState(){return this.flowThread.getCurrentState()}getStatusData(){return this.flowAnchor.getStatusData()}onInit(){return this.on($INIT)}on(t){return this.flowDef.statusesByStatusName[t]}getStatusDefs(){return this.flowDef.statusesByStatusName}removeReaction(t,e){let a=this.on(t),n=a.reactions;n&&(a.reactions=n.filter(t=>t!==e))}processReactions(t){let e,a=this.flowOrchestrator.createRuntimeTracker(this,FlowRuntimeEventSource.FLOW_CONTROLLER,FlowRuntimeEventType.PROCESS_REACTIONS,t).trace(FlowRuntimeEventTiming.REQUEST_START);return this.getReactions(t).forEach(a=>{a.reactionType===ReactionType.ONCE&&this.removeReaction(t,a),a.action(this.flowThread.createContext(t,t=>e=t))}),e&&e(),a.trace(FlowRuntimeEventTiming.REQUEST_END,t),this}getStateData(){throw new Error("TBI")}reactOnStatusChanged(t){return Object.keys(this.getStatusDefs()).forEach(e=>{this.addReaction(e,{name:"-",reactionType:ReactionType.ALWAYS,action:a=>t({name:e,data:a.getData()})})}),this}runIf(t,e,a){if(!this.isRunning)return void(a&&a());let n=this.getCurrentStatusName();null!=n&&n===t?this.doRun(e,t):a&&a()}doRun(t,e){t.action(this.flowThread.createContext(e,t=>t()))}assertOn(t,e){let a=this.getCurrentStatusName();if(a!==t)throw new Error(`asserting that we are on the status [${t}]. But we are currently on [${a}]`);return e&&this.onceOn(t,t=>e(t)),this}chainInto(t,e,a){const[n,s]=Asaps.next();return this.assertOn(t),this.addReactionNext(this.on(e),{name:"once on next",reactionType:ReactionType.ONCE,action:t=>n(t)}),this.onceOn(t,t=>a(t.do)),s}deferInto(t,e,a){let n=deferParser(a,{name:`[${this.getName()}]::${t}=>${e}`,payload:`[${this.getName()}]::${t}=>${e}`}),s=this.flowOrchestrator.createRuntimeTracker(this,FlowRuntimeEventSource.FLOW_CONTROLLER,FlowRuntimeEventType.MONITOR,{asap:n.action,name:n.name,payload:n.payload}).trace(FlowRuntimeEventTiming.REQUEST_START);return n.action.merge(a=>(s.trace(FlowRuntimeEventTiming.REQUEST_END),this.chainInto(t,e,a))).onCancel(()=>{s.trace(FlowRuntimeEventTiming.REQUEST_CANCEL)})}}class FlowFacadeImpl{constructor(t,e){this.flow=t,this.actions=e,this.do=e}addReaction(t,e){return this.flow.addReaction(t,e),this}alwaysOn(t,e){return this.flow.alwaysOn(t,e),this}assertOn(t,e){return this.flow.assertOn(t,e),this}chainInto(t,e,a){this.flow.chainInto(t,e,a)}getCurrentStatusName(){return this.flow.getCurrentStatusName()}getEvents(){return this.flow.getEvents()}getName(){return this.flow.getName()}getState(){return this.flow.getState()}getStatusData(){return this.flow.getStatusData()}on(t){return this.flow.on(t)}onceOn(t,e){return this.flow.onceOn(t,e),this}onceOnInit(t){return this.flow.onceOnInit(t),this}onceOnStop(t){return this.flow.onceOnStop(t),this}start(t){return this.flow.start(t),this}stop(t){return this.flow.stop(t),this}get isRunning(){return this.flow.isRunning}onInit(){return this.flow.onInit()}reactOnStatusChanged(t){return this.flow.reactOnStatusChanged(t),this}deferInto(t,e,a){return this.flow.deferInto(t,e,a)}removeReaction(t,e){this.flow.removeReaction(t,e)}}const FlowOrchestrator$=t=>new FlowOrchestrator([(t,e)=>FLOW_LOGGER.log(t,e),...t]);class Flows{static create(t){let e=this.createController(t);return this.createFacade(e,t.actions)}static createFacade(t,e){return new FlowFacadeImpl(t,e?e(t):void 0)}static createController(t){let e=new FlowAnchor,a=FlowOrchestrator$(t.pipelineListener?[t.pipelineListener]:[]),n=new FlowImpl(FlowDefFactory.create(t,e),e,a);return a.createRuntimeTracker(n,FlowRuntimeEventSource.FLOW_FACTORY,FlowRuntimeEventType.CREATE_FLOW,t).trace(FlowRuntimeEventTiming.REQUEST_START).trace(FlowRuntimeEventTiming.REQUEST_END,n),n}}class ThreadFacade{constructor(t,e){this.thread=t,this.actions=e}chain(t){this.thread.chain(t)}next(t){this.thread.next(t)}start(){return this.thread.start(),this}stop(t){return this.thread.stop(t),this}get do(){let t=this.reducers;return Object.assign(Object.assign({},t),this.actions)}get reducers(){return this.thread.reducers}addReaction(t){return this.thread.addReaction(t)}get isRunning(){return this.thread.isRunning}getData(){return this.thread.getData()}getEvents(){return this.thread.getEvents()}getName(){return this.thread.getName()}}class MethodFinder{static exists(t,e){return null!=t&&this.find(t,e).length>0}static find(t,e=""){let a=Object.getPrototypeOf(t),n="Object"===a.constructor.name?t:a;return Object.getOwnPropertyNames(n).filter(t=>t.startsWith(e))}}class Threads{static create(t){let e,a=Flows.createController(Object.assign(Object.assign({name:t.name,statuses:{nextData:Object.assign({},t.reducers?{steps:t.reducers}:void 0)}},null==t.initialData?void 0:{initialStatus:AsapParser.from(t.initialData).map(t=>({name:"nextData",data:t}))}),{pipelineListener:t.pipelineListener})),n=new ThreadImpl(a);if(t.actions&&t.autoBind)throw new Error("you can only use actions or autoBind. Both in conjunction is illegal");if(t.autoBind){let a=[],s=Object.assign({},t.autoBind);Object.keys(n.reducers).forEach(e=>{let r=e.substring(1,e.length);MethodFinder.exists(t.autoBind,r)?(s[r]=((...e)=>t.autoBind[r](...e)),a.push(r)):s[r]=((...t)=>n.chain(a=>a[e](...t)))}),e=new ThreadFacade(n,Proxyfier.proxy(s,(t,e)=>-1===a.indexOf(e.methodName)?t():n.monitor(t(),(t,a)=>a[`$${e.methodName}`](t),e.methodName,e.payload)))}else{let a=t.actions?t.actions(n):{};Object.keys(n.reducers).forEach(t=>{let e=t.substring(1,t.length);a[e]||(a[e]=((...e)=>n.chain(a=>a[t](...e))))}),e=new ThreadFacade(n,a)}return t.cancelAutoStart||e.start(),e}}class PipeMerge{constructor(t,e,a,n,s,r,i){this.name=t,this.base=e,this.leftThread=a,this.leftMapper=n,this.rightThread=s,this.rightMapper=r,this.pipeThreadDef=i}addReaction(t){return this.baseThread.addReaction(t)}chain(t){return this.baseThread.chain(t)}getData(){return this.baseThread.getData()}getEvents(){return this.baseThread.getEvents()}getName(){return this.baseThread.getName()}next(t){this.baseThread.next(t)}start(){return null==this.baseThread?(this.baseThread=Threads.create(Object.assign({name:this.name,initialData:this.base},this.pipeThreadDef)),this.leftThread.addReaction({name:void 0,dataConsumer:t=>{this.lastLeftData=t,this.baseThread.reducers.$update(e=>this.leftMapper(t,this.lastRightData,e))}}),this.rightThread.addReaction({name:void 0,dataConsumer:t=>{this.lastRightData=t,this.baseThread.reducers.$update(e=>this.rightMapper(t,this.lastLeftData,e))}})):this.baseThread.start(),this}stop(t){return this.baseThread.stop(void 0),this}get reducers(){return this.baseThread.reducers}get do(){return this.baseThread.do}get isRunning(){return this.baseThread.isRunning}get actions(){return this.baseThread.actions}get thread(){return this.baseThread.thread}}class PipeFilter{constructor(t,e,a,n){this.fromThread=t,this.filter=e,this.name=a,this.base=n}addReaction(t){return this.baseThread.addReaction(t)}chain(t){return this.baseThread.chain(t)}getData(){return this.baseThread.getData()}getEvents(){return this.baseThread.getEvents()}getName(){return this.baseThread.getName()}next(t){this.baseThread.next(t)}start(){return null==this.baseThread?(this.baseThread=Threads.create({name:this.name,initialData:this.base}),this.fromThread.addReaction({name:void 0,dataConsumer:t=>{this.filter(t,this.lastState)&&(this.lastState=t,this.reducers.$update(t))}})):this.baseThread.start(),this}stop(t){this.baseThread.stop(void 0)}get reducers(){return this.baseThread.reducers}get isRunning(){return this.baseThread.isRunning}}class Pipes{static fromMonitor(t,e,a,n){let s=new PipeMerge(`pipeMonitorRaw[${t.getName()}]`,e,t.mainThread,(t,e,a)=>n(t,a),t.asyncThread,(t,e,n)=>a(t,n));return s.start(),new PipeFilter(s,(t,e)=>!Objects.deepEquals(t,e),`pipeMonitor[${t.getName()}]`,e).start()}static tupleCombine(t,e,a,n){return new PipeMerge(`combineArray => [${t.getName()}, ${e.getName()}]`,a,t,(t,e,a)=>[t,a[1]],e,(t,e,a)=>[a[0],t],n).start()}}class ConanState{constructor(t){this.state=t}getName(){return this.state.getName()}connectMap(t,e){return React.createElement(StateMapConnect,{from:this,into:t,mapper:e})}connectLive(t,e){return React.createElement(StateLive,{from:this,renderer:t,fallbackValue:e})}connectData(t){return React.createElement(StateMapConnect,{from:this,into:t,mapper:t=>t})}connect(t){return React.createElement(StateConnect,{from:this,into:t})}addAsyncReaction(t){if(!(this.state instanceof ThreadFacade))return this.state.addAsyncReaction(t)}addDataReaction(t){return this.state.addReaction(t)}get do(){return this.state.do}start(){return this.state.start(),this}stop(t){return this.state.stop(t),this}get actions(){return this.state.actions}getData(){return this.state.getData()}asyncMerge(t,e,a){if(this.state instanceof ThreadFacade)throw new Error("this conan state is not ready for async");let n=Pipes.fromMonitor(this.state,t,e,a);return new ConanState(new ThreadFacade(n,this.actions))}}class MonitorFacade{constructor(t,e){this.monitor=t,this.actions=e}start(){return this.monitor.start(),this}addAsyncReaction(t){return this.monitor.addAsyncReaction(t)}addReaction(t){return this.monitor.addReaction(t)}get do(){return this.monitor.do}getEvents(){return this.monitor.getEvents()}getName(){return this.monitor.getName()}stop(t){this.monitor.stop(t)}getData(){return this.monitor.getData()}next(t){this.monitor.next(t)}get asyncThread(){return this.monitor.asyncThread}get mainThread(){return this.monitor.mainThread}}class MonitorImpl{constructor(t,e){this.mainThread=t,this.asyncThread=e}start(){return this.mainThread.start(),this}addReaction(t){return this.mainThread.addReaction(t)}addAsyncReaction(t){return this.asyncThread.addReaction(t)}get do(){return this.mainThread.do}getEvents(){return this.mainThread.getEvents()}getName(){return this.mainThread.getName()}stop(t){this.mainThread.stop(t)}getData(){return this.mainThread.getData()}next(t){this.mainThread.next(t)}}class Monitors{static create(t){let e=this.createAsyncThread(t),a=Threads.create(Object.assign(Object.assign({},t),{pipelineListener:t=>{t.runtimeEvent!==FlowRuntimeEventType.MONITOR||(t.timing===FlowRuntimeEventTiming.REQUEST_START?e.do.tick(t.payload):t.timing===FlowRuntimeEventTiming.REQUEST_END?e.do.unTick(t.payload,!1):t.timing===FlowRuntimeEventTiming.REQUEST_CANCEL&&e.do.unTick(t.payload,!0))}})),n=new MonitorImpl(a,e);return new MonitorFacade(n,a.actions)}static createAsyncThread(t){return Threads.create({name:`monitor[${t.name}]`,actions:t=>({tick(e){t.reducers.$update(t=>({status:exports.MonitorStatus.ASYNC_START,currentAction:e,inProgressActions:[...t.inProgressActions,e]}))},unTick(e,a){t.reducers.$update(t=>({status:a?exports.MonitorStatus.ASYNC_CANCELLED:exports.MonitorStatus.ASYNC_FULFILLED,currentAction:e,inProgressActions:t.inProgressActions.filter(t=>t!==e)})),0===t.getData().inProgressActions.length&&t.reducers.$update(t=>({inProgressActions:[],currentAction:void 0,status:exports.MonitorStatus.IDLE}))}}),initialData:{inProgressActions:[],status:exports.MonitorStatus.IDLE,currentAction:void 0}})}}class Conan{static light(t,e){return new ConanState(Monitors.create({name:t,initialData:e}))}static state(t){return new ConanState(Monitors.create(t))}}class Lists{static mergeCombine(t,e,a,n){let s=[],r=!1;return s=e.map(e=>{for(let s of t)if(a(s,e))return r=!0,n(s,e);return e}),r?s:e}}exports.AsapParser=AsapParser,exports.Asaps=Asaps,exports.Conan=Conan,exports.ConanState=ConanState,exports.ContextStateConnect=ContextStateConnect,exports.ContextStateLive=ContextStateLive,exports.ContextStateMapConnect=ContextStateMapConnect,exports.DiAnnotationsMetadataFactory=DiAnnotationsMetadataFactory,exports.DiContextFactory=DiContextFactory,exports.DynamicOrStatics=DynamicOrStatics,exports.Flows=Flows,exports.InjectByName=InjectByName,exports.InjectByType=InjectByType,exports.InjectDynamic=InjectDynamic,exports.Lists=Lists,exports.ReactStateContext=ReactStateContext,exports.StateConnect=StateConnect,exports.StateLive=StateLive,exports.StateMapConnect=StateMapConnect,exports.contextStateConnect=contextStateConnect,exports.contextStateLive=contextStateLive,exports.contextStateMapConnect=contextStateMapConnect,exports.diAnnotationsCrud=diAnnotationsCrud,exports.isAsap=isAsap,exports.stateConnect=stateConnect,exports.stateLive=stateLive,exports.stateMapConnect=stateMapConnect,exports.useConantState=useConantState,exports.useContextConantState=useContextConantState,exports.useFlow=useFlow,exports.useFlowStatus=useFlowStatus;