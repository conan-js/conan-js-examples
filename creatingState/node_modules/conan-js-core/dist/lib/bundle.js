'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

class DynamicOrStatics {
    static result(dynamicOrStatic, basedOn) {
        return ((typeof dynamicOrStatic === 'function') ? dynamicOrStatic(basedOn) : dynamicOrStatic);
    }
}

class Strings {
    static firstCharToLowerCase(from) {
        return from.substring(0, 1).toLowerCase() + from.substring(1, from.length);
    }
    static firstCharToUpperCase(from) {
        return from.substring(0, 1).toUpperCase() + from.substring(1, from.length);
    }
    static camelCaseWithPrefix(prefix, from) {
        return prefix + this.firstCharToUpperCase(from);
    }
    static repeat(s, repeats) {
        let result = '';
        for (let i = 0; i < repeats; i++) {
            result += s;
        }
        return result;
    }
    static padEnd(s, positions) {
        if (s == null)
            return s;
        let toAdd = positions - s.length;
        if (toAdd < 1) {
            let middle = '...';
            let toRemove = s.length + middle.length - positions;
            let leftInsertionPoint = 1;
            let rightInsertionPoint = leftInsertionPoint + toRemove;
            return s.substring(0, leftInsertionPoint) + middle + s.substring(rightInsertionPoint, s.length);
        }
        else {
            return s + " ".repeat(toAdd);
        }
    }
}

class DiUtils {
    static beanName(from) {
        return Strings.firstCharToLowerCase(from.name);
    }
}

var InjectableType;
(function (InjectableType) {
    InjectableType["DYNAMIC"] = "dynamic";
    InjectableType["NAME"] = "name";
    InjectableType["TYPE"] = "type";
})(InjectableType || (InjectableType = {}));

class MetadataCrudUtils {
    constructor(spaceName, defaultProvider) {
        this.spaceName = spaceName;
        this.defaultProvider = defaultProvider;
    }
    updateMetadata(constructor, updater) {
        let current = this.getOrCreateMetadata(constructor);
        if (current == null)
            throw Error(`can't get or create metaData`);
        updater(current);
        return current;
    }
    assignMetaDataToConstructor(constructor, metaData) {
        let annotationsMetadataBySpaceAndPrototypeHolder = this.getPrototype(constructor);
        if (annotationsMetadataBySpaceAndPrototypeHolder.$a == null) {
            annotationsMetadataBySpaceAndPrototypeHolder.$a = {};
        }
        if (annotationsMetadataBySpaceAndPrototypeHolder.$a[this.spaceName] == null) {
            annotationsMetadataBySpaceAndPrototypeHolder.$a[this.spaceName] = {};
        }
        let name = MetadataCrudUtils.extractName(constructor);
        annotationsMetadataBySpaceAndPrototypeHolder.$a[this.spaceName][name] = metaData;
    }
    getAnnotationsMetaData(constructorOrInstance) {
        let annotationsMetadataBySpaceAndPrototypeHolder = constructorOrInstance;
        if (!annotationsMetadataBySpaceAndPrototypeHolder.$a) {
            annotationsMetadataBySpaceAndPrototypeHolder = this.getPrototype(constructorOrInstance);
        }
        let annotationsMetadataBySpaceAndPrototype = annotationsMetadataBySpaceAndPrototypeHolder.$a;
        if (annotationsMetadataBySpaceAndPrototype == null) {
            return null;
        }
        let annotationsMetadataByPrototype = annotationsMetadataBySpaceAndPrototype[this.spaceName];
        if (annotationsMetadataByPrototype == null) {
            return null;
        }
        let name = MetadataCrudUtils.extractName(constructorOrInstance);
        return annotationsMetadataByPrototype[name];
    }
    getOrCreateMetadata(constructor) {
        if (this.getAnnotationsMetaData(constructor) == null) {
            let metadata = this.defaultProvider();
            this.assignMetaDataToConstructor(constructor, metadata);
        }
        return this.getAnnotationsMetaData(constructor);
    }
    getPrototype(constructor) {
        if (typeof constructor === 'object') {
            return constructor;
        }
        if (typeof constructor.prototype === 'object') {
            return constructor.prototype;
        }
        return this.getPrototype(Object.getPrototypeOf(constructor));
    }
    static extractName(constructor) {
        let rawName = constructor.name;
        if (rawName == null) {
            rawName = constructor.constructor.name;
        }
        return rawName.substring(0, 1).toLowerCase() + rawName.substring(1, rawName.length);
    }
}

let diAnnotationsCrud = new MetadataCrudUtils('$di', () => ({
    diAnnotations: []
}));
function InjectByType(constructor, propsProvider) {
    return (classConstructor, keyOfParam_alwaysIgnore, index) => {
        diAnnotationsCrud.updateMetadata(classConstructor, (current) => current.diAnnotations.push({
            onConstructorParamIndex: index,
            injectable: constructor,
            type: InjectableType.TYPE,
            cascadeProperties: propsProvider
        }));
    };
}
function InjectDynamic(constructorProvider, propsProvider) {
    return (classConstructor, keyOfParam_alwaysIgnore, index) => {
        diAnnotationsCrud.updateMetadata(classConstructor, (current) => current.diAnnotations.push({
            onConstructorParamIndex: index,
            injectable: constructorProvider,
            type: InjectableType.DYNAMIC,
            cascadeProperties: propsProvider
        }));
    };
}
function InjectByName(name, propsProvider) {
    console.log('Inject by name', name);
    return (classConstructor, keyOfParam_alwaysIgnore, index) => {
        diAnnotationsCrud.updateMetadata(classConstructor, (current) => current.diAnnotations.push({
            onConstructorParamIndex: index,
            injectable: name,
            type: InjectableType.NAME,
            cascadeProperties: propsProvider
        }));
    };
}

const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;
class Functions {
    static extractArgNames(func) {
        if (func.length === 0)
            return [];
        let fnStr = func.toString().replace(STRIP_COMMENTS, '');
        let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
        if (result === null)
            result = [];
        return result;
    }
}

class DiAnnotationsMetadataFactory {
    create(from) {
        let dependencyName = DiUtils.beanName(from);
        let argumentNames = Functions.extractArgNames(from);
        let diParams = {};
        let annotationsMetaData = diAnnotationsCrud.getAnnotationsMetaData(from);
        if (annotationsMetaData) {
            annotationsMetaData.diAnnotations.forEach(it => {
                let argumentName = argumentNames[it.onConstructorParamIndex];
                diParams[argumentName] = {
                    name: argumentName,
                    type: it.type,
                    payload: it.injectable,
                    propsProvider: it.cascadeProperties
                };
            });
        }
        return {
            dependencyName: dependencyName,
            argumentNames: argumentNames,
            diParams: diParams,
            constructor: from
        };
    }
}

class DiRuntime {
    constructor(diInvocationResolver, diInvocationBuilderFactory) {
        this.diInvocationResolver = diInvocationResolver;
        this.diInvocationBuilderFactory = diInvocationBuilderFactory;
    }
    invoke(from, transitiveBeans, context) {
        if (typeof from === "object")
            return from;
        let invocation = this.diInvocationBuilderFactory.root(from)
            .if(transitiveBeans != null, it => it.withTransitiveBeans(transitiveBeans))
            .build();
        let result = this.diInvocationResolver.resolve(invocation, context, this).result;
        if (result == null)
            throw Error(`Can't invoke`);
        return result;
    }
    invokeWithProps(from, props, transitiveBeans, context) {
        let invocation = this.diInvocationBuilderFactory.root(from)
            .withProperties(props)
            .if(transitiveBeans != null, it => it.withTransitiveBeans(transitiveBeans))
            .build();
        let result = this.diInvocationResolver.resolve(invocation, context, this).result;
        if (result == null)
            throw Error(`Can't invoke`);
        return result;
    }
}
DiRuntime.PROPS_PROPERTY_NAME = '$props';

class DiInvocationResolver {
    constructor(diInvocationFactory, diCache, diEnricher) {
        this.diInvocationFactory = diInvocationFactory;
        this.diCache = diCache;
        this.diEnricher = diEnricher;
    }
    resolve(invocation, context, diRuntime) {
        if (this.causesCircularDependency(invocation)) {
            return {
                circularDependencyEndOf: invocation.diMetadata.dependencyName,
                result: null,
                pendingDependencies: {}
            };
        }
        // @ts-ignore
        let freshInvocationResult = null;
        let bean = this.diCache.resolve(invocation.diMetadata.dependencyName, () => {
            freshInvocationResult = this.doCreate(invocation, context, diRuntime);
            if (this.diEnricher) {
                freshInvocationResult.result = this.diEnricher(invocation.diMetadata, freshInvocationResult.result);
            }
            if (Object.keys(freshInvocationResult.pendingDependencies).indexOf(invocation.diMetadata.dependencyName) > -1) {
                freshInvocationResult.pendingDependencies[invocation.diMetadata.dependencyName].forEach(childDependency => {
                    this.diCache.resolve(childDependency, null)[invocation.diMetadata.dependencyName] = freshInvocationResult.result;
                });
            }
            return freshInvocationResult.result;
        });
        return freshInvocationResult == null ? {
            result: bean,
            pendingDependencies: {}
        } : freshInvocationResult;
    }
    causesCircularDependency(invocation) {
        return invocation.inProcessDiInvocations.indexOf(invocation.diMetadata.dependencyName) > -1;
    }
    doCreate(invocation, context, diRuntime) {
        const useConstructorOrFn = (invocation, params) => {
            let constructor = invocation.diMetadata.constructor;
            if (!!constructor.prototype && !!constructor.prototype.constructor.name) {
                return params ? new constructor(...params) : new constructor();
            }
            else {
                return params ? constructor(...params) : constructor();
            }
        };
        if (invocation.diMetadata.argumentNames.length === 0) {
            let result = useConstructorOrFn(invocation, undefined);
            return {
                result: result,
                pendingDependencies: {}
            };
        }
        let childrenInvocationResults = this.invokeChildren(invocation, context, diRuntime);
        let params = [];
        let startsCircularDependencies = {};
        childrenInvocationResults.forEach(child => {
            params.push(child.result);
            if (child.circularDependencyEndOf != null) {
                DiInvocationResolver.addValueToKeyValuePairs(startsCircularDependencies, child.circularDependencyEndOf, invocation.diMetadata.dependencyName);
            }
            if (child.pendingDependencies) {
                Object.keys(child.pendingDependencies).forEach(key => {
                    DiInvocationResolver.addValuesToKeyValuePairs(startsCircularDependencies, key, child.pendingDependencies[key]);
                });
            }
        });
        return {
            result: useConstructorOrFn(invocation, params),
            pendingDependencies: startsCircularDependencies
        };
    }
    static addValueToKeyValuePairs(keyValuePairs, key, value) {
        if (!keyValuePairs[key]) {
            keyValuePairs[key] = [];
        }
        if (keyValuePairs[key].indexOf(value) > -1)
            return;
        keyValuePairs[key].push(value);
    }
    static addValuesToKeyValuePairs(keyValuePairs, key, values) {
        if (!keyValuePairs[key]) {
            keyValuePairs[key] = values;
            return;
        }
        values.forEach(value => DiInvocationResolver.addValueToKeyValuePairs(keyValuePairs, key, value));
    }
    invokeChildren(invocation, context, diRuntime) {
        let params = [];
        invocation
            .diMetadata
            .argumentNames
            .forEach(argumentName => {
            let resolvedParam = this.resolveParamDef(invocation, argumentName);
            params.push(this.invokeChild(invocation, resolvedParam, context, diRuntime));
        });
        return params;
    }
    resolveParamDef(invocation, argumentName) {
        let fromAnnotation = invocation.diMetadata.diParams[argumentName];
        if (fromAnnotation == null) {
            return {
                name: argumentName,
                propsProvider: null,
                payload: argumentName,
                type: InjectableType.NAME
            };
        }
        return fromAnnotation;
    }
    invokeChild(invocation, resolvedParam, context, diRuntime) {
        if (resolvedParam.name === DiRuntime.PROPS_PROPERTY_NAME) {
            return this.resolveChildProps(invocation);
        }
        if (resolvedParam.type === InjectableType.TYPE) {
            return this.resolveChildByType(invocation, resolvedParam, context, diRuntime);
        }
        if (resolvedParam.type === InjectableType.DYNAMIC) {
            return this.resolveDynamicChild(invocation, resolvedParam, context, diRuntime);
        }
        return this.resolveChildByName(invocation, resolvedParam, context, diRuntime);
    }
    resolveChildProps(invocation) {
        if (invocation.properties == null) {
            throw Error(`can't resolve properties for $props - There are no properties passed to the beanRuntime`);
        }
        return {
            result: invocation.properties,
            pendingDependencies: {}
        };
    }
    resolveChildByType(invocation, childParamMetadata, context, diRuntime) {
        return this.resolve(this.diInvocationFactory.childrenOf(invocation, childParamMetadata.payload, childParamMetadata.propsProvider), context, diRuntime);
    }
    resolveDynamicChild(invocation, resolvedParam, context, diRuntime) {
        return this.resolveChildByType(invocation, {
            payload: resolvedParam.payload(),
            type: InjectableType.TYPE,
            propsProvider: resolvedParam.propsProvider,
            name: resolvedParam.name
        }, context, diRuntime);
    }
    resolveChildByName(invocation, resolvedParam, context, diRuntime) {
        let nameToResolve = resolvedParam.payload;
        if (invocation.transitiveBeans == null || invocation.transitiveBeans[nameToResolve] == null) {
            if (context[nameToResolve] != null) {
                let byName = diRuntime.invoke(context[nameToResolve], invocation.transitiveBeans, context);
                return {
                    result: byName,
                    pendingDependencies: {}
                };
            }
            else {
                throw Error(`can't resolve param '${nameToResolve}' - There are no transitive beans passed into the runtime`);
            }
        }
        return {
            result: invocation.transitiveBeans[nameToResolve],
            pendingDependencies: {}
        };
    }
}

class DiInvocationBuilderFactory {
    constructor(diAnnotationsMetadataFactory) {
        this.diAnnotationsMetadataFactory = diAnnotationsMetadataFactory;
    }
    childrenOf(parent, from, propsProvider) {
        let newBranch = parent.inProcessDiInvocations.slice(0);
        newBranch.push(parent.diMetadata.dependencyName);
        return new DiInvocationBuilder(this.diAnnotationsMetadataFactory, from)
            .withInProcessDiInvocations(newBranch)
            .withTransitiveBeans(parent.transitiveBeans)
            // @ts-ignore
            .if(propsProvider != null, (it) => it.withProperties(propsProvider()));
    }
    root(from) {
        return new DiInvocationBuilder(this.diAnnotationsMetadataFactory, from);
    }
}
class DiInvocationFactory {
    constructor(diInvocationBuilderFactory) {
        this.diInvocationBuilderFactory = diInvocationBuilderFactory;
    }
    childrenOf(parent, from, propsProvider) {
        return this.diInvocationBuilderFactory.childrenOf(parent, from, propsProvider).build();
    }
}
class DiInvocationBuilder {
    constructor(diAnnotationsMetadataFactory, _constructor) {
        this.diAnnotationsMetadataFactory = diAnnotationsMetadataFactory;
        this._constructor = _constructor;
        this.inProcessDiInvocations = [];
        this.transitiveBeans = {};
        this.properties = null;
    }
    if(condition, cb) {
        if (condition) {
            cb(this);
        }
        return this;
    }
    withInProcessDiInvocations(inProcessDiInvocations) {
        this.inProcessDiInvocations = inProcessDiInvocations;
        return this;
    }
    withTransitiveBeans(transitiveBeans) {
        this.transitiveBeans = transitiveBeans;
        return this;
    }
    withProperties(properties) {
        this.properties = properties;
        return this;
    }
    build() {
        return {
            diMetadata: this.diAnnotationsMetadataFactory.create(this._constructor),
            inProcessDiInvocations: this.inProcessDiInvocations,
            transitiveBeans: this.transitiveBeans,
            properties: this.properties
        };
    }
}

class KeyValueCache {
    constructor() {
        this.cache = {};
    }
    resolve(key, producer) {
        if (this.cache[key]) {
            return this.cache[key];
        }
        if (producer == null)
            throw Error(`Can't resolve cache`);
        let bean = producer();
        this.cache[key] = bean;
        return bean;
    }
}

class DiRuntimeFactory {
    static create(diReducer) {
        return new DiRuntime(DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER(new KeyValueCache(), diReducer ? diReducer : null), DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY);
    }
}
DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY = new DiInvocationBuilderFactory(new DiAnnotationsMetadataFactory());
DiRuntimeFactory.cacheTBR = () => new KeyValueCache();
DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER = (cache, diReducer) => new DiInvocationResolver(new DiInvocationFactory(DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY), DiRuntimeFactory.cacheTBR(), diReducer);

class DiContextFactory {
    static createContext(contextDef, aux) {
        let diRuntime = DiRuntimeFactory.create();
        let from = Object.assign(Object.assign({}, contextDef), aux);
        let keys;
        if (aux) {
            keys = [...Object.keys(contextDef), ...Object.keys(aux)];
        }
        else {
            keys = Object.keys(contextDef);
        }
        let result = {};
        let context = Object.assign(Object.assign({}, contextDef), aux);
        (keys).forEach(key => {
            let constr = from[key];
            result[key] = diRuntime.invoke(constr, result, context);
        });
        return result;
    }
}

(function (MonitorStatus) {
    MonitorStatus["IDLE"] = "IDLE";
    MonitorStatus["ASYNC_START"] = "ASYNC_START";
    MonitorStatus["ASYNC_FULFILLED"] = "ASYNC_FULFILLED";
    MonitorStatus["ASYNC_CANCELLED"] = "ASYNC_CANCELLED";
})(exports.MonitorStatus || (exports.MonitorStatus = {}));

const ReactStateContext = React.createContext(null);
class StateMapConnect extends React.Component {
    constructor(props) {
        super(props);
        this._isMounted = false;
        this.lastMonitorInfo = undefined;
        this.lastState = undefined;
        let needsDefault = true;
        let name = this.props.into.prototype ? this.props.into.prototype : this.props.into.name;
        this._mainDataReactionLock = this.props.from.addDataReaction({
            name: `connect | ${name}`,
            dataConsumer: (data) => {
                this.lastState = data;
                let lastProps = this.props.mapper(data, Object.assign({}, this.props.from.actions), this.lastMonitorInfo);
                if (this._isMounted) {
                    this.setState(lastProps);
                }
                else {
                    needsDefault = false;
                    this.state = lastProps;
                }
            },
        });
        this._asyncDataReactionLock = this.props.from.addAsyncReaction({
            name: `connect monitor| ${name}`,
            dataConsumer: (monitorInfo) => {
                this.lastMonitorInfo = monitorInfo;
                let lastProps = this.props.mapper(this.lastState, Object.assign({}, this.props.from.actions), monitorInfo);
                if (this._isMounted) {
                    this.setState(lastProps);
                }
                else {
                    needsDefault = false;
                    this.state = lastProps;
                }
            }
        });
        if (needsDefault && this.props.fallbackValue) {
            this.state = this.props.fallbackValue(this.props.from.actions);
        }
    }
    componentDidMount() {
        this._isMounted = true;
    }
    componentWillUnmount() {
        this._isMounted = false;
        this._mainDataReactionLock.release();
        if (this._asyncDataReactionLock) {
            this._asyncDataReactionLock.release();
        }
    }
    render() {
        let Comp = this.props.into;
        return (React.createElement(ReactStateContext.Provider, { value: this.props.from },
            React.createElement(Comp, Object.assign({}, this.state))));
    }
}
const StateConnect = (props) => {
    return (React.createElement(StateMapConnect, { mapper: (data, actions, monitorInfo) => ({ data, actions, monitorInfo }), into: props.into, from: props.from, fallbackValue: (actions) => ({
            data: props.fallbackValue,
            actions,
            monitorInfo: {
                status: exports.MonitorStatus.IDLE
            }
        }) }));
};
const stateConnect = (from, into, fallbackValue) => {
    return React.createElement(StateConnect, { from: from, into: into, fallbackValue: fallbackValue });
};
const stateMapConnect = (from, into, mapper, fallbackValue) => {
    return React.createElement(StateMapConnect, { from: from, into: into, fallbackValue: fallbackValue, mapper: mapper });
};

function useFlow(flow, setState, mapper) {
    React.useEffect(() => {
        flow.reactOnStatusChanged(status => {
            setState((previousUserState) => {
                return mapper ? mapper(status, previousUserState) : status.name;
            });
        });
    }, []);
}
function useFlowStatus(flow, status, setState, mapper) {
    React.useEffect(() => {
        flow.alwaysOn(status, context => {
            setState(previousState => {
                return mapper ? mapper(context.getData(), previousState) : context.getData();
            });
        });
    }, []);
}
function useConantState(state, fallbackValue) {
    let lastData = state.getData();
    const [compState, compStateSetter] = React.useState(lastData == null ? fallbackValue : lastData);
    React.useEffect(() => {
        const lock = state.addDataReaction({
            dataConsumer: compStateSetter,
            name: `useConanState[${state.getName()}]`
        });
        return () => lock.release();
    }, []);
    return [compState, state.actions, ({ children }) => {
            return React.createElement(ReactStateContext.Provider, { value: state }, children);
        }];
}
function useContextConantState() {
    const state$ = React.useContext(ReactStateContext);
    let result = useConantState(state$);
    return [result[0], result[1]];
}

class ContextStateMapConnect extends React.Component {
    render() {
        return React.createElement(ReactStateContext.Consumer, null, (reactThread) => {
            if (reactThread == null) {
                throw new Error(`trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?`);
            }
            return React.createElement(StateMapConnect, { from: reactThread, into: this.props.into, mapper: this.props.mapper, fallbackValue: this.props.fallbackValue });
        });
    }
}
class ContextStateConnect extends React.Component {
    render() {
        return React.createElement(ReactStateContext.Consumer, null, (reactThread) => {
            if (reactThread == null) {
                throw new Error(`trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?`);
            }
            return React.createElement(StateConnect, { from: reactThread, into: this.props.into, fallbackValue: this.props.fallbackValue });
        });
    }
}
const contextStateConnect = (into, fallbackValue) => {
    return React.createElement(ContextStateConnect, { into: into, fallbackValue: fallbackValue });
};
const contextStateMapConnect = (into, mapper, fallbackValue) => {
    return React.createElement(ContextStateMapConnect, { into: into, fallbackValue: fallbackValue, mapper: mapper });
};

const ContextStateLive = (props) => {
    const LiveRenderer = (propsLive) => {
        return props.renderer(propsLive.data, propsLive.actions);
    };
    return (React.createElement(ContextStateConnect, { into: LiveRenderer, fallbackValue: props.fallbackValue }));
};
const StateLive = (props) => {
    const LiveRenderer = (propsLive) => {
        let result = props.renderer(propsLive.data, propsLive.actions);
        return Array.isArray(result) ? (React.createElement(React.Fragment, null, result)) : result;
    };
    return (React.createElement(StateConnect, { from: props.from, into: LiveRenderer, fallbackValue: props.fallbackValue }));
};
const contextStateLive = (renderer, fallbackValue) => {
    const LiveRenderer = (props) => {
        let result = renderer(props.data, props.actions);
        return Array.isArray(result) ? (React.createElement(React.Fragment, null, result)) : result;
    };
    return React.createElement(ContextStateConnect, { into: LiveRenderer, fallbackValue: fallbackValue });
};
const stateLive = (from, renderer, fallbackValue) => {
    const LiveRenderer = (props) => {
        let result = renderer(props.data, props.actions);
        return Array.isArray(result) ? (React.createElement(React.Fragment, null, result)) : result;
    };
    return React.createElement(StateConnect, { from: from, into: LiveRenderer, fallbackValue: fallbackValue });
};

var ReactionType;
(function (ReactionType) {
    ReactionType["ONCE"] = "ONCE";
    ReactionType["ALWAYS"] = "ALWAYS";
})(ReactionType || (ReactionType = {}));

class ThreadImpl {
    constructor(flow) {
        this.flow = flow;
    }
    start(initialData) {
        this.flow.start(initialData ? { name: 'nextData', data: initialData } : undefined);
        return this;
    }
    next(cb) {
        this.flow.onceOn("nextData", cb);
    }
    stop(eventsConsumer) {
        this.flow.stop(eventsConsumer);
    }
    chain(mutatorsCb) {
        return this.flow.chainInto('nextData', 'nextData', mutatorsCb).map(context => context.getData());
    }
    monitor(toMonitor, thenCallback, name, payload) {
        let mutatorsCbAsap = toMonitor.map(data => reducers => thenCallback(data, reducers));
        let defer = {
            payload: payload,
            name: name == null ? 'anonymous' : name,
            action: mutatorsCbAsap
        };
        return this.flow.deferInto('nextData', 'nextData', defer).map(context => context.getData());
    }
    get isRunning() {
        return this.flow.isRunning;
    }
    get reducers() {
        return this.flow.on('nextData').steps;
    }
    addReaction(def) {
        let reactionDef = {
            name: def.name,
            reactionType: ReactionType.ALWAYS,
            action: oNextData => def.dataConsumer(oNextData.getData()),
        };
        this.flow.addReaction('nextData', reactionDef);
        return {
            release: () => {
                this.flow.removeReaction('nextData', reactionDef);
            }
        };
    }
    getData() {
        return this.flow.getStatusData()['nextData'];
    }
    getEvents() {
        return this.flow.getEvents();
    }
    getName() {
        return this.flow.getName();
    }
}

class Objects {
    static mapKeys(from, valueMapper, keyMapper) {
        let result = {};
        Object.keys(from).forEach(key => {
            let newKey = keyMapper ? keyMapper(key) : key;
            result[newKey] = valueMapper(from[key]);
        });
        return result;
    }
    static foreachEntry(from, cb) {
        Object.keys(from).forEach(key => {
            cb(from[key], key);
        });
    }
    static keyfy(from, keyProvider) {
        return from.reduce((acc, it) => {
            return Object.assign(Object.assign({}, acc), { [keyProvider(it)]: it });
        }, {});
    }
    static navigate(from, iterator) {
        let result = [];
        let next = from;
        while (next) {
            next = iterator(next);
            if (next !== null) {
                result.push(next);
            }
        }
        return result;
    }
    static deepEqualsArrays(left, right) {
        if (left.length !== right.length)
            return false;
        for (let leftItem of left) {
            if (right.indexOf(leftItem) === -1)
                return false;
        }
        return true;
    }
    static deepEqualsObjects(left, right) {
        for (let key of Object.keys(left)) {
            if (!Objects.deepEquals(left[key], right[key])) {
                return false;
            }
        }
        return true;
    }
    static deepEquals(left, right) {
        if ((left == null) && (right == null))
            return true;
        if ((left == null) && (right != null))
            return false;
        if ((left != null) && (right == null))
            return false;
        if ((typeof left === "string") && (typeof right === "string"))
            return left === right;
        if ((typeof left === "number") && (typeof right === "number"))
            return left === right;
        if ((typeof left === "function") && (typeof right === "function"))
            return left === right;
        if ((typeof left === "boolean") && (typeof right === "boolean"))
            return left === right;
        if ((typeof left === "undefined") && (typeof right === "undefined"))
            return left === right;
        if (Array.isArray(left) && (Array.isArray(right)))
            return Objects.deepEqualsArrays(left, right);
        if (Array.isArray(left) && (!Array.isArray(right)))
            return false;
        if (!Array.isArray(left) && (Array.isArray(right)))
            return false;
        if ((typeof left === "object") && (typeof right === "object"))
            return Objects.deepEqualsObjects(left, right);
        return left === right;
    }
}

class StatusLikeParser {
    static parse(toParse) {
        if (typeof toParse === "string")
            return {
                name: toParse
            };
        return toParse;
    }
}

class FlowRequest {
    constructor(flowThread, id, status, isStep) {
        this.flowThread = flowThread;
        this.id = id;
        this.status = status;
        this.isStep = isStep;
        this.queuedReactions = [];
        this.queuedTransitions = [];
        this.queuedSteps = [];
        this.queuedStatuses = [];
        this.queuedStates = [];
        this.started = false;
        this.processingStatus = {
            id: this.id,
            status: this.status
        };
    }
    static statusRequest(smFlow, id, state, isStep) {
        return new FlowRequest(smFlow, id, state, isStep);
    }
    static transitionRequest(smFlow, id, transition, isStep) {
        return new FlowRequest(smFlow, id, StatusLikeParser.parse(transition.into), isStep);
    }
    start() {
        if (this.started) {
            throw new Error('unexpected');
        }
        this.started = true;
        this.flowThread.processStateAndReactions(this.processingStatus, this.isStep);
        this.flowThread.flagAsSettled(this.processingStatus, this.isStep);
        this.flowThread.onStateRequestCompleted(this, this.queuedReactions, this.queuedStatuses, this.queuedStates, this.queuedTransitions, this.queuedSteps);
    }
    queueStatus(state) {
        this.queuedStatuses.push(state);
    }
    queueTransition(transition) {
        this.queuedTransitions.push(transition);
        return this;
    }
    queueStep(transition) {
        this.queuedSteps.push(transition);
        return this;
    }
    queueState(status) {
        this.queuedStates.push(status);
    }
    queueReaction(eventName, reaction) {
        this.queuedReactions.push([eventName, reaction]);
    }
}

var FlowRuntimeEventSource;
(function (FlowRuntimeEventSource) {
    FlowRuntimeEventSource["FLOW_CONTROLLER"] = "FLOW_CONTROLLER";
    FlowRuntimeEventSource["FLOW_THREAD"] = "FLOW_THREAD";
    FlowRuntimeEventSource["CONTEXT"] = "CONTEXT";
    FlowRuntimeEventSource["FLOW_FACTORY"] = "FLOW_FACTORY";
})(FlowRuntimeEventSource || (FlowRuntimeEventSource = {}));
var FlowRuntimeEventTiming;
(function (FlowRuntimeEventTiming) {
    FlowRuntimeEventTiming["REQUEST_START"] = "REQUEST_START";
    FlowRuntimeEventTiming["REQUEST_END"] = "REQUEST_END";
    FlowRuntimeEventTiming["REQUEST_CANCEL"] = "REQUEST_CANCEL";
    FlowRuntimeEventTiming["USER_TRACE"] = "USER_TRACE";
    FlowRuntimeEventTiming["TRACE"] = "TRACE";
    FlowRuntimeEventTiming["INFO"] = "INFO";
})(FlowRuntimeEventTiming || (FlowRuntimeEventTiming = {}));
var FlowRuntimeEventType;
(function (FlowRuntimeEventType) {
    FlowRuntimeEventType["MONITOR"] = "MONITOR";
    FlowRuntimeEventType["PROCESS_REACTIONS"] = "PROCESS_REACTIONS";
    FlowRuntimeEventType["START"] = "START";
    FlowRuntimeEventType["REQUEST_STATUS"] = "REQUEST_STATUS";
    FlowRuntimeEventType["FLAG_AS_SETTLED"] = "FLAG_AS_SETTLED";
    FlowRuntimeEventType["USER_MSG"] = "USER_MSG";
    FlowRuntimeEventType["REQUEST_TRANSITION"] = "REQUEST_TRANSITION";
    FlowRuntimeEventType["CREATE_FLOW"] = "CREATE_FLOW";
})(FlowRuntimeEventType || (FlowRuntimeEventType = {}));

class FlowThread {
    constructor(flowController, flowOrchestrator, flowEvents) {
        this.flowController = flowController;
        this.flowOrchestrator = flowOrchestrator;
        this.flowEvents = flowEvents;
        this.ids = {};
    }
    requestStatus(statusLike, isStep) {
        let status = StatusLikeParser.parse(statusLike);
        let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowRuntimeEventSource.FLOW_THREAD, FlowRuntimeEventType.REQUEST_STATUS, statusLike).highlight(FlowRuntimeEventTiming.REQUEST_START, `${status.name}`);
        this.assertValidStatus(status.name);
        if (this.currentRequest != null) {
            if (!isStep) {
                tracker.trace(FlowRuntimeEventTiming.TRACE, `queueing status [${status.name}]`);
                this.currentRequest.queueStatus(status);
            }
            else {
                tracker.trace(FlowRuntimeEventTiming.TRACE, `queueing state [${status.name}]`);
                this.currentRequest.queueState(status);
            }
            return;
        }
        let id = this.getNextId(status);
        this.currentRequest = FlowRequest.statusRequest(this, id + '', status, isStep);
        this.currentRequest.start();
        tracker.trace(FlowRuntimeEventTiming.REQUEST_END);
    }
    requestTransition(transition, isStep) {
        let intoStatusName = StatusLikeParser.parse(transition.into).name;
        let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowRuntimeEventSource.FLOW_THREAD, FlowRuntimeEventType.REQUEST_TRANSITION, transition).highlight(FlowRuntimeEventTiming.REQUEST_START, `${transition.transitionName}`);
        tracker.highlight(FlowRuntimeEventTiming.INFO, isStep ? 'step' : 'Transition', transition.transitionName);
        this.assertValidStatus(intoStatusName);
        if (this.currentRequest != null) {
            if (!isStep) {
                tracker.trace(FlowRuntimeEventTiming.TRACE, `queueing transition [${transition.transitionName}]`);
                this.currentRequest.queueTransition(transition);
            }
            else {
                tracker.trace(FlowRuntimeEventTiming.TRACE, `queueing step [${transition.transitionName}]`);
                this.currentRequest.queueStep(transition);
            }
            return;
        }
        let id = this.getNextId(StatusLikeParser.parse(transition.into));
        this.currentRequest = FlowRequest.transitionRequest(this, id + '', transition, isStep);
        this.onTransitionRequested(transition, isStep);
        this.currentRequest.start();
        tracker.trace(FlowRuntimeEventTiming.REQUEST_END);
    }
    requestStep(statusName, reducerName, payload, data) {
        this.assertValidStatus(statusName);
        let currentStatusName = this.getCurrentStatusName();
        if (currentStatusName !== statusName) {
            throw new Error(`car't request step on [${statusName}] as the current status is[${currentStatusName}]`);
        }
        this.requestTransition({
            transitionName: reducerName,
            payload,
            into: {
                name: statusName,
                data
            }
        }, true);
    }
    requestState(statusName, data) {
        this.assertValidStatus(statusName);
        let currentStatusName = this.getCurrentStatusName();
        if (currentStatusName !== statusName) {
            throw new Error(`car't request state on [${statusName}] as the current status is[${currentStatusName}]`);
        }
        this.requestStatus({
            name: statusName,
            data: data
        }, true);
    }
    tryToQueue(eventName, reaction) {
        if (this.currentRequest == null)
            return false;
        this.currentRequest.queueReaction(eventName, reaction);
        return true;
    }
    onTransitionRequested(transition, isStep) {
        this.flowEvents.addTransition(transition, isStep);
    }
    getNextId(status, preview = false) {
        if (this.ids[status.name] == null) {
            this.ids[status.name] = 0;
        }
        let nextId = this.ids[status.name] + 1;
        if (preview)
            return nextId;
        this.ids[status.name] = nextId;
        return this.ids[status.name];
    }
    processStateAndReactions(statusRequest, isStep) {
        this.flowEvents.addProcessingStatus(statusRequest, isStep);
        this.flowController.processReactions(statusRequest.status.name);
    }
    flagAsSettled(statusRequest, isStep) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowRuntimeEventSource.FLOW_THREAD, FlowRuntimeEventType.FLAG_AS_SETTLED, statusRequest).highlight(FlowRuntimeEventTiming.REQUEST_START, `${statusRequest.status.name}`);
        this.flowEvents.settleProcessingStatus(statusRequest, isStep);
        if (!isStep) {
            tracker.highlight(FlowRuntimeEventTiming.INFO, 'STATUS', statusRequest.status);
        }
        else {
            tracker.highlight(FlowRuntimeEventTiming.INFO, 'STATE', statusRequest.status.data);
        }
        tracker.trace(FlowRuntimeEventTiming.REQUEST_END);
    }
    onStateRequestCompleted(stateMachineRequest, queuedReactions, queuedStatuses, queuedStates, queuedTransitions, queuedSteps) {
        if (this.currentRequest == null) {
            throw new Error(`can't complete the request for [${this.flowController.getName()} - ${stateMachineRequest.status.name}] as is not flagged as currently in process`);
        }
        if (this.currentRequest != stateMachineRequest) {
            throw new Error(`can't complete the request for [${this.flowController.getName()} - ${stateMachineRequest.status.name}] as it does not match [${this.currentRequest.status.name}]`);
        }
        if (queuedTransitions.length > 0 && queuedStatuses.length > 0) {
            throw new Error(`can't have transitions and states forked at the same time!`);
        }
        this.currentRequest = undefined;
        if (queuedTransitions.length > 1 || queuedStatuses.length > 1) {
            throw new Error('TBI');
        }
        queuedTransitions.forEach(it => this.flowController.requestTransition(it));
        queuedStatuses.forEach(it => this.flowController.requestStatus(it));
        queuedStates.forEach(it => this.flowController.requestState(it.name, it.data));
        queuedSteps.forEach(it => {
            let into = StatusLikeParser.parse(it.into);
            this.flowController.requestStep(into.name, it.transitionName, it.payload, into.data);
        });
        queuedReactions.forEach(it => this.flowController.addReaction(it[0], it[1]));
    }
    createContext(statusLike, doChain) {
        let status = StatusLikeParser.parse(statusLike);
        return {
            // step: this.flowController.on(status.name).steps,
            // transitions: this.flowController.on(status.name).transitions,
            getData: this.flowController.getState.bind(this.flowController),
            getStatusData: this.flowController.getStatusData.bind(this.flowController),
            do: Object.assign(Object.assign({}, this.flowController.on(status.name).transitions), this.flowController.on(status.name).steps),
            chain(cb) {
                doChain(cb);
            },
            interruptFlow: () => {
                this.flowController.stop();
            },
            trace: (msg) => {
                let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowRuntimeEventSource.CONTEXT, FlowRuntimeEventType.USER_MSG, msg).highlight(FlowRuntimeEventTiming.REQUEST_START, `${msg}`);
                let flowRuntimeTracker = tracker.highlight(FlowRuntimeEventTiming.USER_TRACE, undefined, msg);
                tracker.trace(FlowRuntimeEventTiming.REQUEST_END);
                return flowRuntimeTracker;
            }
        };
    }
    getCurrentStatusName() {
        let currentStatus = this.flowEvents.currentStatus;
        return currentStatus == null ? undefined : currentStatus.name;
    }
    getCurrentState() {
        let currentStatus = this.flowEvents.currentStatus;
        return currentStatus == null ? undefined : currentStatus.data;
    }
    assertValidStatus(statusName) {
        if (this.flowController.on(statusName) == null) {
            throw new Error(`error requesting a transition into [${statusName}] unknown status, valid statuses are: [${Object.keys(this.flowController.getStatusDefs()).join(', ')}]`);
        }
    }
}

var StatusEventType;
(function (StatusEventType) {
    StatusEventType["TRANSITION"] = "TRANSITION";
    StatusEventType["STEP"] = "STEP";
    StatusEventType["STATUS"] = "STATUS";
    StatusEventType["PROCESSING_STATUS"] = "PROCESSING_STATUS";
    StatusEventType["STATE"] = "STATE";
    StatusEventType["PROCESSING_STATE"] = "PROCESSING_STATE";
})(StatusEventType || (StatusEventType = {}));

class FlowEventsTracker {
    constructor() {
        this.eventsByStatus = {};
        this.events = [];
    }
    addTransition(transition, isStep) {
        let lastEvent;
        let intoStatus = StatusLikeParser.parse(transition.into);
        if (!isStep) {
            lastEvent = {
                type: StatusEventType.TRANSITION,
                fromStatus: this.currentStatus.name,
                intoStatus: intoStatus,
                transitionName: transition.transitionName,
                transitionPayload: transition.payload
            };
        }
        else {
            lastEvent = {
                type: StatusEventType.STEP,
                reducerName: transition.transitionName,
                newData: intoStatus.data,
                reducerPayload: transition.payload
            };
        }
        this.lastEvent = lastEvent;
        this.process(lastEvent);
    }
    addStateFromStatus(stateEvent) {
        this.lastEvent = stateEvent;
        this.process(stateEvent);
    }
    addProcessingStatus(statusRequest, isStep) {
        let lastEvent;
        if (!isStep) {
            lastEvent = {
                type: StatusEventType.PROCESSING_STATUS,
                status: statusRequest.status
            };
        }
        else {
            lastEvent = {
                type: StatusEventType.PROCESSING_STATE,
                data: statusRequest.status.data
            };
        }
        this.currentStatus = statusRequest.status;
        this.lastEvent = lastEvent;
        this.process(lastEvent);
    }
    settleProcessingStatus(statusRequest, isStep) {
        if (!isStep) {
            if (this.lastEvent.status !== statusRequest.status) {
                throw new Error(`unexpected error settling events`);
            }
            this.lastEvent.type = StatusEventType.STATUS;
            this.addStateFromStatus({
                data: statusRequest.status.data,
                type: StatusEventType.STATE
            });
        }
        else {
            if (this.lastEvent.data !== statusRequest.status.data) {
                throw new Error(`unexpected error settling events`);
            }
            this.lastEvent.type = StatusEventType.STATE;
            this.eventsByStatus[this.currentStatus.name].lastState = statusRequest.status.data;
        }
    }
    process(lastEvent) {
        if (this.eventsByStatus[this.currentStatus.name] == null) {
            this.eventsByStatus[this.currentStatus.name] = {
                allEvents: [],
                statusName: this.currentStatus.name,
                lastState: undefined
            };
        }
        let eventWithStatusInfo = {
            event: lastEvent,
            statusName: this.currentStatus.name
        };
        this.eventsByStatus[this.currentStatus.name].allEvents.push(eventWithStatusInfo);
        if (lastEvent.type === StatusEventType.STATE || lastEvent.type === StatusEventType.PROCESSING_STATE) {
            this.eventsByStatus[this.currentStatus.name].lastState = lastEvent.data;
        }
        this.events.push(eventWithStatusInfo);
    }
    serializeStatesWithStatus(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATE] }));
    }
    serializeStates(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATE] })).map(it => it.event);
    }
    serializeStatuses(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATUS] })).map(it => it.event);
    }
    serialize(filterOptions) {
        return this.serializeWithStatusInfo(filterOptions).map(it => it.event);
    }
    serializeWithStatusInfo(filterOptions) {
        if (!filterOptions) {
            return this.events;
        }
        let filtered = [];
        this.events.forEach(eventWithStatusInfo => {
            let toBeIncluded = true;
            if (!toBeIncluded)
                return;
            if (filterOptions.excludeInit) {
                if (this.eventsByStatus['$init'].allEvents.indexOf(eventWithStatusInfo) > -1) {
                    toBeIncluded = false;
                }
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.excludeStop) {
                if (this.eventsByStatus['$stop'] && this.eventsByStatus['$stop'].allEvents.indexOf(eventWithStatusInfo) > -1) {
                    toBeIncluded = false;
                }
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.statuses) {
                filterOptions.statuses.forEach(status => {
                    if (toBeIncluded)
                        return;
                    if (this.eventsByStatus[status].allEvents.indexOf(eventWithStatusInfo) === -1) {
                        toBeIncluded = false;
                    }
                });
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.eventTypes) {
                if (filterOptions.eventTypes.indexOf(eventWithStatusInfo.event.type) === -1) {
                    toBeIncluded = false;
                }
            }
            if (toBeIncluded) {
                filtered.push(eventWithStatusInfo);
            }
        });
        return filtered;
    }
    getLastStates() {
        let lastStates = {};
        Object.keys(this.eventsByStatus).forEach(statusKey => {
            lastStates[statusKey] = this.eventsByStatus[statusKey].lastState;
        });
        return lastStates;
    }
    getLastState(statusName) {
        let eventsByStatus = this.eventsByStatus[statusName];
        if (eventsByStatus == null)
            return undefined;
        return eventsByStatus.lastState;
    }
}

var BindBackType;
(function (BindBackType) {
    BindBackType["STEP"] = "STEP";
    BindBackType["TRANSITION"] = "TRANSITION";
})(BindBackType || (BindBackType = {}));
class FlowAnchor {
    createNewThread(flowController, flowOrchestrator) {
        let flowEvents = new FlowEventsTracker();
        let flowThread = new FlowThread(flowController, flowOrchestrator, flowEvents);
        this.currentThread = {
            flowEvents: flowEvents,
            flowThread: flowThread,
        };
        return flowThread;
    }
    getCurrentEvents() {
        return this.currentThread.flowEvents;
    }
    get currentStatus() {
        if (!this.currentThread)
            return undefined;
        return this.currentThread.flowEvents.currentStatus;
    }
    getStatusDataProducerFn() {
        return (statusName, defaultValue) => {
            let statusData = this.currentThread.flowEvents.getLastStates();
            if (Object.keys(statusData).indexOf(statusName) === -1) {
                return defaultValue;
            }
            return statusData[statusName];
        };
    }
    getDataFn(status) {
        return () => {
            let currentStatus = this.currentThread.flowEvents.currentStatus.name;
            if (status !== currentStatus) {
                throw new Error(`unexpected error trying to retrieve the last status for [${status}, but the current status is [${currentStatus}]]`);
            }
            return this.currentThread.flowEvents.getLastState(status);
        };
    }
    bindBack(expectedStatusName, param, type) {
        if (!this.currentThread.flowThread.flowController.isRunning) {
            return;
        }
        if (param.result.name != "$stop" && (!this.currentStatus || this.currentStatus.name !== expectedStatusName)) {
            throw Error(`unable to request [${param.methodName}] as is meant for status [${expectedStatusName}], but the current status is [${this.currentStatus ? this.currentStatus.name : '-'}]`);
        }
        if (type === BindBackType.STEP) {
            this.currentThread.flowThread.requestStep(param.statusName, param.methodName, param.payload, param.result);
        }
        else {
            this.currentThread.flowThread.requestTransition({
                into: param.result,
                payload: param.payload,
                transitionName: param.methodName
            }, false);
        }
    }
    getStatusData() {
        return this.currentThread.flowEvents.getLastStates();
    }
}

class Proxyfier {
    static proxy(from, enricher) {
        let proxy = {};
        let prototype = Object.getPrototypeOf(from);
        let methodHost = prototype.constructor.name === 'Object' ? from : prototype;
        let ownPropertyNames = Object.getOwnPropertyNames(methodHost);
        ownPropertyNames.forEach(key => {
            if (key === 'constructor')
                return;
            let toProxy = methodHost[key];
            if (typeof toProxy !== 'function')
                return;
            proxy[key] = (...payload) => {
                let originalCall = () => from[key](...payload);
                return enricher(originalCall, {
                    methodName: key,
                    payload
                });
            };
        });
        return proxy;
    }
}

class MutatorsFactory {
    static createDefaultStepsDef() {
        return (getData) => ({
            $update(reducer) {
                if (typeof reducer !== 'function')
                    return reducer;
                return reducer(getData());
            }
        });
    }
    static createDefaultTransitionDef() {
        return (() => ({
            $toStatus(toStatus) {
                return StatusLikeParser.parse(toStatus);
            }
        }));
    }
    static createDefaultSteps(statusName, flowAnchor) {
        return this.createSteps(statusName, flowAnchor, this.createDefaultStepsDef());
    }
    static createTransitions(statusName, flowAnchor, userTransitions) {
        let defaultTransitionDef = this.createDefaultTransitionDef();
        return this.doCreateTransitions(statusName, flowAnchor, userTransitions ? [userTransitions, defaultTransitionDef] : [defaultTransitionDef]);
    }
    static createSteps(statusName, flowAnchor, userStepsDef) {
        let defaultStepDef = this.createDefaultStepsDef();
        return this.doCreateSteps(statusName, flowAnchor, userStepsDef ? [userStepsDef, defaultStepDef] : [defaultStepDef]);
    }
    static doCreateSteps(statusName, flowAnchor, allStepsDef) {
        let dataProducerFn = flowAnchor.getDataFn(statusName);
        let allSteps = {};
        allStepsDef.forEach(it => {
            let thisStep = it(dataProducerFn);
            allSteps = Object.assign(Object.assign({}, allSteps), thisStep);
        });
        return this.bindToAnchor(statusName, flowAnchor, allSteps, BindBackType.STEP);
    }
    static doCreateTransitions(statusName, flowAnchor, allTransitionsDef) {
        let statusDataProducerFn = flowAnchor.getStatusDataProducerFn();
        let allTransitions = {};
        allTransitionsDef.forEach(it => {
            let thisTransitions = it(statusDataProducerFn);
            allTransitions = Object.assign(Object.assign({}, allTransitions), thisTransitions);
        });
        return this.bindToAnchor(statusName, flowAnchor, allTransitions, BindBackType.TRANSITION);
    }
    static bindToAnchor(expectedStatusName, flowAnchor, toBind, type) {
        return Proxyfier.proxy(toBind, (originalCall, metadata) => {
            let newState = originalCall();
            flowAnchor.bindBack(expectedStatusName, {
                statusName: flowAnchor.currentStatus.name,
                methodName: metadata.methodName,
                payload: metadata.payload,
                result: newState,
            }, type);
            return newState;
        });
    }
}

const $INIT = "$init";
const $STOP = "$stop";

class ReactionDefLikeParser {
    static parse(toParse, reactionType, defaultName) {
        if (typeof toParse === "object")
            return toParse;
        return {
            name: defaultName ? defaultName : 'anonymous',
            reactionType: reactionType,
            action: toParse
        };
    }
}

class FlowDefFactory {
    static create(userFlowDef, flowAnchor) {
        let statusesByStatusName = FlowDefFactory.statusesByName(userFlowDef.statuses, flowAnchor);
        statusesByStatusName[$INIT] = {
            name: $INIT,
            steps: MutatorsFactory.createDefaultSteps($INIT, flowAnchor),
            transitions: MutatorsFactory.createTransitions($INIT, flowAnchor),
            reactions: userFlowDef.$onInit ?
                userFlowDef.$onInit.map(it => (ReactionDefLikeParser.parse(it, ReactionType.ALWAYS, `on init`))) : [],
        };
        statusesByStatusName[$STOP] = {
            name: $STOP,
            steps: MutatorsFactory.createDefaultSteps($STOP, flowAnchor),
            transitions: MutatorsFactory.createTransitions($STOP, flowAnchor),
            reactions: userFlowDef.$onStop ?
                userFlowDef.$onStop.map(it => (ReactionDefLikeParser.parse(it, ReactionType.ALWAYS, `on stop`))) : [],
        };
        return Object.assign({ statusesByStatusName: statusesByStatusName, name: userFlowDef.name }, userFlowDef.initialStatus ? { starter: () => userFlowDef.initialStatus } : undefined);
    }
    static statusesByName(userStatusesDefLike, flowAnchor) {
        let statusesByName = {};
        if (Array.isArray(userStatusesDefLike)) {
            userStatusesDefLike.forEach(it => {
                statusesByName[it] = {
                    name: it,
                    steps: [],
                    reactions: [],
                };
            });
        }
        else {
            Objects.foreachEntry(userStatusesDefLike, (value, key) => {
                statusesByName[key] = {
                    name: key,
                    steps: MutatorsFactory.createSteps(key, flowAnchor, value.steps),
                    transitions: MutatorsFactory.createTransitions(key, flowAnchor, value.transitions),
                    reactions: value.reactions ?
                        value.reactions.map(it => ReactionDefLikeParser.parse(it, ReactionType.ALWAYS, `on[${key}]`)) :
                        [],
                    getLastData: flowAnchor.getDataFn(key)
                };
            });
        }
        return statusesByName;
    }
}

class FlowRuntimeTracker {
    constructor(orchestrator, event) {
        this.orchestrator = orchestrator;
        this.event = event;
    }
    trace(timing, shortDesc, payload) {
        return this.doTick(timing, shortDesc, payload, {
            highlight: false
        });
    }
    highlight(timing, shortDesc, payload) {
        return this.doTick(timing, shortDesc, payload, {
            highlight: true
        });
    }
    doTick(timing, shortDesc, payload, loggingOptions) {
        let event = Object.assign(Object.assign(Object.assign({}, this.event), { shortDesc,
            timing }), (payload ? { payload } : undefined));
        this.orchestrator.onRuntimeEvent(this, event, loggingOptions);
        return this;
    }
}

class FlowOrchestrator {
    constructor(eventsProcessor) {
        this.eventsProcessor = eventsProcessor;
        this.pastTrackers = [];
    }
    onRuntimeEvent(tracker, event, loggingOptions) {
        if (event.timing === FlowRuntimeEventTiming.REQUEST_START) {
            this.currentTracker = tracker;
        }
        else if (event.timing === FlowRuntimeEventTiming.REQUEST_END || event.timing === FlowRuntimeEventTiming.REQUEST_CANCEL) {
            this.pastTrackers.push(tracker);
            this.currentTracker = undefined;
        }
        this.eventsProcessor.forEach(it => it(event, loggingOptions));
    }
    createRuntimeTracker(flowController, source, runtimeEvent, payload) {
        return new FlowRuntimeTracker(this, {
            flowController: flowController,
            source,
            runtimeEvent,
            payload
        });
    }
}

class FlowLogger {
    constructor(filters) {
        this.filters = filters;
    }
    log(event, loggingOptions) {
        for (let filter of this.filters) {
            if (!filter(event)) {
                return;
            }
        }
        let currentStatusName = event.flowController.getCurrentStatusName();
        currentStatusName = currentStatusName ? currentStatusName : '-';
        if (loggingOptions.highlight) {
            console.log(Strings.padEnd(`${event.flowController.getName()}`, 30), Strings.padEnd(`${currentStatusName}`, 20), Strings.padEnd(`${event.runtimeEvent}`, 20), Strings.padEnd(`${event.timing}`, 20));
            if (event.payload || event.shortDesc) {
                if (event.shortDesc) {
                    console.log(`  =>[${event.shortDesc}]`);
                    if (event.payload) {
                        console.log(' ', event.payload);
                    }
                }
                else {
                    console.log(`  =>[${event.payload}]`);
                }
            }
            console.log('------------------------------------------------------------------------------------------------------------------------------------------------');
        }
        else if (event.shortDesc) {
            console.log(Strings.padEnd(`${event.flowController.getName()}`, 30), Strings.padEnd(`${currentStatusName}`, 20), Strings.padEnd(`${event.runtimeEvent}`, 20), Strings.padEnd(`${event.timing}`, 20), Strings.padEnd(`=>${event.shortDesc}`, 30));
        }
    }
}
class LoggerFilters {
    static excludeByLogName(nameToExclude) {
        return (logEvent) => logEvent.flowController.getName() !== nameToExclude;
    }
    static excludeByEventTiming(eventTiming) {
        return (logEvent) => logEvent.timing !== eventTiming;
    }
}
const FLOW_LOGGER = new FlowLogger([
    LoggerFilters.excludeByEventTiming(FlowRuntimeEventTiming.REQUEST_END),
    LoggerFilters.excludeByEventTiming(FlowRuntimeEventTiming.REQUEST_START),
    LoggerFilters.excludeByLogName('next-promise'),
]);

(function (AsapType) {
    AsapType["NOW"] = "NOW";
    AsapType["LATER"] = "LATER";
})(exports.AsapType || (exports.AsapType = {}));
function isPromise(toParse) {
    if (toParse == null)
        return false;
    if (typeof toParse != "object")
        return false;
    return ('then' in toParse) && typeof (toParse.then) === 'function';
}
function isAsap(toParse) {
    return (toParse instanceof NowImpl) || (toParse instanceof LaterImpl);
}
class NowImpl {
    constructor(rawValue) {
        this.rawValue = rawValue;
        this.type = exports.AsapType.NOW;
    }
    cancel() {
        return false;
    }
    then(consumer) {
        consumer(this.rawValue);
        return this;
    }
    map(mapper) {
        return Asaps.now(mapper(this.rawValue));
    }
    merge(mapper) {
        const [next, asap] = Asaps.next();
        this.then(value => mapper(value).then(toMerge => next(toMerge)));
        return asap;
    }
    catch(error) {
        //Since is not async, it would never fail
        return this;
    }
    onCancel(consumer) {
        //Since is not async, it would never cancel
        return this;
    }
}
class LaterImpl {
    constructor(flow) {
        this.flow = flow;
        this.type = exports.AsapType.LATER;
    }
    map(mapper) {
        let [setNext, nextAsap] = Asaps.next();
        this.then(value => setNext(mapper(value)));
        this.onCancel(() => nextAsap.cancel());
        return nextAsap;
    }
    then(consumer) {
        if (this.flow.getCurrentStatusName() === 'resolved') {
            consumer(this.flow.on('resolved').getLastData());
        }
        else {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { then: [...current.then, consumer] })));
        }
        return this;
    }
    resolve(value) {
        if (this.flow.getCurrentStatusName() === 'cancelled')
            return;
        try {
            this.flow.assertOn('resolving', (onResolving) => {
                onResolving.getData().then.forEach(subscriber => {
                    subscriber(value);
                });
                this.flow.on('resolving').transitions.$toStatus({
                    name: "resolved",
                    data: value
                });
            });
        }
        catch (e) {
            console.error(e);
            this.flow.assertOn('resolving', (onResolving) => {
                onResolving.getData().catch.forEach(subscriber => {
                    subscriber(e, value);
                });
                onResolving.do.$toStatus({ name: "errored", data: value });
            });
        }
    }
    onCancel(consumer) {
        if (this.flow.getCurrentStatusName() === 'cancelled') {
            consumer();
            return;
        }
        if (this.flow.getCurrentStatusName() === 'resolving') {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { onCancel: [...current.onCancel, consumer] })));
        }
        return this;
    }
    cancel() {
        if (this.flow.getCurrentStatusName() !== 'resolving') {
            return false;
        }
        this.flow.assertOn('resolving', onResolving => {
            onResolving.getData().onCancel.forEach(subscriber => {
                subscriber();
            });
            this.flow.on('resolving').transitions.$toStatus({ name: "cancelled", });
        });
        return true;
    }
    merge(mapper) {
        const [next, asap] = Asaps.next();
        this.then(value => mapper(value)
            .then(toMerge => next(toMerge))
            .onCancel(() => asap.cancel())).onCancel(() => asap.cancel());
        return asap;
    }
    catch(consumer) {
        if (this.flow.getCurrentStatusName() === 'resolving') {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { catch: [...current.catch, consumer] })));
        }
        return this;
    }
}
class AsapParser {
    static from(toParse) {
        return isAsap(toParse) ?
            toParse :
            isPromise(toParse) ?
                Asaps.fromPromise(toParse) :
                Asaps.now(toParse);
    }
}
class Asaps {
    static now(value) {
        return new NowImpl(value);
    }
    static fromPromise(promise) {
        let promiseImpl = new LaterImpl(Flows.createController({
            name: 'next-promise',
            statuses: {
                resolving: {},
                resolved: {},
                errored: {},
                cancelled: {}
            },
            initialStatus: {
                name: 'resolving',
                data: {
                    then: [],
                    catch: [],
                    onCancel: [],
                }
            }
        }).start());
        promise.then(value => promiseImpl.resolve(value));
        promise.catch(e => promiseImpl.catch(e));
        return promiseImpl;
    }
    static delayed(value, ms) {
        return Asaps.fromPromise(new Promise((done) => setTimeout(() => done(value), ms)));
    }
    static fetch(url) {
        return Asaps.fromPromise(new Promise((done) => {
            fetch(url)
                .then((resp) => resp.json()) // Transform the data into json
                .then(function (data) {
                done(data);
            });
        }));
    }
    static next() {
        let laterImpl = new LaterImpl(Flows.createController({
            name: 'next-promise',
            statuses: {
                resolving: {},
                resolved: {},
                errored: {},
                cancelled: {}
            },
            initialStatus: {
                name: 'resolving',
                data: {
                    then: [],
                    catch: [],
                    onCancel: []
                }
            }
        }).start());
        return [(value) => laterImpl.resolve(value), laterImpl];
    }
}

function deferParser(deferLike, otherwise) {
    if (!isAsap(deferLike))
        return deferLike;
    return {
        action: deferLike,
        name: otherwise.name,
        payload: otherwise.payload
    };
}

class FlowImpl {
    constructor(flowDef, flowAnchor, flowOrchestrator) {
        this.flowDef = flowDef;
        this.flowAnchor = flowAnchor;
        this.flowOrchestrator = flowOrchestrator;
        this.isRunning = false;
    }
    start(initialStatus) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowRuntimeEventSource.FLOW_CONTROLLER, FlowRuntimeEventType.START, initialStatus).trace(FlowRuntimeEventTiming.REQUEST_START);
        if (this.isRunning) {
            throw new Error(`can't request a flow that it has been started to start again`);
        }
        this.flowThread = this.flowAnchor.createNewThread(this, this.flowOrchestrator);
        this.isRunning = true;
        if (initialStatus == null && this.flowDef.starter == null) {
            this.requestStatus($INIT);
            return this;
        }
        let actualStarter = initialStatus ? initialStatus : this.flowDef.starter();
        let doStart = (status) => {
            this.addReaction($INIT, {
                action: () => {
                    tracker.highlight(FlowRuntimeEventTiming.TRACE, 'initialStatus - resolved', status);
                    this.requestStatus(status);
                },
                reactionType: ReactionType.ONCE,
                name: 'to initial state'
            });
            this.addReaction($STOP, {
                name: `onStop=>notifyEvents`,
                reactionType: ReactionType.ONCE,
                action: onStop => {
                    onStop.chain(() => {
                        tracker.highlight(FlowRuntimeEventTiming.TRACE, 'state machine stopped');
                        this.flowThread = null;
                        this.isRunning = false;
                    });
                }
            });
            this.requestStatus($INIT);
        };
        AsapParser.from(actualStarter).then(status => doStart(status));
        tracker.trace(FlowRuntimeEventTiming.REQUEST_END);
        return this;
    }
    requestStatus(statusLike) {
        let statusName = StatusLikeParser.parse(statusLike).name;
        if (!this.isRunning)
            return;
        if (this.on(statusName) == null) {
            throw new Error(`unable to request non existing status [${statusName}]`);
        }
        this.flowThread.requestStatus(statusLike, false);
    }
    requestState(statusName, data) {
        if (!this.isRunning)
            return;
        this.flowThread.requestState(statusName, data);
    }
    requestTransition(transition) {
        if (!this.isRunning)
            return;
        this.flowThread.requestTransition(transition, false);
        return this;
    }
    requestStep(statusName, reducerName, payload, data) {
        if (!this.isRunning)
            return;
        this.flowThread.requestStep(statusName, reducerName, payload, data);
    }
    stop(eventsCb) {
        if (!this.isRunning) {
            throw new Error(`unexpected`);
        }
        this.addReaction($STOP, {
            name: `onStop=>notifyEvents`,
            reactionType: ReactionType.ONCE,
            action: () => {
                if (eventsCb) {
                    eventsCb(this.flowAnchor.getCurrentEvents());
                }
            }
        });
        this.requestStatus({
            name: $STOP
        });
        return this;
    }
    alwaysOn(stateName, def) {
        return this.addReaction(stateName, {
            name: `-`,
            reactionType: ReactionType.ALWAYS,
            action: def
        });
    }
    onceOnInit(def) {
        return this.onceOn($INIT, def);
    }
    onceOnStop(def) {
        return this.onceOn($STOP, def);
    }
    onceOn(stateName, def) {
        return this.addReaction(stateName, {
            name: `-`,
            reactionType: ReactionType.ONCE,
            action: def
        });
    }
    addReaction(statusName, reaction) {
        let needsToBeAdded = true;
        if (this.isRunning) {
            if (this.flowThread.tryToQueue(statusName, reaction)) {
                return this;
            }
            this.runIf(statusName, {
                action: (context) => {
                    reaction.action(context);
                    if (reaction.reactionType === ReactionType.ONCE) {
                        needsToBeAdded = false;
                    }
                },
                reactionType: reaction.reactionType,
                name: reaction.name
            });
        }
        if (needsToBeAdded) {
            let statusDef = this.on(statusName);
            if (statusDef == null) {
                throw new Error(`unable to add reactions for unknown event [${statusName}]`);
            }
            this.addReactionNext(statusDef, reaction);
        }
        return this;
    }
    addReactionNext(statusDef, reaction) {
        statusDef.reactions.push(reaction);
        return this;
    }
    getReactions(statusName) {
        let statusDef = this.on(statusName);
        if (statusDef == null) {
            throw new Error(`can't getReactions for unknown status[${statusName}]`);
        }
        return statusDef.reactions;
    }
    getCurrentStatusName() {
        if (this.flowThread == undefined)
            return undefined;
        return this.flowThread.getCurrentStatusName();
    }
    getEvents() {
        return this.flowAnchor.getCurrentEvents();
    }
    getName() {
        return this.flowDef.name;
    }
    getState() {
        return this.flowThread.getCurrentState();
    }
    getStatusData() {
        return this.flowAnchor.getStatusData();
    }
    onInit() {
        return this.on($INIT);
    }
    on(statusName) {
        return this.flowDef.statusesByStatusName[statusName];
    }
    getStatusDefs() {
        return this.flowDef.statusesByStatusName;
    }
    removeReaction(statusName, reactionToRemove) {
        let statusDef = this.on(statusName);
        let previousReactions = statusDef.reactions;
        if (!previousReactions)
            return;
        statusDef.reactions = previousReactions.filter(it => it !== reactionToRemove);
    }
    processReactions(statusName) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowRuntimeEventSource.FLOW_CONTROLLER, FlowRuntimeEventType.PROCESS_REACTIONS, statusName).trace(FlowRuntimeEventTiming.REQUEST_START);
        let onAllReactionsCompleted;
        this.getReactions(statusName).forEach(reaction => {
            if (reaction.reactionType === ReactionType.ONCE) {
                this.removeReaction(statusName, reaction);
            }
            reaction.action(this.flowThread.createContext(statusName, (cb) => onAllReactionsCompleted = cb));
        });
        if (onAllReactionsCompleted) {
            onAllReactionsCompleted();
        }
        tracker.trace(FlowRuntimeEventTiming.REQUEST_END, statusName);
        return this;
    }
    getStateData() {
        throw new Error(`TBI`);
    }
    reactOnStatusChanged(customReaction) {
        Object.keys(this.getStatusDefs()).forEach(stateName => {
            this.addReaction(stateName, {
                name: `-`,
                reactionType: ReactionType.ALWAYS,
                action: context => customReaction({ name: stateName, data: context.getData() })
            });
        });
        return this;
    }
    runIf(statusName, reaction, elseIf) {
        if (!this.isRunning) {
            if (elseIf)
                elseIf();
            return;
        }
        let currentStatus = this.getCurrentStatusName();
        if (currentStatus == null) {
            if (elseIf) {
                elseIf();
            }
            return;
        }
        if (currentStatus === statusName) {
            this.doRun(reaction, statusName);
        }
        else {
            if (elseIf) {
                elseIf();
            }
        }
    }
    doRun(reaction, currentState) {
        reaction.action(this.flowThread.createContext(currentState, (cb) => cb()));
    }
    assertOn(status, then) {
        let currentStatusName = this.getCurrentStatusName();
        if (currentStatusName !== status) {
            throw new Error(`asserting that we are on the status [${status}]. But we are currently on [${currentStatusName}]`);
        }
        if (then) {
            this.onceOn(status, onAssertedStatus => then(onAssertedStatus));
        }
        return this;
    }
    chainInto(statusFrom, statusTo, mutatorsCb) {
        const [next, asap] = Asaps.next();
        this.assertOn(statusFrom);
        this.addReactionNext(this.on(statusTo), {
            name: `once on next`,
            reactionType: ReactionType.ONCE,
            action: onChain => next(onChain)
        });
        this.onceOn(statusFrom, onThisStatus => mutatorsCb(onThisStatus.do));
        return asap;
    }
    deferInto(statusFrom, statusTo, mutatorsCbAsapLike) {
        let mutatorsCbAsap = deferParser(mutatorsCbAsapLike, {
            name: `[${this.getName()}]::${statusFrom}=>${statusTo}`,
            payload: `[${this.getName()}]::${statusFrom}=>${statusTo}`
        });
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowRuntimeEventSource.FLOW_CONTROLLER, FlowRuntimeEventType.MONITOR, {
            asap: mutatorsCbAsap.action,
            name: mutatorsCbAsap.name,
            payload: mutatorsCbAsap.payload
        }).trace(FlowRuntimeEventTiming.REQUEST_START);
        return mutatorsCbAsap.action.merge(cb => {
            tracker.trace(FlowRuntimeEventTiming.REQUEST_END);
            return this.chainInto(statusFrom, statusTo, cb);
        }).onCancel(() => {
            tracker.trace(FlowRuntimeEventTiming.REQUEST_CANCEL);
        });
    }
}

class FlowFacadeImpl {
    constructor(flow, actions) {
        this.flow = flow;
        this.actions = actions;
        this.do = actions;
    }
    addReaction(statusName, reaction) {
        this.flow.addReaction(statusName, reaction);
        return this;
    }
    alwaysOn(stateName, def) {
        this.flow.alwaysOn(stateName, def);
        return this;
    }
    assertOn(status, then) {
        this.flow.assertOn(status, then);
        return this;
    }
    chainInto(statusFrom, statusTo, mutatorsCb) {
        this.flow.chainInto(statusFrom, statusTo, mutatorsCb);
        return undefined;
    }
    getCurrentStatusName() {
        return this.flow.getCurrentStatusName();
    }
    getEvents() {
        return this.flow.getEvents();
    }
    getName() {
        return this.flow.getName();
    }
    getState() {
        return this.flow.getState();
    }
    getStatusData() {
        return this.flow.getStatusData();
    }
    on(statusName) {
        return this.flow.on(statusName);
    }
    onceOn(stateName, def) {
        this.flow.onceOn(stateName, def);
        return this;
    }
    onceOnInit(def) {
        this.flow.onceOnInit(def);
        return this;
    }
    onceOnStop(def) {
        this.flow.onceOnStop(def);
        return this;
    }
    start(initialStatus) {
        this.flow.start(initialStatus);
        return this;
    }
    stop(eventsCb) {
        this.flow.stop(eventsCb);
        return this;
    }
    get isRunning() {
        return this.flow.isRunning;
    }
    onInit() {
        return this.flow.onInit();
    }
    reactOnStatusChanged(customReaction) {
        this.flow.reactOnStatusChanged(customReaction);
        return this;
    }
    deferInto(statusFrom, statusTo, mutatorsCbAsap) {
        return this.flow.deferInto(statusFrom, statusTo, mutatorsCbAsap);
    }
    removeReaction(statusName, reactionToRemove) {
        this.flow.removeReaction(statusName, reactionToRemove);
    }
}

const FlowOrchestrator$ = (pipeline) => new FlowOrchestrator([
    (event, loggingOptions) => FLOW_LOGGER.log(event, loggingOptions),
    ...pipeline,
]);
class Flows {
    static create(flowDef) {
        let flowController = this.createController(flowDef);
        return this.createFacade(flowController, flowDef.actions);
    }
    static createFacade(flowController, actionsDef) {
        return new FlowFacadeImpl(flowController, actionsDef ? actionsDef(flowController) : undefined);
    }
    static createController(flowDef) {
        let flowAnchor = new FlowAnchor();
        let flowOrchestrator = FlowOrchestrator$(flowDef.pipelineListener ? [flowDef.pipelineListener] : []);
        let flowImpl = new FlowImpl(FlowDefFactory.create(flowDef, flowAnchor), flowAnchor, flowOrchestrator);
        let tracker = flowOrchestrator.createRuntimeTracker(flowImpl, FlowRuntimeEventSource.FLOW_FACTORY, FlowRuntimeEventType.CREATE_FLOW, flowDef).trace(FlowRuntimeEventTiming.REQUEST_START);
        tracker.trace(FlowRuntimeEventTiming.REQUEST_END, flowImpl);
        return flowImpl;
    }
}

class ThreadFacade {
    constructor(thread, actions) {
        this.thread = thread;
        this.actions = actions;
    }
    chain(mutatorsCb) {
        this.thread.chain(mutatorsCb);
        return undefined;
    }
    next(cb) {
        this.thread.next(cb);
    }
    start() {
        this.thread.start();
        return this;
    }
    stop(eventsConsumer) {
        this.thread.stop(eventsConsumer);
        return this;
    }
    get do() {
        let steps = this.reducers;
        return Object.assign(Object.assign({}, steps), this.actions);
    }
    get reducers() {
        return this.thread.reducers;
    }
    addReaction(def) {
        return this.thread.addReaction(def);
    }
    get isRunning() {
        return this.thread.isRunning;
    }
    getData() {
        return this.thread.getData();
    }
    getEvents() {
        return this.thread.getEvents();
    }
    getName() {
        return this.thread.getName();
    }
}

class MethodFinder {
    static exists(theObject, methodName) {
        if (theObject == null)
            return false;
        return this.find(theObject, methodName).length > 0;
    }
    static find(theObject, pattern = '') {
        let prototype = Object.getPrototypeOf(theObject);
        let methodHost = prototype.constructor.name === 'Object' ? theObject : prototype;
        let ownPropertyNames = Object.getOwnPropertyNames(methodHost);
        return ownPropertyNames.filter(it => it.startsWith(pattern));
    }
}

class Threads {
    static create(data) {
        let flow = Flows.createController(Object.assign(Object.assign({ name: data.name, statuses: {
                nextData: Object.assign({}, (data.reducers ? { steps: data.reducers } : undefined))
            } }, (data.initialData == null ? undefined : {
            initialStatus: AsapParser.from(data.initialData).map(data => ({
                name: 'nextData',
                data
            }))
        })), { pipelineListener: data.pipelineListener }));
        let threadImpl = new ThreadImpl(flow);
        if (data.actions && data.autoBind) {
            throw new Error(`you can only use actions or autoBind. Both in conjunction is illegal`);
        }
        let threadFacade;
        if (data.autoBind) {
            let methodsToProxy = [];
            let autoBindWrapper = Object.assign({}, data.autoBind);
            Object.keys(threadImpl.reducers).forEach(reducerWithDollar => {
                let actionName = reducerWithDollar.substring(1, reducerWithDollar.length);
                if (MethodFinder.exists(data.autoBind, actionName)) {
                    autoBindWrapper[actionName] = (...params) => {
                        return data.autoBind[actionName](...params);
                    };
                    methodsToProxy.push(actionName);
                }
                else {
                    autoBindWrapper[actionName] = (...params) => {
                        return threadImpl.chain(reducers => reducers[reducerWithDollar](...params));
                    };
                }
            });
            threadFacade = new ThreadFacade(threadImpl, Proxyfier.proxy(autoBindWrapper, (original, metadata) => {
                if (methodsToProxy.indexOf(metadata.methodName) === -1) {
                    return original();
                }
                return threadImpl.monitor(original(), (value, reducers) => reducers[`$${metadata.methodName}`](value), metadata.methodName, metadata.payload);
            }));
        }
        else {
            let actions = data.actions ? data.actions(threadImpl) : {};
            Object.keys(threadImpl.reducers).forEach(reducerKey => {
                let matchingActionName = reducerKey.substring(1, reducerKey.length);
                if (!actions[matchingActionName]) {
                    actions[matchingActionName] = (...params) => {
                        return threadImpl.chain(reducers => reducers[reducerKey](...params));
                    };
                }
            });
            threadFacade = new ThreadFacade(threadImpl, actions);
        }
        if (!data.cancelAutoStart) {
            threadFacade.start();
        }
        return threadFacade;
    }
}

class PipeMerge {
    constructor(name, base, leftThread, leftMapper, rightThread, rightMapper, pipeThreadDef) {
        this.name = name;
        this.base = base;
        this.leftThread = leftThread;
        this.leftMapper = leftMapper;
        this.rightThread = rightThread;
        this.rightMapper = rightMapper;
        this.pipeThreadDef = pipeThreadDef;
    }
    addReaction(def) {
        return this.baseThread.addReaction(def);
    }
    chain(mutatorsCb) {
        return this.baseThread.chain(mutatorsCb);
    }
    getData() {
        return this.baseThread.getData();
    }
    getEvents() {
        return this.baseThread.getEvents();
    }
    getName() {
        return this.baseThread.getName();
    }
    next(cb) {
        this.baseThread.next(cb);
    }
    start() {
        if (this.baseThread == null) {
            this.baseThread = Threads.create(Object.assign({ name: this.name, initialData: this.base }, this.pipeThreadDef));
            this.leftThread.addReaction({
                name: undefined,
                dataConsumer: (data) => {
                    this.lastLeftData = data;
                    this.baseThread.reducers.$update((current) => {
                        return this.leftMapper(data, this.lastRightData, current);
                    });
                },
            });
            this.rightThread.addReaction({
                name: undefined,
                dataConsumer: (data) => {
                    this.lastRightData = data;
                    this.baseThread.reducers.$update((current) => {
                        return this.rightMapper(data, this.lastLeftData, current);
                    });
                },
            });
        }
        else {
            this.baseThread.start();
        }
        return this;
    }
    stop(eventsConsumer) {
        this.baseThread.stop(undefined);
        return this;
    }
    get reducers() {
        return this.baseThread.reducers;
    }
    get do() {
        return this.baseThread.do;
    }
    get isRunning() {
        return this.baseThread.isRunning;
    }
    get actions() {
        return this.baseThread.actions;
    }
    get thread() {
        return this.baseThread.thread;
    }
}

class PipeFilter {
    constructor(fromThread, filter, name, base) {
        this.fromThread = fromThread;
        this.filter = filter;
        this.name = name;
        this.base = base;
    }
    addReaction(def) {
        return this.baseThread.addReaction(def);
    }
    chain(mutatorsCb) {
        return this.baseThread.chain(mutatorsCb);
    }
    getData() {
        return this.baseThread.getData();
    }
    getEvents() {
        return this.baseThread.getEvents();
    }
    getName() {
        return this.baseThread.getName();
    }
    next(cb) {
        this.baseThread.next(cb);
    }
    start() {
        if (this.baseThread == null) {
            this.baseThread = Threads.create({
                name: this.name,
                initialData: this.base
            });
            this.fromThread.addReaction({
                name: undefined,
                dataConsumer: (data) => {
                    if (this.filter(data, this.lastState)) {
                        this.lastState = data;
                        this.reducers.$update(data);
                    }
                },
            });
        }
        else {
            this.baseThread.start();
        }
        return this;
    }
    stop(eventsConsumer) {
        this.baseThread.stop(undefined);
    }
    get reducers() {
        return this.baseThread.reducers;
    }
    get isRunning() {
        return this.baseThread.isRunning;
    }
}

class Pipes {
    static fromMonitor(monitor, baseValue, monitorMerger, dataMerger) {
        let pipeMerge = new PipeMerge(`pipeMonitorRaw[${monitor.getName()}]`, baseValue, monitor.mainThread, (data, monitorInfo, into) => dataMerger(data, into), monitor.asyncThread, (monitorInfo, data, into) => monitorMerger(monitorInfo, into));
        pipeMerge.start();
        return new PipeFilter(pipeMerge, (current, previous) => !Objects.deepEquals(current, previous), `pipeMonitor[${monitor.getName()}]`, baseValue).start();
    }
    static tupleCombine(left, right, baseValue, pipeThreadDef) {
        return new PipeMerge(`combineArray => [${left.getName()}, ${right.getName()}]`, baseValue, left, (left, right, into) => [left, into[1]], right, (right, left, into) => [into[0], right], pipeThreadDef).start();
    }
}

class ConanState {
    constructor(state) {
        this.state = state;
    }
    getName() {
        return this.state.getName();
    }
    connectMap(toConnect, mapper) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: mapper });
    }
    connectLive(renderer, fallbackValue) {
        return React.createElement(StateLive, { from: this, renderer: renderer, fallbackValue: fallbackValue });
    }
    connectData(toConnect) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: (data) => data });
    }
    connect(toConnect) {
        return React.createElement(StateConnect, { from: this, into: toConnect });
    }
    addAsyncReaction(def) {
        if (this.state instanceof ThreadFacade) {
            return;
        }
        return this.state.addAsyncReaction(def);
    }
    addDataReaction(def) {
        return this.state.addReaction(def);
    }
    get do() {
        return this.state.do;
    }
    start() {
        this.state.start();
        return this;
    }
    stop(eventsConsumer) {
        this.state.stop(eventsConsumer);
        return this;
    }
    get actions() {
        return this.state.actions;
    }
    getData() {
        return this.state.getData();
    }
    asyncMerge(baseValue, monitorMerger, dataMerger) {
        if (this.state instanceof ThreadFacade) {
            throw new Error(`this conan state is not ready for async`);
        }
        let mergedThread = Pipes.fromMonitor(this.state, baseValue, monitorMerger, dataMerger);
        return new ConanState(new ThreadFacade(mergedThread, this.actions));
    }
}

class MonitorFacade {
    constructor(monitor, actions) {
        this.monitor = monitor;
        this.actions = actions;
    }
    start() {
        this.monitor.start();
        return this;
    }
    addAsyncReaction(def) {
        return this.monitor.addAsyncReaction(def);
    }
    addReaction(def) {
        return this.monitor.addReaction(def);
    }
    get do() {
        return this.monitor.do;
    }
    getEvents() {
        return this.monitor.getEvents();
    }
    getName() {
        return this.monitor.getName();
    }
    stop(eventsConsumer) {
        this.monitor.stop(eventsConsumer);
    }
    getData() {
        return this.monitor.getData();
    }
    next(cb) {
        this.monitor.next(cb);
    }
    get asyncThread() {
        return this.monitor.asyncThread;
    }
    get mainThread() {
        return this.monitor.mainThread;
    }
}

class MonitorImpl {
    constructor(mainThread, asyncThread) {
        this.mainThread = mainThread;
        this.asyncThread = asyncThread;
    }
    start() {
        this.mainThread.start();
        return this;
    }
    addReaction(def) {
        return this.mainThread.addReaction(def);
    }
    addAsyncReaction(def) {
        return this.asyncThread.addReaction(def);
    }
    get do() {
        return this.mainThread.do;
    }
    getEvents() {
        return this.mainThread.getEvents();
    }
    getName() {
        return this.mainThread.getName();
    }
    stop(eventsConsumer) {
        this.mainThread.stop(eventsConsumer);
    }
    getData() {
        return this.mainThread.getData();
    }
    next(cb) {
        this.mainThread.next(cb);
    }
}

class Monitors {
    static create(data) {
        let asyncThread = this.createAsyncThread(data);
        let mainThread = Threads.create(Object.assign(Object.assign({}, data), { pipelineListener: (event) => {
                if (event.runtimeEvent === FlowRuntimeEventType.MONITOR) {
                    if (event.timing === FlowRuntimeEventTiming.REQUEST_START) {
                        asyncThread.do.tick(event.payload);
                    }
                    else if (event.timing === FlowRuntimeEventTiming.REQUEST_END) {
                        asyncThread.do.unTick(event.payload, false);
                    }
                    else if (event.timing === FlowRuntimeEventTiming.REQUEST_CANCEL) {
                        asyncThread.do.unTick(event.payload, true);
                    }
                    return;
                }
            } }));
        let monitorImpl = new MonitorImpl(mainThread, asyncThread);
        return new MonitorFacade(monitorImpl, mainThread.actions);
    }
    static createAsyncThread(data) {
        return Threads.create({
            name: `monitor[${data.name}]`,
            actions: thread => ({
                tick(toMonitor) {
                    thread.reducers.$update(current => ({
                        status: exports.MonitorStatus.ASYNC_START,
                        currentAction: toMonitor,
                        inProgressActions: [...current.inProgressActions, toMonitor]
                    }));
                },
                unTick(toMonitor, cancelled) {
                    thread.reducers.$update(current => {
                        return ({
                            status: cancelled ? exports.MonitorStatus.ASYNC_CANCELLED : exports.MonitorStatus.ASYNC_FULFILLED,
                            currentAction: toMonitor,
                            inProgressActions: current.inProgressActions.filter(it => it !== toMonitor)
                        });
                    });
                    if (thread.getData().inProgressActions.length === 0)
                        thread.reducers.$update(current => ({
                            inProgressActions: [],
                            currentAction: undefined,
                            status: exports.MonitorStatus.IDLE
                        }));
                }
            }),
            initialData: {
                inProgressActions: [],
                status: exports.MonitorStatus.IDLE,
                currentAction: undefined
            }
        });
    }
}

class Conan {
    static light(name, initialData) {
        return new ConanState(Monitors.create({
            name,
            initialData
        }));
    }
    static state(data) {
        return new ConanState(Monitors.create(data));
    }
}

class Lists {
    static mergeCombine(from, toMerge, comparator, merger) {
        let result = [];
        let anythingChanged = false;
        result = toMerge.map(it => {
            for (let inSrc of from) {
                if (comparator(inSrc, it)) {
                    anythingChanged = true;
                    return merger(inSrc, it);
                }
            }
            return it;
        });
        return anythingChanged ? result : toMerge;
    }
}

exports.AsapParser = AsapParser;
exports.Asaps = Asaps;
exports.Conan = Conan;
exports.ConanState = ConanState;
exports.ContextStateConnect = ContextStateConnect;
exports.ContextStateLive = ContextStateLive;
exports.ContextStateMapConnect = ContextStateMapConnect;
exports.DiAnnotationsMetadataFactory = DiAnnotationsMetadataFactory;
exports.DiContextFactory = DiContextFactory;
exports.DynamicOrStatics = DynamicOrStatics;
exports.Flows = Flows;
exports.InjectByName = InjectByName;
exports.InjectByType = InjectByType;
exports.InjectDynamic = InjectDynamic;
exports.Lists = Lists;
exports.ReactStateContext = ReactStateContext;
exports.StateConnect = StateConnect;
exports.StateLive = StateLive;
exports.StateMapConnect = StateMapConnect;
exports.contextStateConnect = contextStateConnect;
exports.contextStateLive = contextStateLive;
exports.contextStateMapConnect = contextStateMapConnect;
exports.diAnnotationsCrud = diAnnotationsCrud;
exports.isAsap = isAsap;
exports.stateConnect = stateConnect;
exports.stateLive = stateLive;
exports.stateMapConnect = stateMapConnect;
exports.useConantState = useConantState;
exports.useContextConantState = useContextConantState;
exports.useFlow = useFlow;
exports.useFlowStatus = useFlowStatus;
