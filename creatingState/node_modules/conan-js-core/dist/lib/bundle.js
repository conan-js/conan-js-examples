'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var __ = require('..');

class DynamicOrStatics {
    static result(dynamicOrStatic, basedOn) {
        return ((typeof dynamicOrStatic === 'function') ? dynamicOrStatic(basedOn) : dynamicOrStatic);
    }
}

class Strings {
    static firstCharToLowerCase(from) {
        return from.substring(0, 1).toLowerCase() + from.substring(1, from.length);
    }
    static firstCharToUpperCase(from) {
        return from.substring(0, 1).toUpperCase() + from.substring(1, from.length);
    }
    static camelCaseWithPrefix(prefix, from) {
        return prefix + this.firstCharToUpperCase(from);
    }
    static repeat(s, repeats) {
        let result = '';
        for (let i = 0; i < repeats; i++) {
            result += s;
        }
        return result;
    }
    static padEnd(s, positions) {
        if (s == null)
            return s;
        let toAdd = positions - s.length;
        if (toAdd < 1) {
            let middle = '...';
            let toRemove = s.length + middle.length - positions;
            let leftInsertionPoint = 1;
            let rightInsertionPoint = leftInsertionPoint + toRemove;
            return s.substring(0, leftInsertionPoint) + middle + s.substring(rightInsertionPoint, s.length);
        }
        else {
            return s + " ".repeat(toAdd);
        }
    }
}

class DiUtils {
    static beanName(from) {
        return Strings.firstCharToLowerCase(from.name);
    }
}

var InjectableType;
(function (InjectableType) {
    InjectableType["DYNAMIC"] = "dynamic";
    InjectableType["NAME"] = "name";
    InjectableType["TYPE"] = "type";
})(InjectableType || (InjectableType = {}));

class MetadataCrudUtils {
    constructor(spaceName, defaultProvider) {
        this.spaceName = spaceName;
        this.defaultProvider = defaultProvider;
    }
    updateMetadata(constructor, updater) {
        let current = this.getOrCreateMetadata(constructor);
        if (current == null)
            throw Error(`can't get or create metaData`);
        updater(current);
        return current;
    }
    assignMetaDataToConstructor(constructor, metaData) {
        let annotationsMetadataBySpaceAndPrototypeHolder = this.getPrototype(constructor);
        if (annotationsMetadataBySpaceAndPrototypeHolder.$a == null) {
            annotationsMetadataBySpaceAndPrototypeHolder.$a = {};
        }
        if (annotationsMetadataBySpaceAndPrototypeHolder.$a[this.spaceName] == null) {
            annotationsMetadataBySpaceAndPrototypeHolder.$a[this.spaceName] = {};
        }
        let name = MetadataCrudUtils.extractName(constructor);
        annotationsMetadataBySpaceAndPrototypeHolder.$a[this.spaceName][name] = metaData;
    }
    getAnnotationsMetaData(constructorOrInstance) {
        let annotationsMetadataBySpaceAndPrototypeHolder = constructorOrInstance;
        if (!annotationsMetadataBySpaceAndPrototypeHolder.$a) {
            annotationsMetadataBySpaceAndPrototypeHolder = this.getPrototype(constructorOrInstance);
        }
        let annotationsMetadataBySpaceAndPrototype = annotationsMetadataBySpaceAndPrototypeHolder.$a;
        if (annotationsMetadataBySpaceAndPrototype == null) {
            return null;
        }
        let annotationsMetadataByPrototype = annotationsMetadataBySpaceAndPrototype[this.spaceName];
        if (annotationsMetadataByPrototype == null) {
            return null;
        }
        let name = MetadataCrudUtils.extractName(constructorOrInstance);
        return annotationsMetadataByPrototype[name];
    }
    getOrCreateMetadata(constructor) {
        if (this.getAnnotationsMetaData(constructor) == null) {
            let metadata = this.defaultProvider();
            this.assignMetaDataToConstructor(constructor, metadata);
        }
        return this.getAnnotationsMetaData(constructor);
    }
    getPrototype(constructor) {
        if (typeof constructor === 'object') {
            return constructor;
        }
        if (typeof constructor.prototype === 'object') {
            return constructor.prototype;
        }
        return this.getPrototype(Object.getPrototypeOf(constructor));
    }
    static extractName(constructor) {
        let rawName = constructor.name;
        if (rawName == null) {
            rawName = constructor.constructor.name;
        }
        return rawName.substring(0, 1).toLowerCase() + rawName.substring(1, rawName.length);
    }
}

let diAnnotationsCrud = new MetadataCrudUtils('$di', () => ({
    diAnnotations: []
}));
function InjectByType(constructor, propsProvider) {
    return (classConstructor, keyOfParam_alwaysIgnore, index) => {
        diAnnotationsCrud.updateMetadata(classConstructor, (current) => current.diAnnotations.push({
            onConstructorParamIndex: index,
            injectable: constructor,
            type: InjectableType.TYPE,
            cascadeProperties: propsProvider
        }));
    };
}
function InjectDynamic(constructorProvider, propsProvider) {
    return (classConstructor, keyOfParam_alwaysIgnore, index) => {
        diAnnotationsCrud.updateMetadata(classConstructor, (current) => current.diAnnotations.push({
            onConstructorParamIndex: index,
            injectable: constructorProvider,
            type: InjectableType.DYNAMIC,
            cascadeProperties: propsProvider
        }));
    };
}
function InjectByName(name, propsProvider) {
    console.log('Inject by name', name);
    return (classConstructor, keyOfParam_alwaysIgnore, index) => {
        diAnnotationsCrud.updateMetadata(classConstructor, (current) => current.diAnnotations.push({
            onConstructorParamIndex: index,
            injectable: name,
            type: InjectableType.NAME,
            cascadeProperties: propsProvider
        }));
    };
}

const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;
class Functions {
    static extractArgNames(func) {
        if (func.length === 0)
            return [];
        let fnStr = func.toString().replace(STRIP_COMMENTS, '');
        let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
        if (result === null)
            result = [];
        return result;
    }
}

class DiAnnotationsMetadataFactory {
    create(from) {
        let dependencyName = DiUtils.beanName(from);
        let argumentNames = Functions.extractArgNames(from);
        let diParams = {};
        let annotationsMetaData = diAnnotationsCrud.getAnnotationsMetaData(from);
        if (annotationsMetaData) {
            annotationsMetaData.diAnnotations.forEach(it => {
                let argumentName = argumentNames[it.onConstructorParamIndex];
                diParams[argumentName] = {
                    name: argumentName,
                    type: it.type,
                    payload: it.injectable,
                    propsProvider: it.cascadeProperties
                };
            });
        }
        return {
            dependencyName: dependencyName,
            argumentNames: argumentNames,
            diParams: diParams,
            constructor: from
        };
    }
}

class DiRuntime {
    constructor(diInvocationResolver, diInvocationBuilderFactory) {
        this.diInvocationResolver = diInvocationResolver;
        this.diInvocationBuilderFactory = diInvocationBuilderFactory;
    }
    invoke(from, transitiveBeans, context) {
        if (typeof from === "object")
            return from;
        let invocation = this.diInvocationBuilderFactory.root(from)
            .if(transitiveBeans != null, it => it.withTransitiveBeans(transitiveBeans))
            .build();
        let result = this.diInvocationResolver.resolve(invocation, context, this).result;
        if (result == null)
            throw Error(`Can't invoke`);
        return result;
    }
    invokeWithProps(from, props, transitiveBeans, context) {
        let invocation = this.diInvocationBuilderFactory.root(from)
            .withProperties(props)
            .if(transitiveBeans != null, it => it.withTransitiveBeans(transitiveBeans))
            .build();
        let result = this.diInvocationResolver.resolve(invocation, context, this).result;
        if (result == null)
            throw Error(`Can't invoke`);
        return result;
    }
}
DiRuntime.PROPS_PROPERTY_NAME = '$props';

class DiInvocationResolver {
    constructor(diInvocationFactory, diCache, diEnricher) {
        this.diInvocationFactory = diInvocationFactory;
        this.diCache = diCache;
        this.diEnricher = diEnricher;
    }
    resolve(invocation, context, diRuntime) {
        if (this.causesCircularDependency(invocation)) {
            return {
                circularDependencyEndOf: invocation.diMetadata.dependencyName,
                result: null,
                pendingDependencies: {}
            };
        }
        // @ts-ignore
        let freshInvocationResult = null;
        let bean = this.diCache.resolve(invocation.diMetadata.dependencyName, () => {
            freshInvocationResult = this.doCreate(invocation, context, diRuntime);
            if (this.diEnricher) {
                freshInvocationResult.result = this.diEnricher(invocation.diMetadata, freshInvocationResult.result);
            }
            if (Object.keys(freshInvocationResult.pendingDependencies).indexOf(invocation.diMetadata.dependencyName) > -1) {
                freshInvocationResult.pendingDependencies[invocation.diMetadata.dependencyName].forEach(childDependency => {
                    this.diCache.resolve(childDependency, null)[invocation.diMetadata.dependencyName] = freshInvocationResult.result;
                });
            }
            return freshInvocationResult.result;
        });
        return freshInvocationResult == null ? {
            result: bean,
            pendingDependencies: {}
        } : freshInvocationResult;
    }
    causesCircularDependency(invocation) {
        return invocation.inProcessDiInvocations.indexOf(invocation.diMetadata.dependencyName) > -1;
    }
    doCreate(invocation, context, diRuntime) {
        const useConstructorOrFn = (invocation, params) => {
            let constructor = invocation.diMetadata.constructor;
            if (!!constructor.prototype && !!constructor.prototype.constructor.name) {
                return params ? new constructor(...params) : new constructor();
            }
            else {
                return params ? constructor(...params) : constructor();
            }
        };
        if (invocation.diMetadata.argumentNames.length === 0) {
            let result = useConstructorOrFn(invocation, undefined);
            return {
                result: result,
                pendingDependencies: {}
            };
        }
        let childrenInvocationResults = this.invokeChildren(invocation, context, diRuntime);
        let params = [];
        let startsCircularDependencies = {};
        childrenInvocationResults.forEach(child => {
            params.push(child.result);
            if (child.circularDependencyEndOf != null) {
                DiInvocationResolver.addValueToKeyValuePairs(startsCircularDependencies, child.circularDependencyEndOf, invocation.diMetadata.dependencyName);
            }
            if (child.pendingDependencies) {
                Object.keys(child.pendingDependencies).forEach(key => {
                    DiInvocationResolver.addValuesToKeyValuePairs(startsCircularDependencies, key, child.pendingDependencies[key]);
                });
            }
        });
        return {
            result: useConstructorOrFn(invocation, params),
            pendingDependencies: startsCircularDependencies
        };
    }
    static addValueToKeyValuePairs(keyValuePairs, key, value) {
        if (!keyValuePairs[key]) {
            keyValuePairs[key] = [];
        }
        if (keyValuePairs[key].indexOf(value) > -1)
            return;
        keyValuePairs[key].push(value);
    }
    static addValuesToKeyValuePairs(keyValuePairs, key, values) {
        if (!keyValuePairs[key]) {
            keyValuePairs[key] = values;
            return;
        }
        values.forEach(value => DiInvocationResolver.addValueToKeyValuePairs(keyValuePairs, key, value));
    }
    invokeChildren(invocation, context, diRuntime) {
        let params = [];
        invocation
            .diMetadata
            .argumentNames
            .forEach(argumentName => {
            let resolvedParam = this.resolveParamDef(invocation, argumentName);
            params.push(this.invokeChild(invocation, resolvedParam, context, diRuntime));
        });
        return params;
    }
    resolveParamDef(invocation, argumentName) {
        let fromAnnotation = invocation.diMetadata.diParams[argumentName];
        if (fromAnnotation == null) {
            return {
                name: argumentName,
                propsProvider: null,
                payload: argumentName,
                type: InjectableType.NAME
            };
        }
        return fromAnnotation;
    }
    invokeChild(invocation, resolvedParam, context, diRuntime) {
        if (resolvedParam.name === DiRuntime.PROPS_PROPERTY_NAME) {
            return this.resolveChildProps(invocation);
        }
        if (resolvedParam.type === InjectableType.TYPE) {
            return this.resolveChildByType(invocation, resolvedParam, context, diRuntime);
        }
        if (resolvedParam.type === InjectableType.DYNAMIC) {
            return this.resolveDynamicChild(invocation, resolvedParam, context, diRuntime);
        }
        return this.resolveChildByName(invocation, resolvedParam, context, diRuntime);
    }
    resolveChildProps(invocation) {
        if (invocation.properties == null) {
            throw Error(`can't resolve properties for $props - There are no properties passed to the beanRuntime`);
        }
        return {
            result: invocation.properties,
            pendingDependencies: {}
        };
    }
    resolveChildByType(invocation, childParamMetadata, context, diRuntime) {
        return this.resolve(this.diInvocationFactory.childrenOf(invocation, childParamMetadata.payload, childParamMetadata.propsProvider), context, diRuntime);
    }
    resolveDynamicChild(invocation, resolvedParam, context, diRuntime) {
        return this.resolveChildByType(invocation, {
            payload: resolvedParam.payload(),
            type: InjectableType.TYPE,
            propsProvider: resolvedParam.propsProvider,
            name: resolvedParam.name
        }, context, diRuntime);
    }
    resolveChildByName(invocation, resolvedParam, context, diRuntime) {
        let nameToResolve = resolvedParam.payload;
        if (invocation.transitiveBeans == null || invocation.transitiveBeans[nameToResolve] == null) {
            if (context[nameToResolve] != null) {
                let byName = diRuntime.invoke(context[nameToResolve], invocation.transitiveBeans, context);
                return {
                    result: byName,
                    pendingDependencies: {}
                };
            }
            else {
                throw Error(`can't resolve param '${nameToResolve}' - There are no transitive beans passed into the runtime`);
            }
        }
        return {
            result: invocation.transitiveBeans[nameToResolve],
            pendingDependencies: {}
        };
    }
}

class DiInvocationBuilderFactory {
    constructor(diAnnotationsMetadataFactory) {
        this.diAnnotationsMetadataFactory = diAnnotationsMetadataFactory;
    }
    childrenOf(parent, from, propsProvider) {
        let newBranch = parent.inProcessDiInvocations.slice(0);
        newBranch.push(parent.diMetadata.dependencyName);
        return new DiInvocationBuilder(this.diAnnotationsMetadataFactory, from)
            .withInProcessDiInvocations(newBranch)
            .withTransitiveBeans(parent.transitiveBeans)
            // @ts-ignore
            .if(propsProvider != null, (it) => it.withProperties(propsProvider()));
    }
    root(from) {
        return new DiInvocationBuilder(this.diAnnotationsMetadataFactory, from);
    }
}
class DiInvocationFactory {
    constructor(diInvocationBuilderFactory) {
        this.diInvocationBuilderFactory = diInvocationBuilderFactory;
    }
    childrenOf(parent, from, propsProvider) {
        return this.diInvocationBuilderFactory.childrenOf(parent, from, propsProvider).build();
    }
}
class DiInvocationBuilder {
    constructor(diAnnotationsMetadataFactory, _constructor) {
        this.diAnnotationsMetadataFactory = diAnnotationsMetadataFactory;
        this._constructor = _constructor;
        this.inProcessDiInvocations = [];
        this.transitiveBeans = {};
        this.properties = null;
    }
    if(condition, cb) {
        if (condition) {
            cb(this);
        }
        return this;
    }
    withInProcessDiInvocations(inProcessDiInvocations) {
        this.inProcessDiInvocations = inProcessDiInvocations;
        return this;
    }
    withTransitiveBeans(transitiveBeans) {
        this.transitiveBeans = transitiveBeans;
        return this;
    }
    withProperties(properties) {
        this.properties = properties;
        return this;
    }
    build() {
        return {
            diMetadata: this.diAnnotationsMetadataFactory.create(this._constructor),
            inProcessDiInvocations: this.inProcessDiInvocations,
            transitiveBeans: this.transitiveBeans,
            properties: this.properties
        };
    }
}

class KeyValueCache {
    constructor() {
        this.cache = {};
    }
    resolve(key, producer) {
        if (this.cache[key]) {
            return this.cache[key];
        }
        if (producer == null)
            throw Error(`Can't resolve cache`);
        let bean = producer();
        this.cache[key] = bean;
        return bean;
    }
}

class DiRuntimeFactory {
    static create(diReducer) {
        return new DiRuntime(DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER(new KeyValueCache(), diReducer ? diReducer : null), DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY);
    }
}
DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY = new DiInvocationBuilderFactory(new DiAnnotationsMetadataFactory());
DiRuntimeFactory.cacheTBR = () => new KeyValueCache();
DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER = (cache, diReducer) => new DiInvocationResolver(new DiInvocationFactory(DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY), DiRuntimeFactory.cacheTBR(), diReducer);

class DiContextFactory {
    static createContext(contextDef, aux) {
        let diRuntime = DiRuntimeFactory.create();
        let from = Object.assign(Object.assign({}, contextDef), aux);
        let keys;
        if (aux) {
            keys = [...Object.keys(contextDef), ...Object.keys(aux)];
        }
        else {
            keys = Object.keys(contextDef);
        }
        let result = {};
        let context = Object.assign(Object.assign({}, contextDef), aux);
        (keys).forEach(key => {
            let constr = from[key];
            result[key] = diRuntime.invoke(constr, result, context);
        });
        return result;
    }
}

(function (MonitorStatus) {
    MonitorStatus["IDLE"] = "IDLE";
    MonitorStatus["ASYNC_START"] = "ASYNC_START";
    MonitorStatus["ASYNC_FULFILLED"] = "ASYNC_FULFILLED";
    MonitorStatus["ASYNC_CANCELLED"] = "ASYNC_CANCELLED";
})(exports.MonitorStatus || (exports.MonitorStatus = {}));

const ReactStateContext = React.createContext(null);
class StateMapConnect extends React.Component {
    constructor(props) {
        super(props);
        this._isMounted = false;
        this.lastMonitorInfo = undefined;
        this.lastState = undefined;
        let needsDefault = true;
        let name = this.props.into.prototype ? this.props.into.prototype : this.props.into.name;
        this._mainDataReactionLock = this.props.from.addDataReaction({
            name: `connect | ${name}`,
            dataConsumer: (data) => {
                this.lastState = data;
                let lastProps = this.props.mapper(data, Object.assign({}, this.props.from.actions), this.lastMonitorInfo);
                if (this._isMounted) {
                    this.setState(lastProps);
                }
                else {
                    needsDefault = false;
                    this.state = lastProps;
                }
            },
        });
        this._asyncDataReactionLock = this.props.from.addAsyncReaction({
            name: `connect monitor| ${name}`,
            dataConsumer: (monitorInfo) => {
                this.lastMonitorInfo = monitorInfo;
                let lastProps = this.props.mapper(this.lastState, Object.assign({}, this.props.from.actions), monitorInfo);
                if (this._isMounted) {
                    this.setState(lastProps);
                }
                else {
                    needsDefault = false;
                    this.state = lastProps;
                }
            }
        });
        if (needsDefault && this.props.fallbackValue) {
            this.state = this.props.fallbackValue(this.props.from.actions);
        }
    }
    componentDidMount() {
        this._isMounted = true;
    }
    componentWillUnmount() {
        this._isMounted = false;
        this._mainDataReactionLock.release();
        if (this._asyncDataReactionLock) {
            this._asyncDataReactionLock.release();
        }
    }
    render() {
        let Comp = this.props.into;
        return (React.createElement(ReactStateContext.Provider, { value: this.props.from },
            React.createElement(Comp, Object.assign({}, this.state))));
    }
}
const StateConnect = (props) => {
    return (React.createElement(StateMapConnect, { mapper: (data, actions, monitorInfo) => ({ data, actions, monitorInfo }), into: props.into, from: props.from, fallbackValue: (actions) => ({
            data: props.fallbackValue,
            actions,
            monitorInfo: {
                status: exports.MonitorStatus.IDLE
            }
        }) }));
};
const stateConnect = (from, into, fallbackValue) => {
    return React.createElement(StateConnect, { from: from, into: into, fallbackValue: fallbackValue });
};
const stateMapConnect = (from, into, mapper, fallbackValue) => {
    return React.createElement(StateMapConnect, { from: from, into: into, fallbackValue: fallbackValue, mapper: mapper });
};

function useFlow(flow, setState, mapper) {
    React.useEffect(() => {
        flow.reactOnStatusChanged(status => {
            setState((previousUserState) => {
                return mapper ? mapper(status, previousUserState) : status.name;
            });
        });
    }, []);
}
function useFlowStatus(flow, status, setState, mapper) {
    React.useEffect(() => {
        flow.alwaysOn(status, context => {
            setState(previousState => {
                return mapper ? mapper(context.getData(), previousState) : context.getData();
            });
        });
    }, []);
}
function useConanState(state, fallbackValue) {
    let lastData = state.getData();
    const [compState, compStateSetter] = React.useState(lastData == null ? fallbackValue : lastData);
    React.useEffect(() => {
        const lock = state.addDataReaction({
            dataConsumer: compStateSetter,
            name: `useConanState[${state.getName()}]`
        });
        return () => lock.release();
    }, []);
    return [compState, state.actions, ({ children }) => {
            return React.createElement(ReactStateContext.Provider, { value: state }, children);
        }];
}
function useContextConanState() {
    const state$ = React.useContext(ReactStateContext);
    let result = useConanState(state$);
    return [result[0], result[1]];
}

class ContextStateMapConnect extends React.Component {
    render() {
        return React.createElement(ReactStateContext.Consumer, null, (reactThread) => {
            if (reactThread == null) {
                throw new Error(`trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?`);
            }
            return React.createElement(StateMapConnect, { from: reactThread, into: this.props.into, mapper: this.props.mapper, fallbackValue: this.props.fallbackValue });
        });
    }
}
class ContextStateConnect extends React.Component {
    render() {
        return React.createElement(ReactStateContext.Consumer, null, (reactThread) => {
            if (reactThread == null) {
                throw new Error(`trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?`);
            }
            return React.createElement(StateConnect, { from: reactThread, into: this.props.into, fallbackValue: this.props.fallbackValue });
        });
    }
}
const contextStateConnect = (into, fallbackValue) => {
    return React.createElement(ContextStateConnect, { into: into, fallbackValue: fallbackValue });
};
const contextStateMapConnect = (into, mapper, fallbackValue) => {
    return React.createElement(ContextStateMapConnect, { into: into, fallbackValue: fallbackValue, mapper: mapper });
};

const ContextStateLive = (props) => {
    const LiveRenderer = (propsLive) => {
        return props.renderer(propsLive.data, propsLive.actions);
    };
    return (React.createElement(ContextStateConnect, { into: LiveRenderer, fallbackValue: props.fallbackValue }));
};
const StateLive = (props) => {
    const LiveRenderer = (propsLive) => {
        let result = props.renderer(propsLive.data, propsLive.actions);
        return Array.isArray(result) ? (React.createElement(React.Fragment, null, result)) : result;
    };
    return (React.createElement(StateConnect, { from: props.from, into: LiveRenderer, fallbackValue: props.fallbackValue }));
};
const contextStateLive = (renderer, fallbackValue) => {
    const LiveRenderer = (props) => {
        let result = renderer(props.data, props.actions);
        return Array.isArray(result) ? (React.createElement(React.Fragment, null, result)) : result;
    };
    return React.createElement(ContextStateConnect, { into: LiveRenderer, fallbackValue: fallbackValue });
};
const stateLive = (from, renderer, fallbackValue) => {
    const LiveRenderer = (props) => {
        let result = renderer(props.data, props.actions);
        return Array.isArray(result) ? (React.createElement(React.Fragment, null, result)) : result;
    };
    return React.createElement(StateConnect, { from: from, into: LiveRenderer, fallbackValue: fallbackValue });
};

class Objects {
    static mapKeys(from, valueMapper, keyMapper) {
        let result = {};
        Object.keys(from).forEach(key => {
            let newKey = keyMapper ? keyMapper(key) : key;
            result[newKey] = valueMapper(from[key]);
        });
        return result;
    }
    static foreachEntry(from, cb) {
        Object.keys(from).forEach(key => {
            cb(from[key], key);
        });
    }
    static keyfy(from, keyProvider) {
        return from.reduce((acc, it) => {
            return Object.assign(Object.assign({}, acc), { [keyProvider(it)]: it });
        }, {});
    }
    static navigate(from, iterator) {
        let result = [];
        let next = from;
        while (next) {
            next = iterator(next);
            if (next !== null) {
                result.push(next);
            }
        }
        return result;
    }
    static deepEqualsArrays(left, right) {
        if (left.length !== right.length)
            return false;
        for (let leftItem of left) {
            if (right.indexOf(leftItem) === -1)
                return false;
        }
        return true;
    }
    static deepEqualsObjects(left, right) {
        for (let key of Object.keys(left)) {
            if (!Objects.deepEquals(left[key], right[key])) {
                return false;
            }
        }
        return true;
    }
    static deepEquals(left, right) {
        if ((left == null) && (right == null))
            return true;
        if ((left == null) && (right != null))
            return false;
        if ((left != null) && (right == null))
            return false;
        if ((typeof left === "string") && (typeof right === "string"))
            return left === right;
        if ((typeof left === "number") && (typeof right === "number"))
            return left === right;
        if ((typeof left === "function") && (typeof right === "function"))
            return left === right;
        if ((typeof left === "boolean") && (typeof right === "boolean"))
            return left === right;
        if ((typeof left === "undefined") && (typeof right === "undefined"))
            return left === right;
        if (Array.isArray(left) && (Array.isArray(right)))
            return Objects.deepEqualsArrays(left, right);
        if (Array.isArray(left) && (!Array.isArray(right)))
            return false;
        if (!Array.isArray(left) && (Array.isArray(right)))
            return false;
        if ((typeof left === "object") && (typeof right === "object"))
            return Objects.deepEqualsObjects(left, right);
        return left === right;
    }
}

var ReactionType;
(function (ReactionType) {
    ReactionType["ONCE"] = "ONCE";
    ReactionType["ALWAYS"] = "ALWAYS";
})(ReactionType || (ReactionType = {}));

class ThreadImpl {
    constructor(flow, def) {
        this.flow = flow;
        this.def = def;
    }
    start(initialData) {
        this.flow.start(initialData ? { name: 'nextData', data: initialData } : undefined);
        return this;
    }
    next(cb) {
        this.flow.onceOn("nextData", cb);
    }
    stop(eventsConsumer) {
        this.flow.stop(eventsConsumer);
    }
    chain(mutatorsCb, name) {
        return this.flow.chainInto('nextData', 'nextData', mutatorsCb, name).map(context => context.getData());
    }
    monitor(toMonitor, thenCallback, name, payload) {
        let mutatorsCbAsap = toMonitor.map(data => reducers => thenCallback(data, reducers));
        let defer = {
            payload: payload,
            name: name == null ? 'anonymous' : name,
            action: mutatorsCbAsap
        };
        return this.flow.deferInto('nextData', 'nextData', defer).map(context => context.getData());
    }
    get isRunning() {
        return this.flow.isRunning;
    }
    get reducers() {
        return this.flow.on('nextData').steps;
    }
    addReaction(def) {
        let reactionDef = {
            name: def.name,
            reactionType: ReactionType.ALWAYS,
            action: oNextData => def.dataConsumer(oNextData.getData()),
        };
        this.flow.addReaction('nextData', reactionDef);
        return {
            release: () => {
                this.flow.removeReaction('nextData', reactionDef);
            }
        };
    }
    getData() {
        return this.flow.getStatusData()['nextData'];
    }
    getEvents() {
        return this.flow.getEvents();
    }
    getName() {
        return this.flow.getName();
    }
    changeLoggingNature(nature) {
        this.flow.changeLoggingNature(nature);
    }
    log(msg) {
        this.flow.log(msg);
    }
    once(reaction, name) {
        this.flow.onceOn('nextData', onNextData => reaction(onNextData.getData()), name);
        return this;
    }
    createRuntimeTracker(runtimeEvent, payload) {
        return this.flow.createRuntimeTracker(runtimeEvent, payload);
    }
    addReactionNext(def) {
        this.flow.addReactionNext(this.flow.on('nextData'), {
            name: def.name,
            reactionType: ReactionType.ALWAYS,
            action: (onNextData) => def.dataConsumer(onNextData.getData())
        });
        return this;
    }
    getDefinition() {
        return this.def;
    }
}

class StatusLikeParser {
    static parse(toParse) {
        if (typeof toParse === "string")
            return {
                name: toParse
            };
        return toParse;
    }
}

class FlowRequest {
    constructor(flowThread, id, status, isStep) {
        this.flowThread = flowThread;
        this.id = id;
        this.status = status;
        this.isStep = isStep;
        this.queuedReactions = [];
        this.queuedTransitions = [];
        this.queuedSteps = [];
        this.queuedStatuses = [];
        this.queuedStates = [];
        this.started = false;
        this.processingStatus = {
            id: this.id,
            status: this.status
        };
    }
    static statusRequest(smFlow, id, status, isStep) {
        return new FlowRequest(smFlow, id, status, isStep);
    }
    static transitionRequest(smFlow, id, transition, isStep) {
        return new FlowRequest(smFlow, id, StatusLikeParser.parse(transition.into), isStep);
    }
    start() {
        if (this.started) {
            throw new Error('unexpected');
        }
        this.started = true;
        this.flowThread.processStateAndReactions(this.processingStatus, this.isStep);
        this.flowThread.flagAsSettled(this.processingStatus, this.isStep);
        this.flowThread.onStateRequestCompleted(this, this.queuedReactions, this.queuedStatuses, this.queuedStates, this.queuedTransitions, this.queuedSteps);
    }
    queueStatus(state) {
        this.queuedStatuses.push(state);
    }
    queueTransition(transition) {
        this.queuedTransitions.push(transition);
        return this;
    }
    queueStep(transition) {
        this.queuedSteps.push(transition);
        return this;
    }
    queueState(status) {
        this.queuedStates.push(status);
    }
    queueReaction(eventName, reaction) {
        this.queuedReactions.push([eventName, reaction]);
    }
}

var FlowEventNature;
(function (FlowEventNature) {
    FlowEventNature["MAIN"] = "MAIN";
    FlowEventNature["META"] = "META";
    FlowEventNature["HELPER"] = "HELPER";
    FlowEventNature["ASYNC"] = "ASYNC";
    FlowEventNature["AUX"] = "AUX";
    FlowEventNature["ASAP"] = "ASAP";
})(FlowEventNature || (FlowEventNature = {}));
var FlowEventSource;
(function (FlowEventSource) {
    FlowEventSource["FLOW_CONTROLLER"] = "FLOW_CONTROLLER";
    FlowEventSource["FLOW_THREAD"] = "FLOW_THREAD";
    FlowEventSource["CONTEXT"] = "CONTEXT";
    FlowEventSource["USER_MSG"] = "USER_MSG";
    FlowEventSource["FLOW_FACTORY"] = "FLOW_FACTORY";
})(FlowEventSource || (FlowEventSource = {}));
var FlowEventLevel;
(function (FlowEventLevel) {
    FlowEventLevel["DEBUG"] = "DEBUG";
    FlowEventLevel["TRACE"] = "TRACE";
    FlowEventLevel["INFO"] = "INFO";
    FlowEventLevel["MILESTONE"] = "MILESTONE";
    FlowEventLevel["WARN"] = "WARN";
    FlowEventLevel["ERROR"] = "ERROR";
})(FlowEventLevel || (FlowEventLevel = {}));
var FlowEventTiming;
(function (FlowEventTiming) {
    FlowEventTiming["CONTINUE"] = "CONTINUE";
    FlowEventTiming["START"] = "START";
    FlowEventTiming["END"] = "END";
    FlowEventTiming["CANCEL"] = "CANCEL";
    FlowEventTiming["IN_PROCESS"] = "IN_PROCESS";
})(FlowEventTiming || (FlowEventTiming = {}));
var FlowEventType;
(function (FlowEventType) {
    FlowEventType["MONITORING"] = "MONITORING";
    FlowEventType["PROCESSING_REACTIONS"] = "PROCESSING_REACTIONS";
    FlowEventType["STARTING"] = "STARTING";
    FlowEventType["ONCE_ON"] = "ONCE_ON";
    FlowEventType["RUN_IF"] = "RUN_IF";
    FlowEventType["RUN"] = "RUN";
    FlowEventType["ADDING_REACTION"] = "ADDING_REACTION";
    FlowEventType["ERROR_USER_CODE"] = "ERROR_USER_CODE";
    FlowEventType["MONITOR_TRANSACTION"] = "MONITOR_TRANSACTION";
    FlowEventType["REQUESTING_STATUS"] = "REQUESTING_STATUS";
    FlowEventType["SETTLING_STATUS"] = "SETTLING_STATUS";
    FlowEventType["PROCESSING_STATUS"] = "PROCESSING_STATUS";
    FlowEventType["STATUS_REQUEST_COMPLETED"] = "STATUS_REQUEST_COMPLETED";
    FlowEventType["REQUESTING_TRANSITION"] = "REQUESTING_TRANSITION";
    FlowEventType["ROOT_REQUEST"] = "ROOT_REQUEST";
    FlowEventType["CREATING"] = "CREATING";
    FlowEventType["USER_REACTIONS"] = "USER_REACTIONS";
    FlowEventType["USER_CODE"] = "USER_CODE";
})(FlowEventType || (FlowEventType = {}));

class FlowThread {
    constructor(flowController, flowOrchestrator, flowEvents) {
        this.flowController = flowController;
        this.flowOrchestrator = flowOrchestrator;
        this.flowEvents = flowEvents;
        this.ids = {};
        this.requestStack = [];
    }
    requestStatus(statusLike, isStep) {
        let status = StatusLikeParser.parse(statusLike);
        let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowEventSource.FLOW_THREAD, FlowEventType.REQUESTING_STATUS, statusLike).start(`${status.name}`);
        this.assertValidStatus(status.name);
        if (this.currentRequest != null) {
            if (!isStep) {
                tracker.debug(`queueing status [${status.name}]`);
                this.currentRequest.queueStatus(status);
            }
            else {
                tracker.debug(`queueing state [${status.name}]`);
                this.currentRequest.queueState(status);
            }
            return;
        }
        let id = this.getNextId(status);
        this.currentRequest = FlowRequest.statusRequest(this, id + '', status, isStep);
        this.currentRequest.start();
        tracker.end();
    }
    requestTransition(transition, isStep) {
        let intoStatusName = StatusLikeParser.parse(transition.into).name;
        let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowEventSource.FLOW_THREAD, FlowEventType.REQUESTING_TRANSITION, transition).start(`${transition.transitionName}`);
        tracker.info(isStep ? 'step' : 'transition', [transition.transitionName, transition.payload]);
        this.assertValidStatus(intoStatusName);
        if (this.currentRequest != null) {
            if (!isStep) {
                tracker.debug(`queueing transition [${transition.transitionName}]`);
                this.currentRequest.queueTransition(transition);
            }
            else {
                tracker.debug(`queueing step [${transition.transitionName}]`);
                this.currentRequest.queueStep(transition);
            }
            return;
        }
        let id = this.getNextId(StatusLikeParser.parse(transition.into));
        this.currentRequest = FlowRequest.transitionRequest(this, id + '', transition, isStep);
        this.onTransitionRequested(transition, isStep);
        this.currentRequest.start();
        tracker.end();
    }
    requestStep(statusName, reducerName, payload, data) {
        this.assertValidStatus(statusName);
        let currentStatusName = this.getCurrentStatusName();
        if (currentStatusName !== statusName) {
            throw new Error(`car't request step on [${statusName}] as the current status is[${currentStatusName}]`);
        }
        this.requestTransition({
            transitionName: reducerName,
            payload,
            into: {
                name: statusName,
                data
            }
        }, true);
    }
    requestState(statusName, data) {
        this.assertValidStatus(statusName);
        let currentStatusName = this.getCurrentStatusName();
        if (currentStatusName !== statusName) {
            throw new Error(`car't request state on [${statusName}] as the current status is[${currentStatusName}]`);
        }
        this.requestStatus({
            name: statusName,
            data: data
        }, true);
    }
    tryToQueue(eventName, reaction) {
        if (this.currentRequest == null)
            return false;
        this.currentRequest.queueReaction(eventName, reaction);
        return true;
    }
    onTransitionRequested(transition, isStep) {
        this.flowEvents.addTransition(transition, isStep);
    }
    getNextId(status, preview = false) {
        if (this.ids[status.name] == null) {
            this.ids[status.name] = 0;
        }
        let nextId = this.ids[status.name] + 1;
        if (preview)
            return nextId;
        this.ids[status.name] = nextId;
        return this.ids[status.name];
    }
    processStateAndReactions(statusRequest, isStep) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowEventSource.FLOW_THREAD, FlowEventType.PROCESSING_STATUS).start(`${statusRequest.status.name}`);
        tracker.info(`processing status - ${statusRequest.status.name}`, this.flowController.flowDef.nature === FlowEventNature.MAIN ? statusRequest.status.data : undefined);
        this.flowEvents.addProcessingStatus(statusRequest, isStep);
        tracker.end();
        this.flowController.processReactions(statusRequest.status.name);
    }
    flagAsSettled(statusRequest, isStep) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowEventSource.FLOW_THREAD, FlowEventType.SETTLING_STATUS).start(`${statusRequest.status.name}`);
        this.flowEvents.settleProcessingStatus(statusRequest, isStep);
        let currentNature = this.flowController.flowDef.nature;
        let payload = currentNature !== FlowEventNature.ASYNC ? statusRequest.status.data : statusRequest.status.data ? statusRequest.status.data.status : undefined;
        if (!isStep) {
            tracker.milestone(`STATUS - ${statusRequest.status.name}`, payload);
        }
        else {
            tracker.milestone('STATE', payload);
        }
        tracker.end();
    }
    onStateRequestCompleted(stateMachineRequest, queuedReactions, queuedStatuses, queuedStates, queuedTransitions, queuedSteps) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowEventSource.FLOW_THREAD, FlowEventType.STATUS_REQUEST_COMPLETED).start(`${stateMachineRequest.status.name}`);
        let rootRequestTracker = this.flowOrchestrator.createRuntimeTracker(this.flowController, FlowEventSource.FLOW_THREAD, FlowEventType.ROOT_REQUEST);
        if (this.requestStack.length === 0) {
            rootRequestTracker.debug(`creating new execution stack: [${stateMachineRequest.status.name}]`);
            rootRequestTracker.start(`${stateMachineRequest.status.name}`);
        }
        else {
            rootRequestTracker.debug(`adding to current execution stack [${this.requestStack.length}-${this.requestStack[0].status.name}]`);
            rootRequestTracker.continue(`${stateMachineRequest.status.name}`);
        }
        if (this.currentRequest == null) {
            throw new Error(`can't complete the request for [${this.flowController.getName()} - ${stateMachineRequest.status.name}] as is not flagged as currently in process`);
        }
        if (this.currentRequest != stateMachineRequest) {
            throw new Error(`can't complete the request for [${this.flowController.getName()} - ${stateMachineRequest.status.name}] as it does not match [${this.currentRequest.status.name}]`);
        }
        if (queuedTransitions.length > 0 && queuedStatuses.length > 0) {
            throw new Error(`can't have transitions and states forked at the same time!`);
        }
        this.requestStack.push(this.currentRequest);
        this.currentRequest = undefined;
        if (queuedTransitions.length > 1 || queuedStatuses.length > 1) {
            throw new Error('TBI');
        }
        function logArray(name, queuedItems, mapper) {
            tracker.withLevel(queuedItems.length === 0 ? FlowEventLevel.DEBUG : FlowEventLevel.INFO, `executing ${name}: [(${queuedItems.length}) - ${queuedItems.map(mapper).join(',')}]`);
        }
        logArray('queued transitions', queuedTransitions, (it) => it.transitionName);
        queuedTransitions.forEach(it => this.flowController.requestTransition(it));
        logArray('queued statuses', queuedStatuses, (it) => it.name);
        queuedStatuses.forEach(it => this.flowController.requestStatus(it));
        logArray('queued states', queuedStates, (it) => it.name);
        queuedStates.forEach(it => this.flowController.requestState(it.name, it.data));
        logArray('queued steps', queuedSteps, (it) => it.transitionName);
        queuedSteps.forEach(it => {
            let into = StatusLikeParser.parse(it.into);
            this.flowController.requestStep(into.name, it.transitionName, it.payload, into.data);
        });
        logArray('queued reactions', queuedReactions, (it) => it[1].name);
        queuedReactions.forEach(it => this.flowController.addReaction(it[0], it[1]));
        this.requestStack.pop();
        if (this.requestStack.length === 0) {
            rootRequestTracker.debug(`execution stack completed: [${stateMachineRequest.status.name}]`);
            rootRequestTracker.end();
        }
        tracker.end();
    }
    createContext(statusLike, doChain) {
        let status = StatusLikeParser.parse(statusLike);
        return {
            getData: this.flowController.getState.bind(this.flowController),
            getStatusData: this.flowController.getStatusData.bind(this.flowController),
            do: Object.assign(Object.assign({}, this.flowController.on(status.name).transitions), this.flowController.on(status.name).steps),
            chain(cb) {
                doChain(cb);
            },
            interruptFlow: () => {
                this.flowController.stop();
            },
            log: (msg) => {
                return this.flowController.log(msg);
            }
        };
    }
    getCurrentStatusName() {
        let currentStatus = this.flowEvents.currentStatus;
        return currentStatus == null ? undefined : currentStatus.name;
    }
    getCurrentState() {
        let currentStatus = this.flowEvents.currentStatus;
        return currentStatus == null ? undefined : currentStatus.data;
    }
    assertValidStatus(statusName) {
        if (this.flowController.on(statusName) == null) {
            throw new Error(`error requesting a transition into [${statusName}] unknown status, valid statuses are: [${Object.keys(this.flowController.getStatusDefs()).join(', ')}]`);
        }
    }
}

var StatusEventType;
(function (StatusEventType) {
    StatusEventType["TRANSITION"] = "TRANSITION";
    StatusEventType["STEP"] = "STEP";
    StatusEventType["STATUS"] = "STATUS";
    StatusEventType["PROCESSING_STATUS"] = "PROCESSING_STATUS";
    StatusEventType["STATE"] = "STATE";
    StatusEventType["PROCESSING_STATE"] = "PROCESSING_STATE";
})(StatusEventType || (StatusEventType = {}));

class FlowEventsTracker {
    constructor() {
        this.eventsByStatus = {};
        this.events = [];
    }
    addTransition(transition, isStep) {
        let lastEvent;
        let intoStatus = StatusLikeParser.parse(transition.into);
        if (!isStep) {
            lastEvent = {
                type: StatusEventType.TRANSITION,
                fromStatus: this.currentStatus.name,
                intoStatus: intoStatus,
                transitionName: transition.transitionName,
                transitionPayload: transition.payload
            };
        }
        else {
            lastEvent = {
                type: StatusEventType.STEP,
                reducerName: transition.transitionName,
                newData: intoStatus.data,
                reducerPayload: transition.payload
            };
        }
        this.lastEvent = lastEvent;
        this.process(lastEvent);
    }
    addStateFromStatus(stateEvent) {
        this.lastEvent = stateEvent;
        this.process(stateEvent);
    }
    addProcessingStatus(statusRequest, isStep) {
        let lastEvent;
        if (!isStep) {
            lastEvent = {
                type: StatusEventType.PROCESSING_STATUS,
                status: statusRequest.status
            };
        }
        else {
            lastEvent = {
                type: StatusEventType.PROCESSING_STATE,
                data: statusRequest.status.data
            };
        }
        this.currentStatus = statusRequest.status;
        this.lastEvent = lastEvent;
        this.process(lastEvent);
    }
    settleProcessingStatus(statusRequest, isStep) {
        if (!isStep) {
            if (this.lastEvent.status !== statusRequest.status) {
                throw new Error(`unexpected error settling events`);
            }
            this.lastEvent.type = StatusEventType.STATUS;
            this.addStateFromStatus({
                data: statusRequest.status.data,
                type: StatusEventType.STATE
            });
        }
        else {
            if (this.lastEvent.data !== statusRequest.status.data) {
                throw new Error(`unexpected error settling events`);
            }
            this.lastEvent.type = StatusEventType.STATE;
            this.eventsByStatus[this.currentStatus.name].lastState = statusRequest.status.data;
        }
    }
    process(lastEvent) {
        if (this.eventsByStatus[this.currentStatus.name] == null) {
            this.eventsByStatus[this.currentStatus.name] = {
                allEvents: [],
                statusName: this.currentStatus.name,
                lastState: undefined
            };
        }
        let eventWithStatusInfo = {
            event: lastEvent,
            statusName: this.currentStatus.name
        };
        this.eventsByStatus[this.currentStatus.name].allEvents.push(eventWithStatusInfo);
        if (lastEvent.type === StatusEventType.STATE || lastEvent.type === StatusEventType.PROCESSING_STATE) {
            this.eventsByStatus[this.currentStatus.name].lastState = lastEvent.data;
        }
        this.events.push(eventWithStatusInfo);
    }
    serializeStatesWithStatus(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATE] }));
    }
    serializeStates(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATE] })).map(it => it.event);
    }
    serializeStatuses(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATUS] })).map(it => it.event);
    }
    serialize(filterOptions) {
        return this.serializeWithStatusInfo(filterOptions).map(it => it.event);
    }
    serializeWithStatusInfo(filterOptions) {
        if (!filterOptions) {
            return this.events;
        }
        let filtered = [];
        this.events.forEach(eventWithStatusInfo => {
            let toBeIncluded = true;
            if (!toBeIncluded)
                return;
            if (filterOptions.excludeInit) {
                if (this.eventsByStatus['$init'].allEvents.indexOf(eventWithStatusInfo) > -1) {
                    toBeIncluded = false;
                }
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.excludeStop) {
                if (this.eventsByStatus['$stop'] && this.eventsByStatus['$stop'].allEvents.indexOf(eventWithStatusInfo) > -1) {
                    toBeIncluded = false;
                }
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.statuses) {
                filterOptions.statuses.forEach(status => {
                    if (toBeIncluded)
                        return;
                    if (this.eventsByStatus[status].allEvents.indexOf(eventWithStatusInfo) === -1) {
                        toBeIncluded = false;
                    }
                });
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.eventTypes) {
                if (filterOptions.eventTypes.indexOf(eventWithStatusInfo.event.type) === -1) {
                    toBeIncluded = false;
                }
            }
            if (toBeIncluded) {
                filtered.push(eventWithStatusInfo);
            }
        });
        return filtered;
    }
    getLastStates() {
        let lastStates = {};
        Object.keys(this.eventsByStatus).forEach(statusKey => {
            lastStates[statusKey] = this.eventsByStatus[statusKey].lastState;
        });
        return lastStates;
    }
    getLastState(statusName) {
        let eventsByStatus = this.eventsByStatus[statusName];
        if (eventsByStatus == null)
            return undefined;
        return eventsByStatus.lastState;
    }
}

var BindBackType;
(function (BindBackType) {
    BindBackType["STEP"] = "STEP";
    BindBackType["TRANSITION"] = "TRANSITION";
})(BindBackType || (BindBackType = {}));
class FlowAnchor {
    createNewThread(flowController, flowOrchestrator) {
        let flowEvents = new FlowEventsTracker();
        let flowThread = new FlowThread(flowController, flowOrchestrator, flowEvents);
        this.currentThread = {
            flowEvents: flowEvents,
            flowThread: flowThread,
        };
        return flowThread;
    }
    getCurrentEvents() {
        return this.currentThread.flowEvents;
    }
    get currentStatus() {
        if (!this.currentThread)
            return undefined;
        return this.currentThread.flowEvents.currentStatus;
    }
    getStatusDataProducerFn() {
        return (statusNameOpt, defaultValue) => {
            let statusName = statusNameOpt != null ? statusNameOpt : this.currentStatus.name;
            let statusData = this.currentThread.flowEvents.getLastStates();
            if (Object.keys(statusData).indexOf(statusName) === -1) {
                return defaultValue;
            }
            return statusData[statusName];
        };
    }
    getDataFn(status) {
        return () => {
            if (this.currentThread == null) {
                throw new Error(`error getting the data function associated to this flow, this might happen if you try to mutate the state of the flow before it has been started.`);
            }
            let currentStatus = this.currentThread.flowEvents.currentStatus.name;
            if (currentStatus === '$init') {
                return undefined;
            }
            if (status !== currentStatus) {
                throw new Error(`unexpected error trying to retrieve the last status for [${status}, but the current status is [${currentStatus}]]`);
            }
            return this.currentThread.flowEvents.getLastState(status);
        };
    }
    bindBack(expectedStatusName, param, type) {
        if (!this.currentThread.flowThread.flowController.isRunning) {
            return;
        }
        let isNotGoingToStop = param.result && param.result.name != "$stop";
        let isNotCurrentlyOnInit = this.currentStatus && this.currentStatus.name != "$init";
        if (isNotGoingToStop && isNotCurrentlyOnInit && (!this.currentStatus || this.currentStatus.name !== expectedStatusName)) {
            throw Error(`unable to request [${param.methodName}] as is meant for status [${expectedStatusName}], but the current status is [${this.currentStatus ? this.currentStatus.name : '-'}]`);
        }
        if (type === BindBackType.STEP) {
            let initialStep = this.currentThread.flowThread.getCurrentStatusName() === '$init';
            if (initialStep) {
                this.currentThread.flowThread.requestTransition({
                    into: {
                        name: expectedStatusName,
                        data: param.result
                    },
                    payload: param.payload,
                    transitionName: param.methodName
                }, false);
            }
            else {
                this.currentThread.flowThread.requestStep(param.statusName, param.methodName, param.payload, param.result);
            }
        }
        else {
            this.currentThread.flowThread.requestTransition({
                into: param.result,
                payload: param.payload,
                transitionName: param.methodName
            }, false);
        }
    }
    getStatusData() {
        return this.currentThread.flowEvents.getLastStates();
    }
    createRuntimeTracker(runtimeEvent, payload) {
        let flowThread = this.currentThread.flowThread;
        let flowOrchestrator = flowThread.flowOrchestrator;
        return flowOrchestrator.createRuntimeTracker(flowThread.flowController, FlowEventSource.FLOW_CONTROLLER, runtimeEvent, payload);
    }
}

class Proxyfier {
    static proxy(from, enricher) {
        let proxy = {};
        let prototype = Object.getPrototypeOf(from);
        let methodHost = prototype.constructor.name === 'Object' ? from : prototype;
        let ownPropertyNames = Object.getOwnPropertyNames(methodHost);
        ownPropertyNames.forEach(key => {
            if (key === 'constructor')
                return;
            let toProxy = methodHost[key];
            if (typeof toProxy !== 'function')
                return;
            proxy[key] = (...payload) => {
                let originalCall = () => {
                    let originalResult = from[key](...payload);
                    return originalResult;
                };
                return enricher(originalCall, {
                    methodName: key,
                    payload
                });
            };
        });
        return proxy;
    }
}

class MutatorsFactory {
    static createDefaultStepsDef(flowAnchor) {
        return (getData) => ({
            $update(reducer) {
                let finalValue;
                let flowThread = flowAnchor.currentThread.flowThread;
                let tracker = flowThread.flowOrchestrator.createRuntimeTracker(flowThread.flowController, FlowEventSource.CONTEXT, FlowEventType.USER_CODE, finalValue).start();
                if (typeof reducer !== 'function') {
                    finalValue = reducer;
                }
                else {
                    finalValue = reducer(getData());
                }
                tracker.debug(`$update`, finalValue).end();
                return finalValue;
            }
        });
    }
    static createDefaultTransitionDef(flowAnchor) {
        return (() => ({
            $toStatus(toStatus) {
                let status = StatusLikeParser.parse(toStatus);
                let flowThread = flowAnchor.currentThread.flowThread;
                flowThread.flowOrchestrator.createRuntimeTracker(flowThread.flowController, FlowEventSource.CONTEXT, FlowEventType.USER_CODE, status).start().debug(`$toStatus`, status).end();
                return status;
            }
        }));
    }
    static createDefaultSteps(statusName, flowAnchor) {
        return this.createSteps(statusName, flowAnchor, this.createDefaultStepsDef(flowAnchor));
    }
    static createTransitions(statusName, flowAnchor, userTransitions) {
        let defaultTransitionDef = this.createDefaultTransitionDef(flowAnchor);
        return this.doCreateTransitions(statusName, flowAnchor, userTransitions ? [userTransitions, defaultTransitionDef] : [defaultTransitionDef]);
    }
    static createSteps(statusName, flowAnchor, userStepsDef) {
        let defaultStepDef = this.createDefaultStepsDef(flowAnchor);
        return this.doCreateSteps(statusName, flowAnchor, userStepsDef ? [userStepsDef, defaultStepDef] : [defaultStepDef]);
    }
    static doCreateSteps(statusName, flowAnchor, allStepsDef) {
        let dataProducerFn = flowAnchor.getDataFn(statusName);
        let allSteps = {};
        allStepsDef.forEach(it => {
            let thisStep = it(dataProducerFn);
            allSteps = Object.assign(Object.assign({}, allSteps), thisStep);
        });
        return this.bindToAnchor(statusName, flowAnchor, allSteps, BindBackType.STEP);
    }
    static doCreateTransitions(statusName, flowAnchor, allTransitionsDef) {
        let statusDataProducerFn = flowAnchor.getStatusDataProducerFn();
        let allTransitions = {};
        allTransitionsDef.forEach(it => {
            let thisTransitions = it(statusDataProducerFn);
            allTransitions = Object.assign(Object.assign({}, allTransitions), thisTransitions);
        });
        return this.bindToAnchor(statusName, flowAnchor, allTransitions, BindBackType.TRANSITION);
    }
    static bindToAnchor(expectedStatusName, flowAnchor, toBind, type) {
        return Proxyfier.proxy(toBind, (originalCall, metadata) => {
            let flowController = flowAnchor.currentThread.flowThread.flowController;
            let tracker = flowAnchor.currentThread.flowThread.flowOrchestrator.createRuntimeTracker(flowController, FlowEventSource.CONTEXT, FlowEventType.USER_REACTIONS, flowController.flowDef.nature).start();
            let isMainNature = flowController.flowDef.nature === FlowEventNature.MAIN;
            let level = isMainNature && metadata.methodName !== '$update' ? FlowEventLevel.MILESTONE : FlowEventLevel.DEBUG;
            tracker.withLevel(level, `calling: ${metadata.methodName}`, (typeof metadata.payload === "object" ? metadata.payload : '[reducer]'));
            try {
                let newState = originalCall();
                flowAnchor.bindBack(expectedStatusName, {
                    statusName: flowAnchor.currentStatus.name,
                    methodName: metadata.methodName,
                    payload: metadata.payload,
                    result: newState,
                }, type);
                tracker.end();
                return newState;
            }
            catch (e) {
                flowAnchor.createRuntimeTracker(FlowEventType.ERROR_USER_CODE, e).start().milestone(`error running ${metadata.methodName}`, e).end();
                return undefined;
            }
        });
    }
}

const $INIT = "$init";
const $STOP = "$stop";

class ReactionDefLikeParser {
    static parse(toParse, reactionType, defaultName) {
        if (typeof toParse === "object")
            return toParse;
        return {
            name: defaultName ? defaultName : 'anonymous',
            reactionType: reactionType,
            action: toParse
        };
    }
}

class FlowDefFactory {
    static create(userFlowDef, flowAnchor) {
        let statusesByStatusName = FlowDefFactory.statusesByName(userFlowDef.statuses, flowAnchor);
        statusesByStatusName[$INIT] = {
            name: $INIT,
            steps: MutatorsFactory.createDefaultSteps($INIT, flowAnchor),
            transitions: MutatorsFactory.createTransitions($INIT, flowAnchor),
            reactions: userFlowDef.$onInit ?
                userFlowDef.$onInit.map(it => (ReactionDefLikeParser.parse(it, ReactionType.ALWAYS, `on init`))) : [],
        };
        statusesByStatusName[$STOP] = {
            name: $STOP,
            steps: MutatorsFactory.createDefaultSteps($STOP, flowAnchor),
            transitions: MutatorsFactory.createTransitions($STOP, flowAnchor),
            reactions: userFlowDef.$onStop ?
                userFlowDef.$onStop.map(it => (ReactionDefLikeParser.parse(it, ReactionType.ALWAYS, `on stop`))) : [],
        };
        return Object.assign(Object.assign({ statusesByStatusName: statusesByStatusName, name: userFlowDef.name, nature: userFlowDef.nature ? userFlowDef.nature : FlowEventNature.MAIN }, userFlowDef.hasOwnProperty('initialStatus') ? { starter: () => userFlowDef.initialStatus } : undefined), userFlowDef.hasOwnProperty('loggingRule') ? { loggingRule: userFlowDef.loggingRule } : undefined);
    }
    static statusesByName(userStatusesDefLike, flowAnchor) {
        let statusesByName = {};
        if (Array.isArray(userStatusesDefLike)) {
            userStatusesDefLike.forEach(it => {
                statusesByName[it] = {
                    name: it,
                    steps: [],
                    reactions: [],
                };
            });
        }
        else {
            Objects.foreachEntry(userStatusesDefLike, (value, key) => {
                statusesByName[key] = {
                    name: key,
                    steps: MutatorsFactory.createSteps(key, flowAnchor, value.steps),
                    transitions: MutatorsFactory.createTransitions(key, flowAnchor, value.transitions),
                    reactions: value.reactions ?
                        value.reactions.map(it => ReactionDefLikeParser.parse(it, ReactionType.ALWAYS, `on[${key}]`)) :
                        [],
                    getLastData: flowAnchor.getDataFn(key)
                };
            });
        }
        return statusesByName;
    }
}

class FlowRuntimeTracker {
    constructor(orchestrator, event) {
        this.orchestrator = orchestrator;
        this.event = event;
    }
    end(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.END, shortDesc, payload);
    }
    cancel(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.CANCEL, shortDesc, payload);
    }
    continue(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.CONTINUE, shortDesc, payload);
    }
    start(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.START, shortDesc, payload);
    }
    debug(shortDesc, payload) {
        return this.doTick(FlowEventLevel.DEBUG, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    info(shortDesc, payload) {
        return this.doTick(FlowEventLevel.INFO, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    milestone(shortDesc, payload) {
        return this.doTick(FlowEventLevel.MILESTONE, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    withLevel(level, shortDesc, payload) {
        return this.doTick(level, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    fork(type, level, shortDesc, payload) {
        let forkedTracker = this.orchestrator.createRuntimeTracker(this.event.flowController, this.event.source, type, payload).start();
        forkedTracker.withLevel(level, shortDesc, payload);
        forkedTracker.end();
    }
    doTick(level, timing, shortDesc, payload, type) {
        let event = Object.assign(Object.assign(Object.assign(Object.assign({}, this.event), (type != null ? { type } : undefined)), { shortDesc,
            timing,
            level }), (payload != null ? { payload } : undefined));
        this.orchestrator.onRuntimeEvent(this, event);
        return this;
    }
}

class FlowOrchestrator {
    constructor(eventsProcessor) {
        this.eventsProcessor = eventsProcessor;
    }
    onRuntimeEvent(tracker, event) {
        this.eventsProcessor.forEach(it => it(event));
    }
    createRuntimeTracker(flowController, source, runtimeEvent, payload) {
        return new FlowRuntimeTracker(this, {
            flowController: flowController,
            source,
            type: runtimeEvent,
            payload,
            nature: flowController.flowDef.nature
        });
    }
}

class RuleLikeParser {
    static parse(toParse) {
        return RuleLikeParser.isRule(toParse) ? toParse : BaseRules.if('-anonymous-', toParse);
    }
    static isRule(toParse) {
        return 'test' in toParse;
    }
}
var RuleType;
(function (RuleType) {
    RuleType["COMBINED"] = "COMBINED";
    RuleType["SIMPLE"] = "SIMPLE";
})(RuleType || (RuleType = {}));
var LOGIC_OPERATOR;
(function (LOGIC_OPERATOR) {
    LOGIC_OPERATOR["OR"] = "OR";
    LOGIC_OPERATOR["AND"] = "AND";
})(LOGIC_OPERATOR || (LOGIC_OPERATOR = {}));
class BaseRule {
    constructor(negate = false, baseName) {
        this.negate = negate;
        this.baseName = baseName;
    }
    split(additionalRule) {
        return [
            this.and(additionalRule),
            this.and(additionalRule.inverse()),
        ];
    }
    test(value) {
        let result = this.doEvaluate(value);
        return this.negate === true ? !result : result;
    }
    or(rule) {
        return BaseRules.combineOr(`OR`, this, rule);
    }
    and(rule) {
        return BaseRules.combineAnd(`AND`, this, rule);
    }
    get name() {
        return `${this.negate === true ? '!' : ''}${this.baseName}`;
    }
}
class CombinedRule extends BaseRule {
    constructor(name, rules, operator, negate = false) {
        super(negate, name);
        this.rules = rules;
        this.operator = operator;
        this.ruleType = RuleType.COMBINED;
    }
    doEvaluate(value) {
        for (let rule of this.rules) {
            let partial = rule.test(value);
            if (partial === true && this.operator === LOGIC_OPERATOR.OR) {
                return true;
            }
            if (partial === false && this.operator === LOGIC_OPERATOR.AND) {
                return false;
            }
        }
        return this.operator === LOGIC_OPERATOR.AND;
    }
    inverse() {
        let newNegatedValue = !this.negate;
        return new CombinedRule(this.baseName, this.rules, this.operator, newNegatedValue);
    }
    get name() {
        return `${this.negate === true ? '!' : ''}${this.baseName}=[${this.rules.map(it => it.name).join(',')}]`;
    }
}
class SimpleRule extends BaseRule {
    constructor(name, predicate, negate = false) {
        super(negate, name);
        this.predicate = predicate;
        this.ruleType = RuleType.SIMPLE;
    }
    inverse() {
        let newNegatedValue = !this.negate;
        return new SimpleRule(this.baseName, this.predicate, newNegatedValue);
    }
    doEvaluate(value) {
        return this.predicate(value);
    }
}

class BasePredicates {
    static isUndefined() {
        return BasePredicates.compareByReference(undefined);
    }
    static isNull() {
        return BasePredicates.compareByReference(null);
    }
    static isNullUn() {
        return (value) => value == null;
    }
    static compareByReference(toCompareWith) {
        return (value) => value === toCompareWith;
    }
    static isInitialised() {
        return (value) => value != null;
    }
}
class BaseRules {
    static if(name, predicate) {
        return new SimpleRule(name, predicate);
    }
    static ifNot(name, predicate) {
        return new SimpleRule(name, predicate, true);
    }
    static ifUndefined() {
        return BaseRules.if('ifUndefined', BasePredicates.isUndefined());
    }
    static ifNull() {
        return BaseRules.if('ifNull', BasePredicates.isNull());
    }
    static ifNullUn() {
        return BaseRules.if('ifNullUn', BasePredicates.isNullUn());
    }
    static ifInitialised() {
        return BaseRules.if('ifInitialised', BasePredicates.isInitialised());
    }
    static compareByReference(name, toCompareWith) {
        return BaseRules.if(name, BasePredicates.compareByReference(toCompareWith));
    }
    static combineAnd(name, ...rules) {
        let rulesParsed = rules.map(RuleLikeParser.parse);
        return new CombinedRule(name, rulesParsed, LOGIC_OPERATOR.AND);
    }
    static combineOr(name, ...rules) {
        return new CombinedRule(name, rules.map(RuleLikeParser.parse), LOGIC_OPERATOR.OR);
    }
    static join(mapper, joiner) {
        return BaseRules.if(`join{${joiner.name}`, (value) => {
            let nextValue = mapper(value);
            return joiner.test(nextValue);
        });
    }
}

class FlowLogger {
    constructor(Rule$) {
        this.Rule$ = Rule$;
    }
    log(event) {
        if (!this.Rule$().test(event)) {
            let customRule = event.flowController.flowDef.loggingRule;
            if (customRule) {
                if (!customRule.test(event)) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        let currentStatusName = event.flowController.getCurrentStatusName();
        currentStatusName = currentStatusName ? currentStatusName : '<stopped>';
        if (event.payload != null) {
            console.log(Strings.padEnd(`${event.type}`, 30), Strings.padEnd(`${event.flowController.getName()}`, 50), Strings.padEnd(`${currentStatusName}`, 30), Strings.padEnd(`${event.nature}`, 10), Strings.padEnd(`${event.level}`, 10), Strings.padEnd(`${event.timing}`, 12));
            if (event.payload != null || event.shortDesc != null) {
                if (event.shortDesc != null && event.payload != null) {
                    console.log(`  =>${event.shortDesc}`);
                    console.log(' ', event.payload);
                }
                else if (event.shortDesc != null && !event.payload != null) {
                    console.log(`  =>${event.shortDesc}`);
                }
                else {
                    console.log(`  =>${event.payload}`);
                }
            }
            console.log('------------------------------------------------------------------------------------------------------------------------------------------------');
        }
        else if (event.shortDesc != null) {
            console.log(Strings.padEnd(`${event.type}`, 30), Strings.padEnd(`${event.flowController.getName()}`, 50), Strings.padEnd(`${currentStatusName}`, 30), Strings.padEnd(`${event.level}`, 10), Strings.padEnd(`${event.nature}`, 10), Strings.padEnd(`${event.timing}`, 10));
            console.log(`  =>${event.shortDesc}`);
        }
        return true;
    }
}
class LoggerFilters {
    static trace() {
        return BaseRules.if('ifTrace', (flowEvent) => flowEvent.level === FlowEventLevel.TRACE);
    }
    static debug() {
        return BaseRules.if('ifDebug', (flowEvent) => flowEvent.level === FlowEventLevel.DEBUG);
    }
    static milestone() {
        return BaseRules.if('ifMilestone', (flowEvent) => flowEvent.level === FlowEventLevel.MILESTONE);
    }
    static info() {
        return BaseRules.if('ifInfo', (flowEvent) => flowEvent.level === FlowEventLevel.INFO);
    }
    static logName(logName) {
        return BaseRules.combineOr(`main/async/meta[${logName}]`, LoggerFilters.mainLogName(logName), LoggerFilters.asyncLogName(logName), LoggerFilters.metaLogName(logName));
    }
    static mainLogName(logName) {
        return BaseRules.if(`ifLogName={${logName}`, (flowEvent) => flowEvent.flowController.getName() === logName);
    }
    static asyncLogName(logName) {
        return BaseRules.if(`ifLogName={${logName}`, (flowEvent) => flowEvent.flowController.getName() === `${logName}=>[async]`);
    }
    static metaLogName(logName) {
        return BaseRules.if(`ifLogName={${logName}`, (flowEvent) => flowEvent.flowController.getName() === `${logName}=>[meta]`);
    }
    static eventType(eventType) {
        return BaseRules.combineAnd(`eventType[${eventType}]`, LoggerFilters.trace().inverse(), BaseRules.if(`ifEventType={${eventType}`, (flowEvent) => flowEvent.type === eventType));
    }
    static statusName(statusName) {
        return BaseRules.if(`ifStatusName={${statusName}`, (flowEvent) => flowEvent.flowController.getCurrentStatusName() === statusName);
    }
    static notInitialising() {
        return LoggerFilters.initialising().inverse();
    }
    static initialising() {
        return LoggerFilters.statusName('$init');
    }
    static nextData() {
        return LoggerFilters.statusName('nextData');
    }
    static aux() {
        return BaseRules.if(`ifAux`, (flowEvent) => flowEvent.nature === FlowEventNature.AUX);
    }
    static async() {
        return BaseRules.if(`ifAsync`, (flowEvent) => flowEvent.nature === FlowEventNature.ASYNC);
    }
    static helper() {
        return BaseRules.if(`ifHelper`, (flowEvent) => flowEvent.nature === FlowEventNature.HELPER);
    }
    static main() {
        return BaseRules.if(`ifMain`, (flowEvent) => flowEvent.nature === FlowEventNature.MAIN);
    }
    static all() {
        return BaseRules.if(`all`, () => true);
    }
    static fromInfo() {
        return BaseRules.combineOr(`info and milestone`, LoggerFilters.info(), LoggerFilters.milestone());
    }
    static allExceptTraces() {
        return BaseRules.combineOr(`all except traces`, LoggerFilters.debug(), LoggerFilters.info(), LoggerFilters.milestone());
    }
    static never() {
        return BaseRules.if(`never`, () => false);
    }
    static default() {
        return BaseRules.combineAnd('default filter', LoggerFilters.milestone(), LoggerFilters.main(), LoggerFilters.initialising().inverse());
    }
}
const FLOW_LOGGER = new FlowLogger(() => CURRENT_LOG_FILTER.rule);
const CURRENT_LOG_FILTER = {
    rule: LoggerFilters.default()
};

(function (AsapType) {
    AsapType["NOW"] = "NOW";
    AsapType["LATER"] = "LATER";
})(exports.AsapType || (exports.AsapType = {}));
function isPromise(toParse) {
    if (toParse == null)
        return false;
    if (typeof toParse != "object")
        return false;
    return ('then' in toParse) && typeof (toParse.then) === 'function';
}
function isAsap(toParse) {
    return (toParse instanceof NowImpl) || (toParse instanceof LaterImpl);
}
class NowImpl {
    constructor(rawValue) {
        this.rawValue = rawValue;
        this.type = exports.AsapType.NOW;
    }
    cancel() {
        return false;
    }
    then(consumer) {
        consumer(this.rawValue);
        return this;
    }
    map(mapper) {
        return Asaps.now(mapper(this.rawValue));
    }
    chain(mapper) {
        const [next, asap] = Asaps.next('map', FlowEventNature.AUX);
        this.then(value => mapper(value).then(toMerge => next(toMerge)));
        return asap;
    }
    catch(error) {
        //Since is not async, it would never fail
        return this;
    }
    onCancel(consumer) {
        //Since is not async, it would never cancel
        return this;
    }
}
class LaterImpl {
    constructor(flow) {
        this.flow = flow;
        this.type = exports.AsapType.LATER;
    }
    map(mapper) {
        let [setNext, nextAsap] = Asaps.next('map', FlowEventNature.AUX);
        this.then(value => setNext(mapper(value)));
        this.onCancel(() => nextAsap.cancel());
        return nextAsap;
    }
    then(consumer) {
        if (this.flow.getCurrentStatusName() === 'resolved') {
            consumer(this.flow.on('resolved').getLastData());
        }
        else {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { then: [...current.then, consumer] })));
        }
        return this;
    }
    resolve(value) {
        if (this.flow.getCurrentStatusName() === 'cancelled')
            return;
        try {
            this.flow.assertOn('resolving', (onResolving) => {
                onResolving.getData().then.forEach(subscriber => {
                    subscriber(value);
                });
                this.flow.on('resolving').transitions.$toStatus({
                    name: "resolved",
                    data: value
                });
            });
        }
        catch (e) {
            console.error(e);
            this.flow.assertOn('resolving', (onResolving) => {
                onResolving.getData().catch.forEach(subscriber => {
                    subscriber(e, value);
                });
                onResolving.do.$toStatus({ name: "errored", data: value });
            });
        }
    }
    onCancel(consumer) {
        if (this.flow.getCurrentStatusName() === 'cancelled') {
            consumer();
            return;
        }
        if (this.flow.getCurrentStatusName() === 'resolving') {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { onCancel: [...current.onCancel, consumer] })));
        }
        return this;
    }
    cancel() {
        if (this.flow.getCurrentStatusName() !== 'resolving') {
            return false;
        }
        this.flow.assertOn('resolving', onResolving => {
            onResolving.getData().onCancel.forEach(subscriber => {
                subscriber();
            });
            this.flow.on('resolving').transitions.$toStatus({ name: "cancelled", });
        });
        return true;
    }
    chain(chainProducer) {
        const [next, asap] = Asaps.next('merge', FlowEventNature.AUX);
        this.then(value => chainProducer(value)
            .then(toMerge => next(toMerge))
            .onCancel(() => asap.cancel())).onCancel(() => asap.cancel());
        return asap;
    }
    catch(consumer) {
        if (this.flow.getCurrentStatusName() === 'resolving') {
            this.flow.on('resolving').steps.$update((current) => (Object.assign(Object.assign({}, current), { catch: [...current.catch, consumer] })));
        }
        return this;
    }
}
class ProxyThen {
    constructor(baseAsap, beforeThen, afterThen) {
        this.baseAsap = baseAsap;
        this.beforeThen = beforeThen;
        this.afterThen = afterThen;
    }
    cancel() {
        return this.baseAsap.cancel();
    }
    catch(error) {
        this.baseAsap.catch(error);
        return this;
    }
    chain(chainProducer) {
        let chained = this.baseAsap.chain(chainProducer);
        return Asaps.proxyThen(chained, this.beforeThen, this.afterThen);
    }
    map(mapper) {
        let mapped = this.baseAsap.map(mapper);
        return Asaps.proxyThen(mapped, this.beforeThen, this.afterThen);
    }
    onCancel(consumer) {
        this.baseAsap.onCancel(consumer);
        return this;
    }
    then(consumer) {
        this.beforeThen();
        this.baseAsap.then(consumer);
        this.baseAsap.then(this.afterThen);
        return this;
    }
    get type() {
        return this.baseAsap.type;
    }
}
class AsapParser {
    static from(toParse) {
        return isAsap(toParse) ?
            toParse :
            isPromise(toParse) ?
                Asaps.fromPromise(toParse) :
                Asaps.now(toParse);
    }
}
class Asaps {
    static now(value) {
        return new NowImpl(value);
    }
    static fromPromise(promise, name) {
        let promiseImpl = new LaterImpl(Flows.createController({
            name: `future[${name ? name : 'anonymous'}]`,
            statuses: {
                resolving: {},
                resolved: {},
                errored: {},
                cancelled: {}
            },
            initialStatus: {
                name: 'resolving',
                data: {
                    then: [],
                    catch: [],
                    onCancel: [],
                }
            },
            nature: FlowEventNature.ASAP
        }).start());
        promise.then(value => promiseImpl.resolve(value));
        promise.catch(e => promiseImpl.catch(e));
        return promiseImpl;
    }
    static delayed(value, ms, name) {
        return Asaps.fromPromise(new Promise((done) => setTimeout(() => {
            if (typeof value === "function") {
                done(value());
            }
            else {
                done(value);
            }
        }, ms)), `delay[${name ? name : 'anonymous'}]`);
    }
    static fetch(url) {
        return Asaps.fromPromise(new Promise((done) => {
            fetch(url)
                .then((resp) => resp.json()) // Transform the data into json
                .then(function (data) {
                done(data);
            });
        }), `fetch[${Strings.padEnd(url, 15)}]`);
    }
    static next(name, nature) {
        let laterImpl = new LaterImpl(Flows.createController({
            name: `asap-${name ? name : 'anonymous'}`,
            statuses: {
                resolving: {},
                resolved: {},
                errored: {},
                cancelled: {}
            },
            initialStatus: {
                name: 'resolving',
                data: {
                    then: [],
                    catch: [],
                    onCancel: []
                }
            },
            nature: nature ? nature : FlowEventNature.ASAP
        }).start());
        return [(value) => laterImpl.resolve(value), laterImpl];
    }
    static proxyThen(toProxy, beforeThen, afterThen) {
        return new ProxyThen(toProxy, beforeThen, afterThen);
    }
}

function deferParser(deferLike, otherwise) {
    if (!isAsap(deferLike))
        return deferLike;
    return {
        action: deferLike,
        name: otherwise.name,
        payload: otherwise.payload
    };
}

class FlowImpl {
    constructor(flowDef, flowAnchor, flowOrchestrator) {
        this.flowDef = flowDef;
        this.flowAnchor = flowAnchor;
        this.flowOrchestrator = flowOrchestrator;
        this.isRunning = false;
    }
    start(initialStatus) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.STARTING, initialStatus).start();
        if (this.isRunning) {
            throw new Error(`can't request a flow that it has been started to start again`);
        }
        this.flowThread = this.flowAnchor.createNewThread(this, this.flowOrchestrator);
        this.isRunning = true;
        if (initialStatus == null && this.flowDef.starter == null) {
            this.requestStatus($INIT);
            return this;
        }
        let actualStarter = initialStatus ? initialStatus : this.flowDef.starter();
        let doStart = (status) => {
            this.addReaction($INIT, {
                action: () => {
                    tracker.debug('initialStatus', status);
                    this.requestStatus(status);
                },
                reactionType: ReactionType.ONCE,
                name: 'to initial state'
            });
            this.addReaction($STOP, {
                name: `onStop=>notifyEvents`,
                reactionType: ReactionType.ONCE,
                action: onStop => {
                    onStop.chain(() => {
                        tracker.debug('state machine stopped');
                        this.flowThread = null;
                        this.isRunning = false;
                    });
                }
            });
            this.requestStatus($INIT);
        };
        AsapParser.from(actualStarter).then(status => doStart(status));
        tracker.end();
        return this;
    }
    requestStatus(statusLike) {
        let statusName = StatusLikeParser.parse(statusLike).name;
        if (!this.isRunning)
            return;
        if (this.on(statusName) == null) {
            throw new Error(`unable to request non existing status [${statusName}]`);
        }
        this.flowThread.requestStatus(statusLike, false);
    }
    requestState(statusName, data) {
        if (!this.isRunning)
            return;
        this.flowThread.requestState(statusName, data);
    }
    requestTransition(transition) {
        if (!this.isRunning)
            return;
        this.flowThread.requestTransition(transition, false);
        return this;
    }
    requestStep(statusName, reducerName, payload, data) {
        if (!this.isRunning)
            return;
        this.flowThread.requestStep(statusName, reducerName, payload, data);
    }
    stop(eventsCb) {
        if (!this.isRunning) {
            throw new Error(`unexpected`);
        }
        this.addReaction($STOP, {
            name: `onStop=>notifyEvents`,
            reactionType: ReactionType.ONCE,
            action: () => {
                if (eventsCb) {
                    eventsCb(this.flowAnchor.getCurrentEvents());
                }
            }
        });
        this.requestStatus({
            name: $STOP
        });
        return this;
    }
    alwaysOn(stateName, def) {
        return this.addReaction(stateName, {
            name: `-`,
            reactionType: ReactionType.ALWAYS,
            action: def
        });
    }
    onceOnInit(def) {
        return this.onceOn($INIT, def);
    }
    onceOnStop(def) {
        return this.onceOn($STOP, def);
    }
    onceOn(stateName, def, name) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.ONCE_ON, stateName).start();
        tracker.debug(`[onceOn(${stateName})`);
        let flow = this.addReaction(stateName, {
            name: name != null ? name : `[userCode]`,
            reactionType: ReactionType.ONCE,
            action: def
        });
        tracker.end();
        return flow;
    }
    addReaction(statusName, reaction) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.ADDING_REACTION).start();
        let needsToBeAdded = true;
        if (this.isRunning) {
            if (this.flowThread.tryToQueue(statusName, reaction)) {
                tracker.info([`queueing reaction: ${reaction.name}`]);
                tracker.end();
                return this;
            }
            this.runIf(statusName, {
                action: (context) => {
                    reaction.action(context);
                    if (reaction.reactionType === ReactionType.ONCE) {
                        needsToBeAdded = false;
                    }
                },
                reactionType: reaction.reactionType,
                name: reaction.name
            });
        }
        if (needsToBeAdded) {
            let statusDef = this.on(statusName);
            if (statusDef == null) {
                throw new Error(`unable to add reactions for unknown event [${statusName}]`);
            }
            this.addReactionNext(statusDef, reaction);
        }
        tracker.end();
        return this;
    }
    addReactionNext(statusDef, reaction) {
        statusDef.reactions.push(reaction);
        return this;
    }
    getReactions(statusName) {
        let statusDef = this.on(statusName);
        if (statusDef == null) {
            throw new Error(`can't getReactions for unknown status[${statusName}]`);
        }
        return statusDef.reactions;
    }
    getCurrentStatusName() {
        if (this.flowThread == undefined)
            return undefined;
        return this.flowThread.getCurrentStatusName();
    }
    getEvents() {
        return this.flowAnchor.getCurrentEvents();
    }
    getName() {
        return this.flowDef.name;
    }
    getState() {
        return this.flowThread.getCurrentState();
    }
    getStatusData() {
        return this.flowAnchor.getStatusData();
    }
    onInit() {
        return this.on($INIT);
    }
    on(statusName) {
        return this.flowDef.statusesByStatusName[statusName];
    }
    getStatusDefs() {
        return this.flowDef.statusesByStatusName;
    }
    removeReaction(statusName, reactionToRemove) {
        let statusDef = this.on(statusName);
        let previousReactions = statusDef.reactions;
        if (!previousReactions)
            return;
        statusDef.reactions = previousReactions.filter(it => it !== reactionToRemove);
    }
    processReactions(statusName) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.PROCESSING_REACTIONS).start();
        let reactions = this.getReactions(statusName);
        let reactionNames = reactions.map(it => it.name).join(',');
        tracker.info(`ABOUT TO PROCESS: ${reactionNames}`);
        let onAllReactionsCompleted;
        reactions.forEach(reaction => {
            tracker.info(`START: ${reaction.name}`);
            if (reaction.reactionType === ReactionType.ONCE) {
                this.removeReaction(statusName, reaction);
            }
            reaction.action(this.flowThread.createContext(statusName, (cb) => onAllReactionsCompleted = cb));
            tracker.info(`END:  ${reaction.name}`);
        });
        tracker.info(`REACTIONS PROCESSED${reactionNames}`);
        if (onAllReactionsCompleted) {
            onAllReactionsCompleted();
        }
        tracker.end(statusName);
        return this;
    }
    getStateData() {
        throw new Error(`TBI`);
    }
    reactOnStatusChanged(customReaction) {
        Object.keys(this.getStatusDefs()).forEach(stateName => {
            this.addReaction(stateName, {
                name: `-`,
                reactionType: ReactionType.ALWAYS,
                action: context => customReaction({ name: stateName, data: context.getData() })
            });
        });
        return this;
    }
    runIf(statusName, reaction, elseIf) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.RUN_IF, reaction.name).start();
        if (!this.isRunning) {
            if (elseIf)
                elseIf();
            tracker.end();
            return;
        }
        let currentStatus = this.getCurrentStatusName();
        if (currentStatus == null) {
            if (elseIf) {
                elseIf();
            }
            tracker.end();
            return;
        }
        if (currentStatus === statusName) {
            this.doRun(reaction, statusName);
        }
        else {
            if (elseIf) {
                elseIf();
            }
        }
        tracker.end();
    }
    doRun(reaction, currentState) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.RUN, reaction.name).start();
        tracker.debug(`${reaction.name}`);
        reaction.action(this.flowThread.createContext(currentState, (cb) => cb()));
        tracker.end();
    }
    assertOn(status, then) {
        let currentStatusName = this.getCurrentStatusName();
        if (currentStatusName !== status) {
            throw new Error(`asserting that we are on the status [${status}]. But we are currently on [${currentStatusName}]`);
        }
        if (then) {
            this.onceOn(status, onAssertedStatus => then(onAssertedStatus));
        }
        return this;
    }
    chainInto(statusFrom, statusTo, mutatorsCb, name) {
        let chainName = name != null ? name : `chainInto-${this.getName()}:${statusTo}`;
        const [next, asap] = Asaps.next(chainName, FlowEventNature.AUX);
        this.addReactionNext(this.on(statusTo), {
            name: chainName,
            reactionType: ReactionType.ONCE,
            action: onChain => next(onChain)
        });
        if (this.getCurrentStatusName() !== '$init') {
            this.assertOn(statusFrom);
            this.onceOn(statusFrom, onThisStatus => mutatorsCb(onThisStatus.do), 'chain-' + chainName);
        }
        else {
            let statusToDef = this.getStatusDefs()[statusTo];
            this.onceOn(`$init`, () => mutatorsCb(statusToDef.steps), 'chain-' + chainName);
        }
        return asap;
    }
    deferInto(statusFrom, statusTo, mutatorsCbAsapLike) {
        let description = `[${this.getName()}]::${statusFrom}=>${statusTo}`;
        let defer = deferParser(mutatorsCbAsapLike, {
            name: description,
            payload: description
        });
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, FlowEventType.MONITORING, {
            asap: defer.action,
            name: defer.name,
            payload: defer.payload
        }).start();
        if (defer.action.type === exports.AsapType.LATER) {
            tracker.milestone(`START monitoring - ${defer.name}`, defer.payload);
        }
        return defer.action.chain(cb => {
            if (defer.action.type === exports.AsapType.LATER) {
                tracker.debug(`STOP monitoring - ${defer.name}`);
            }
            tracker.end();
            return this.chainInto(statusFrom, statusTo, cb);
        }).onCancel(() => {
            tracker.cancel();
        });
    }
    changeLoggingNature(nature) {
        this.flowDef.nature = nature;
    }
    log(msg) {
        let tracker = this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.USER_MSG, FlowEventType.USER_CODE, msg).start();
        let flowRuntimeTracker = tracker.milestone(undefined, msg);
        tracker.end();
        return flowRuntimeTracker;
    }
    createRuntimeTracker(runtimeEvent, payload) {
        return this.flowOrchestrator.createRuntimeTracker(this, FlowEventSource.FLOW_CONTROLLER, runtimeEvent, payload);
    }
    getDefinition() {
        return this.flowDef;
    }
    toStateAll() {
        let thread = Threads.create({
            name: `${this.getName()}=>[all statuses]`
        });
        this.reactOnStatusChanged(status => thread.do.$update(status));
        return thread;
    }
    toState(statusName) {
        let thread = Threads.create({ name: `${this.getName()}=>[states:${statusName}]` });
        this.alwaysOn(statusName, (state) => thread.do.$update(state.getData()));
        return thread;
    }
}

class FlowFacadeImpl {
    constructor(flow, actions) {
        this.flow = flow;
        this.actions = actions;
        this.do = actions;
    }
    addReaction(statusName, reaction) {
        this.flow.addReaction(statusName, reaction);
        return this;
    }
    alwaysOn(stateName, def) {
        this.flow.alwaysOn(stateName, def);
        return this;
    }
    assertOn(status, then) {
        this.flow.assertOn(status, then);
        return this;
    }
    chainInto(statusFrom, statusTo, mutatorsCb, name) {
        this.flow.chainInto(statusFrom, statusTo, mutatorsCb, name);
        return undefined;
    }
    getCurrentStatusName() {
        return this.flow.getCurrentStatusName();
    }
    getEvents() {
        return this.flow.getEvents();
    }
    getName() {
        return this.flow.getName();
    }
    getState() {
        return this.flow.getState();
    }
    getStatusData() {
        return this.flow.getStatusData();
    }
    on(statusName) {
        return this.flow.on(statusName);
    }
    onceOn(stateName, def, name) {
        this.flow.onceOn(stateName, def, name);
        return this;
    }
    onceOnInit(def) {
        this.flow.onceOnInit(def);
        return this;
    }
    onceOnStop(def) {
        this.flow.onceOnStop(def);
        return this;
    }
    start(initialStatus) {
        this.flow.start(initialStatus);
        return this;
    }
    stop(eventsCb) {
        this.flow.stop(eventsCb);
        return this;
    }
    get isRunning() {
        return this.flow.isRunning;
    }
    onInit() {
        return this.flow.onInit();
    }
    reactOnStatusChanged(customReaction) {
        this.flow.reactOnStatusChanged(customReaction);
        return this;
    }
    deferInto(statusFrom, statusTo, mutatorsCbAsap) {
        return this.flow.deferInto(statusFrom, statusTo, mutatorsCbAsap);
    }
    removeReaction(statusName, reactionToRemove) {
        this.flow.removeReaction(statusName, reactionToRemove);
    }
    changeLoggingNature(nature) {
        this.flow.changeLoggingNature(nature);
    }
    log(msg) {
        this.flow.log(msg);
    }
    createRuntimeTracker(runtimeEvent, payload) {
        return this.flow.createRuntimeTracker(runtimeEvent, payload);
    }
    addReactionNext(statusDef, reaction) {
        this.flow.addReactionNext(statusDef, reaction);
        return this;
    }
    getDefinition() {
        return this.flow.getDefinition();
    }
    toState(statusName) {
        return this.flow.toState(statusName);
    }
    toStateAll() {
        return this.flow.toStateAll();
    }
}

const FlowOrchestrator$ = (pipeline) => new FlowOrchestrator([
    (event) => FLOW_LOGGER.log(event),
    ...pipeline,
]);
class Flows {
    static create(flowDef) {
        let flowController = this.createController(flowDef);
        return this.createFacade(flowController, flowDef.actions);
    }
    static createFacade(flowController, actionsDef) {
        return new FlowFacadeImpl(flowController, actionsDef ? actionsDef(flowController) : undefined);
    }
    static createController(flowDef) {
        let flowAnchor = new FlowAnchor();
        let flowOrchestrator = FlowOrchestrator$(flowDef.pipelineListener ? [flowDef.pipelineListener] : []);
        let flowImpl = new FlowImpl(FlowDefFactory.create(flowDef, flowAnchor), flowAnchor, flowOrchestrator);
        let tracker = flowOrchestrator.createRuntimeTracker(flowImpl, FlowEventSource.FLOW_FACTORY, FlowEventType.CREATING, flowDef).start();
        tracker.end();
        return flowImpl;
    }
}

class ThreadFacade {
    constructor(thread, actions) {
        this.thread = thread;
        this.actions = actions;
    }
    chain(mutatorsCb, name) {
        this.thread.chain(mutatorsCb, name);
        return undefined;
    }
    next(cb) {
        this.thread.next(cb);
    }
    start() {
        this.thread.start();
        return this;
    }
    stop(eventsConsumer) {
        this.thread.stop(eventsConsumer);
        return this;
    }
    get do() {
        let steps = this.reducers;
        return Object.assign(Object.assign({}, steps), this.actions);
    }
    get reducers() {
        return this.thread.reducers;
    }
    addReaction(def) {
        return this.thread.addReaction(def);
    }
    get isRunning() {
        return this.thread.isRunning;
    }
    getData() {
        return this.thread.getData();
    }
    getEvents() {
        return this.thread.getEvents();
    }
    getName() {
        return this.thread.getName();
    }
    changeLoggingNature(nature) {
        this.thread.changeLoggingNature(nature);
    }
    log(msg) {
        this.thread.log(msg);
    }
    once(reaction, name) {
        this.thread.once(reaction, name);
        return this;
    }
    createRuntimeTracker(runtimeEvent, payload) {
        return this.thread.createRuntimeTracker(runtimeEvent, payload);
    }
    monitor(toMonitor, thenCallback, name, payload) {
        return this.thread.monitor(toMonitor, thenCallback, name, payload);
    }
    addReactionNext(def) {
        this.thread.addReactionNext(def);
        return this;
    }
    getDefinition() {
        return this.thread.getDefinition();
    }
}

class MethodFinder {
    static exists(theObject, methodName) {
        if (theObject == null)
            return false;
        return this.find(theObject, methodName).length > 0;
    }
    static find(theObject, pattern = '') {
        let prototype = Object.getPrototypeOf(theObject);
        let methodHost = prototype.constructor.name === 'Object' ? theObject : prototype;
        let ownPropertyNames = Object.getOwnPropertyNames(methodHost);
        return ownPropertyNames.filter(it => it.startsWith(pattern));
    }
}

class Threads {
    static create(data, actions) {
        let flow = Flows.createController(Object.assign(Object.assign({ name: data.name, statuses: {
                nextData: Object.assign(Object.assign({}, (data.reducers ? { steps: data.reducers } : undefined)), (data.reactions ? { reactions: data.reactions } : undefined))
            } }, (!data.hasOwnProperty('initialData') ? undefined : {
            initialStatus: AsapParser.from(data.initialData).map(data => ({
                name: 'nextData',
                data
            }))
        })), { pipelineListener: data.pipelineListener, nature: data.nature ? data.nature : FlowEventNature.MAIN }));
        let threadImpl = new ThreadImpl(flow, data);
        if (data.actions && data.autoBind) {
            throw new Error(`you can only use actions or autoBind. Both in conjunction is illegal`);
        }
        let threadFacade;
        if (actions != null) {
            threadFacade = new ThreadFacade(threadImpl, actions);
        }
        else if (data.autoBind) {
            let methodsToProxy = [];
            let autoBindWrapper = Object.assign({}, data.autoBind);
            Object.keys(threadImpl.reducers).forEach(reducerWithDollar => {
                let actionName = reducerWithDollar.substring(1, reducerWithDollar.length);
                if (MethodFinder.exists(data.autoBind, actionName)) {
                    autoBindWrapper[actionName] = (...params) => {
                        return data.autoBind[actionName](...params);
                    };
                    methodsToProxy.push(actionName);
                }
                else {
                    autoBindWrapper[actionName] = (...params) => {
                        return threadImpl.chain(reducers => reducers[reducerWithDollar](...params));
                    };
                }
            });
            threadFacade = new ThreadFacade(threadImpl, Proxyfier.proxy(autoBindWrapper, (original, metadata) => {
                if (methodsToProxy.indexOf(metadata.methodName) === -1) {
                    return original();
                }
                return threadImpl.monitor(original(), (value, reducers) => reducers[`$${metadata.methodName}`](value), metadata.methodName, metadata.payload);
            }));
        }
        else {
            let actions = data.actions ? data.actions(threadImpl) : {};
            Object.keys(threadImpl.reducers).forEach(reducerKey => {
                let matchingActionName = reducerKey.substring(1, reducerKey.length);
                if (!actions[matchingActionName]) {
                    actions[matchingActionName] = (...params) => {
                        return threadImpl.chain(reducers => reducers[reducerKey](...params), `${threadFacade.getName()}.do.${matchingActionName} ()`);
                    };
                }
            });
            actions['updateAsap'] = (reducerAsap, name) => {
                let asap;
                if (!('then' in reducerAsap)) {
                    asap = reducerAsap(threadImpl.getData());
                }
                else {
                    asap = reducerAsap;
                }
                return threadImpl.monitor(asap, (value, reducers) => reducers.$update(value), name == null ? 'updateAsap' : name);
            };
            threadFacade = new ThreadFacade(threadImpl, actions);
        }
        if (!data.cancelAutoStart) {
            threadFacade.start();
        }
        return threadFacade;
    }
}

class PipeImpl {
    constructor(name, pipeConnector, pipeThreadDef) {
        this.name = name;
        this.pipeConnector = pipeConnector;
        this.pipeThreadDef = pipeThreadDef;
    }
    addReaction(def) {
        return this.baseThread.addReaction(def);
    }
    chain(mutatorsCb) {
        return this.baseThread.chain(mutatorsCb);
    }
    getData() {
        return this.baseThread.getData();
    }
    getEvents() {
        return this.baseThread.getEvents();
    }
    getName() {
        return this.baseThread.getName();
    }
    next(cb) {
        this.baseThread.next(cb);
    }
    start() {
        if (this.baseThread == null) {
            let def = Object.assign({ name: this.name }, this.pipeThreadDef);
            this.baseThread = Threads.create(def);
            this.pipeConnector(this.baseThread);
        }
        else {
            this.baseThread.start();
        }
        return this;
    }
    stop(eventsConsumer) {
        this.baseThread.stop(undefined);
        return this;
    }
    get reducers() {
        return this.baseThread.reducers;
    }
    get isRunning() {
        return this.baseThread.isRunning;
    }
    get do() {
        return this.baseThread.do;
    }
    get actions() {
        return this.baseThread.actions;
    }
    get thread() {
        return this.baseThread.thread;
    }
    changeLoggingNature(nature) {
        return this.baseThread.changeLoggingNature(nature);
    }
    log(msg) {
        this.baseThread.log(msg);
    }
    once(reaction, name) {
        this.baseThread.once(reaction, name);
        return this;
    }
    createRuntimeTracker(runtimeEvent, payload) {
        return this.baseThread.createRuntimeTracker(runtimeEvent, payload);
    }
    monitor(toMonitor, thenCallback, name, payload) {
        return this.baseThread.monitor(toMonitor, thenCallback, name, payload);
    }
    addReactionNext(def) {
        this.baseThread.addReactionNext(def);
        return this;
    }
    getDefinition() {
        return this.baseThread.getDefinition();
    }
}

class Pipes {
    static fromMonitor(name, monitor, monitorMerger, dataMerger, pipeThreadDef) {
        return Pipes.filter(name, Pipes.merge(name, monitor.asyncThread, monitorMerger, monitor.mainThread, dataMerger, pipeThreadDef), (current, previous) => !Objects.deepEquals(current, previous), {
            nature: FlowEventNature.AUX
        });
    }
    static map(name, src$, mapper, pipeThreadDef) {
        return new PipeImpl(name, thread => src$.addReaction({
            name: `mapper`,
            dataConsumer: (data) => thread.do.update(mapper(data))
        }), pipeThreadDef).start();
    }
    static merge(name, left$, leftMerger, right$, rightMerger, pipeThreadDef) {
        let statesHistory$ = Threads.create({ name: 'last states', nature: FlowEventNature.AUX });
        let leftHistory$ = Threads.create({ name: 'last states', nature: FlowEventNature.AUX });
        let rightHistory$ = Threads.create({ name: 'last states', nature: FlowEventNature.AUX });
        return new PipeImpl(name, thread => {
            thread.addReaction({
                name: `append state`,
                dataConsumer: (data) => statesHistory$.do.update(data)
            });
            [
                [left$, leftMerger, leftHistory$, rightHistory$],
                [right$, rightMerger, rightHistory$, leftHistory$],
            ].forEach(toConnect => {
                let state$ = toConnect[0];
                let mapper = toConnect[1];
                let thisHistory$ = toConnect[2];
                let oppositeHistory$ = toConnect[3];
                state$.addReaction({
                    name: `merge`,
                    dataConsumer: (data) => {
                        thisHistory$.reducers.$update(data);
                        thread.do.update(mapper(data, oppositeHistory$.getData(), statesHistory$.getData()));
                    }
                });
            });
        }, pipeThreadDef).start();
    }
    static tupleCombine(name, left$, right$, pipeThreadDef) {
        let leftHistory$ = Threads.create({ name: 'last states', nature: FlowEventNature.AUX });
        let rightHistory$ = Threads.create({ name: 'last states', nature: FlowEventNature.AUX });
        return new PipeImpl(`combineArray => [${left$.getName()}, ${right$.getName()}]`, thread => {
            thread.addReaction({
                name: name,
                dataConsumer: (data) => {
                    leftHistory$.do.update(data[0]);
                    rightHistory$.do.update(data[1]);
                }
            });
            [
                [left$, rightHistory$, 'left'],
                [right$, leftHistory$, 'right'],
            ].forEach(toProcess => {
                let state$ = toProcess[0];
                let oppositeHistory$ = toProcess[1];
                let currentlyProcessing = toProcess[2];
                state$.addReaction({
                    name: `tuple=>${currentlyProcessing}`,
                    dataConsumer: (data) => {
                        let newValue;
                        if (currentlyProcessing === 'left') {
                            let oppositeValue = oppositeHistory$.getData();
                            let thisValue = data;
                            newValue = [thisValue, oppositeValue];
                        }
                        else {
                            let oppositeValue = oppositeHistory$.getData();
                            let thisValue = data;
                            newValue = [oppositeValue, thisValue];
                        }
                        thread.do.update(newValue);
                    }
                });
            });
        }, pipeThreadDef).start();
    }
    static combine(name, fromState, pipeThreadDef) {
        return new PipeImpl(name, (thread) => Objects.foreachEntry(fromState, (threadFrom, key) => threadFrom.addReaction({
            name: `combine`,
            dataConsumer: (data) => {
                thread.reducers.$update((current) => {
                    return Object.assign(Object.assign({}, current), { [key]: data });
                });
            }
        })), pipeThreadDef).start();
    }
    static filter(name, toFilter$, predicate, pipeThreadDef) {
        let statesHistory$ = Threads.create({ name: 'last states', nature: FlowEventNature.AUX });
        return new PipeImpl(name, (thread) => {
            thread.addReaction({
                name: `save state`,
                dataConsumer: (data) => statesHistory$.reducers.$update(data)
            });
            toFilter$.addReaction({
                name: `pipe-filter`,
                dataConsumer: (toFilter) => {
                    let previousState = statesHistory$.getData();
                    if (predicate(toFilter, previousState)) {
                        thread.reducers.$update(toFilter);
                    }
                },
            });
        }, pipeThreadDef).start();
    }
}

class MonitorFacade {
    constructor(monitor, actions) {
        this.monitor = monitor;
        this.actions = actions;
    }
    start() {
        this.monitor.start();
        return this;
    }
    addAsyncReaction(def) {
        return this.monitor.addAsyncReaction(def);
    }
    addReaction(def) {
        return this.monitor.addReaction(def);
    }
    once(reaction, name) {
        this.monitor.once(reaction, name);
        return this;
    }
    get do() {
        return this.monitor.do;
    }
    getEvents() {
        return this.monitor.getEvents();
    }
    getName() {
        return this.monitor.getName();
    }
    stop(eventsConsumer) {
        this.monitor.stop(eventsConsumer);
    }
    getData() {
        return this.monitor.getData();
    }
    next(cb) {
        this.monitor.next(cb);
    }
    get asyncThread() {
        return this.monitor.asyncThread;
    }
    get mainThread() {
        return this.monitor.mainThread;
    }
    get metaFlow() {
        return this.monitor.metaFlow;
    }
    chain(operation, name) {
        return this.monitor.mainThread.chain(operation, name);
    }
    transaction(code) {
        return this.monitor.transaction(code);
    }
    openTransaction(name) {
        this.monitor.openTransaction(name);
    }
    closeTransaction(callback) {
        this.monitor.closeTransaction(callback);
    }
}

var MetaStatus;
(function (MetaStatus) {
    MetaStatus["STARTING"] = "STARTING";
    MetaStatus["INIT"] = "INIT";
    MetaStatus["RUNNING"] = "RUNNING";
    MetaStatus["ERROR"] = "ERROR";
    MetaStatus["IDLE"] = "IDLE";
    MetaStatus["IDLE_ON_TRANSACTION"] = "IDLE_ON_TRANSACTION";
})(MetaStatus || (MetaStatus = {}));

class ConanFlow {
    constructor(flow) {
        this.flow = flow;
    }
    on(statusName) {
        return this.flow.on(statusName);
    }
    reactOnStatusChanged(customReaction) {
        this.flow.reactOnStatusChanged(customReaction);
        return this;
    }
    alwaysOn(stateName, def) {
        this.flow.alwaysOn(stateName, def);
        return this;
    }
    start(initialStatus) {
        this.flow.start(initialStatus);
        return this;
    }
    toStateAll() {
        let conanState = __.Conan.state({
            name: `${this.flow.getName()}=>[all statuses]`
        });
        this.reactOnStatusChanged(status => conanState.do.update(status));
        return conanState;
    }
    toState(statusName) {
        let conanState = __.Conan.light(`${this.flow.getName()}=>[states:${statusName}]`);
        this.alwaysOn(statusName, (state) => conanState.do.update(state.getData()));
        return conanState;
    }
}

class MonitorImpl {
    constructor(mainThread, asyncThread, metaFlow) {
        this.mainThread = mainThread;
        this.asyncThread = asyncThread;
        this.metaFlow = metaFlow;
    }
    start() {
        this.mainThread.start();
        return this;
    }
    addReaction(def) {
        return this.mainThread.addReaction(def);
    }
    addAsyncReaction(def) {
        return this.asyncThread.addReaction(def);
    }
    get do() {
        return this.mainThread.do;
    }
    getEvents() {
        return this.mainThread.getEvents();
    }
    getName() {
        return this.mainThread.getName();
    }
    stop(eventsConsumer) {
        this.mainThread.stop(eventsConsumer);
    }
    getData() {
        return this.mainThread.getData();
    }
    next(cb) {
        this.mainThread.next(cb);
    }
    once(reaction, name) {
        this.mainThread.once(reaction, name);
        return this;
    }
    chain(operation, name) {
        return this.mainThread.chain(operation, name);
    }
    openTransaction(name) {
        if (this.currentTransaction == null) {
            this.currentTransaction = this.mainThread.createRuntimeTracker(FlowEventType.MONITOR_TRANSACTION).start();
            this.currentTransaction.info(`starting transaction: ${name == null ? `[anonymous]` : name}`);
        }
    }
    closeTransaction(callback) {
        let metaFlowStatuses$ = new ConanFlow(this.metaFlow).toStateAll().map(it => it.data);
        let unlockTupleNow = false;
        let unlockThreadNow = false;
        let tupleLock = undefined;
        tupleLock = Pipes.tupleCombine('idleChecker', this.asyncThread, metaFlowStatuses$.mainThread, {
            nature: FlowEventNature.AUX
        }).addReaction({
            name: `wait for both idle`,
            dataConsumer: ([monitorInfo, metaInfo]) => {
                if (monitorInfo.status === exports.MonitorStatus.IDLE && (metaInfo.status === MetaStatus.IDLE_ON_TRANSACTION ||
                    metaInfo.status === MetaStatus.IDLE)) {
                    let mainThreadLock = undefined;
                    mainThreadLock = this.mainThread.addReaction({
                        name: 'wait for both idle',
                        dataConsumer: (data) => {
                            this.currentTransaction.info(`finishing transaction`);
                            this.currentTransaction.end();
                            this.currentTransaction = null;
                            if (mainThreadLock) {
                                mainThreadLock.release();
                            }
                            else {
                                unlockThreadNow = true;
                            }
                            if (tupleLock) {
                                tupleLock.release();
                            }
                            else {
                                unlockTupleNow = true;
                            }
                            if (callback) {
                                callback(data);
                            }
                        }
                    });
                    if (unlockThreadNow) {
                        mainThreadLock.release();
                    }
                }
            }
        });
        if (unlockTupleNow) {
            tupleLock.release();
        }
    }
    transaction(code, name) {
        let [next, asap] = Asaps.next(`transaction[${name}]`);
        this.openTransaction();
        code(this.do);
        this.closeTransaction(data => next(data));
        return asap;
    }
}

class MetaMutatorsFactory {
    static createTransitions(getStatus, statusName) {
        return {
            toIdle() {
                let transactionCount = getStatus().transactionCount;
                return {
                    name: transactionCount === 0 ? "idle" : "idleOnTransaction",
                    data: {
                        status: transactionCount === 0 ? MetaStatus.IDLE : MetaStatus.IDLE_ON_TRANSACTION,
                        transactionCount: transactionCount,
                        lastError: getStatus().lastError
                    }
                };
            },
            toInit() {
                return {
                    name: "init",
                    data: {
                        status: MetaStatus.INIT,
                        transactionCount: getStatus().transactionCount,
                        lastError: getStatus().lastError
                    }
                };
            },
            toRunning() {
                return {
                    name: "running",
                    data: {
                        status: MetaStatus.RUNNING,
                        transactionCount: getStatus().transactionCount,
                        lastError: getStatus().lastError
                    }
                };
            },
            toError(error) {
                return {
                    name: "error",
                    data: {
                        status: MetaStatus.ERROR,
                        transactionCount: getStatus().transactionCount,
                        lastError: error
                    }
                };
            }
        };
    }
    static createSteps(getState) {
        return ({
            $onTransaction(timing) {
                let metaInfo = getState();
                return {
                    status: metaInfo.status,
                    transactionCount: timing === FlowEventTiming.START ? ++metaInfo.transactionCount : --metaInfo.transactionCount,
                    lastError: metaInfo.lastError
                };
            },
        });
    }
}

class Monitors {
    static fromThread(thread) {
        let monitorFacade = Monitors.create({
            name: thread.getName(),
            initialData: thread.getDefinition().initialData,
            nature: thread.getDefinition().nature,
            actions: thread.getDefinition().actions,
            autoBind: thread.getDefinition().autoBind,
            reducers: thread.getDefinition().reducers
        }, thread.actions);
        thread.addReaction({
            name: `pipe`,
            dataConsumer: (data) => monitorFacade.do.$update(data)
        });
        return monitorFacade;
    }
    static create(data, actions) {
        let asyncThread = this.createAsyncThread(data);
        let metaFlow = this.createMetaFlow(data.name);
        let mainThread = Threads.create(Object.assign(Object.assign({}, data), { nature: data.nature, pipelineListener: (event) => {
                this.orchestrate(event, asyncThread, metaFlow);
            } }), actions);
        let monitorImpl = new MonitorImpl(mainThread, asyncThread, metaFlow);
        return new MonitorFacade(monitorImpl, mainThread.actions);
    }
    static createMetaFlow(parentName) {
        let flowFacade = Flows.create({
            name: `${parentName}=>[meta]`,
            statuses: {
                starting: {
                    transitions: getStatus => MetaMutatorsFactory.createTransitions(getStatus, 'starting'),
                    steps: getState => MetaMutatorsFactory.createSteps(getState)
                },
                init: {
                    transitions: getStatus => MetaMutatorsFactory.createTransitions(getStatus, 'init'),
                    steps: getState => MetaMutatorsFactory.createSteps(getState)
                },
                running: {
                    transitions: getStatus => MetaMutatorsFactory.createTransitions(getStatus, 'running'),
                    steps: getState => MetaMutatorsFactory.createSteps(getState)
                },
                idle: {
                    transitions: getStatus => MetaMutatorsFactory.createTransitions(getStatus, 'idle'),
                    steps: getState => MetaMutatorsFactory.createSteps(getState)
                },
                idleOnTransaction: {
                    transitions: getStatus => MetaMutatorsFactory.createTransitions(getStatus, 'idleOnTransaction'),
                    steps: getState => MetaMutatorsFactory.createSteps(getState)
                },
                error: {
                    transitions: getStatus => MetaMutatorsFactory.createTransitions(getStatus, 'error'),
                    steps: getState => MetaMutatorsFactory.createSteps(getState)
                }
            },
            initialStatus: {
                name: 'starting',
                data: {
                    status: MetaStatus.STARTING,
                    transactionCount: 0
                }
            },
            nature: FlowEventNature.META
        });
        flowFacade.start();
        return flowFacade;
    }
    static createAsyncThread(data) {
        return Threads.create({
            name: `${data.name}=>[async]`,
            actions: thread => ({
                tick(toMonitor) {
                    thread.reducers.$update(current => ({
                        status: exports.MonitorStatus.ASYNC_START,
                        currentAction: toMonitor,
                        inProgressActions: [...current.inProgressActions, toMonitor]
                    }));
                },
                unTick(toMonitor, cancelled) {
                    thread.reducers.$update(current => {
                        return ({
                            status: cancelled ? exports.MonitorStatus.ASYNC_CANCELLED : exports.MonitorStatus.ASYNC_FULFILLED,
                            currentAction: toMonitor,
                            inProgressActions: current.inProgressActions.filter(it => it !== toMonitor)
                        });
                    });
                    if (thread.getData().inProgressActions.length === 0)
                        thread.reducers.$update(current => ({
                            inProgressActions: [],
                            currentAction: undefined,
                            status: exports.MonitorStatus.IDLE
                        }));
                }
            }),
            initialData: {
                inProgressActions: [],
                status: exports.MonitorStatus.IDLE,
                currentAction: undefined
            },
            nature: FlowEventNature.ASYNC
        });
    }
    static orchestrate(event, asyncThread, metaFlow) {
        let timing = event.timing;
        if (event.type === FlowEventType.ERROR_USER_CODE) {
            metaFlow.assertOn(metaFlow.getCurrentStatusName(), onAny => onAny.do.toError());
        }
        if (event.type === FlowEventType.MONITORING) {
            if (timing === FlowEventTiming.START) {
                asyncThread.do.tick(event.payload);
                metaFlow.assertOn(metaFlow.getCurrentStatusName(), onAny => onAny.do.toRunning());
            }
            else if (timing === FlowEventTiming.END) {
                asyncThread.do.unTick(event.payload, false);
            }
            else if (timing === FlowEventTiming.CANCEL) {
                asyncThread.do.unTick(event.payload, true);
            }
            return;
        }
        if (event.type === FlowEventType.MONITOR_TRANSACTION && (timing === FlowEventTiming.START || timing === FlowEventTiming.END)) {
            switch (metaFlow.getCurrentStatusName()) {
                case 'starting':
                    metaFlow.assertOn('starting', onStarting => onStarting.do.$onTransaction(timing));
                    break;
                case 'init':
                    metaFlow.assertOn('init', onInit => onInit.do.$onTransaction(timing));
                    break;
                case 'running':
                    metaFlow.assertOn('running', onRunning => onRunning.do.$onTransaction(timing));
                    break;
                case 'idle':
                    metaFlow.assertOn('idle', onIdle => onIdle.do.$onTransaction(timing));
                    break;
                case 'idleOnTransaction':
                    metaFlow.assertOn('idleOnTransaction', onIdle => {
                        onIdle.do.$onTransaction(timing);
                        if (onIdle.getData().transactionCount === 0 && timing === FlowEventTiming.END) {
                            onIdle.do.toIdle();
                        }
                    });
                    break;
            }
        }
        if (event.type === FlowEventType.ROOT_REQUEST) {
            if (timing === FlowEventTiming.START || timing === FlowEventTiming.CONTINUE) {
                if (event.flowController.getCurrentStatusName() === '$init')
                    return;
                switch (metaFlow.getCurrentStatusName()) {
                    case 'idle':
                        metaFlow.assertOn('idle', onInit => onInit.do.toRunning());
                        break;
                    case 'idleOnTransaction':
                        metaFlow.assertOn('idleOnTransaction', onInit => onInit.do.toRunning());
                        break;
                    case 'init':
                        metaFlow.assertOn('init', onInit => onInit.do.toRunning());
                        break;
                }
            }
            else if (timing === FlowEventTiming.END) {
                switch (metaFlow.getCurrentStatusName()) {
                    case 'starting':
                        metaFlow.assertOn('starting', onStarting => onStarting.do.toInit());
                        break;
                    case 'init':
                        metaFlow.assertOn('init', onInit => onInit.do.toIdle());
                        break;
                    case 'running':
                        if (asyncThread.getData().status === exports.MonitorStatus.IDLE) {
                            metaFlow.assertOn('running', onRunning => onRunning.do.toIdle());
                        }
                        break;
                    case 'idleOnTransaction':
                        if (asyncThread.getData().status === exports.MonitorStatus.IDLE) {
                            metaFlow.assertOn('idleOnTransaction', onInit => onInit.do.toIdle());
                        }
                        break;
                }
            }
        }
    }
}

class ConanState {
    constructor(monitor) {
        this.monitor = monitor;
    }
    getName() {
        return this.monitor.getName();
    }
    connectMap(toConnect, mapper) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: mapper });
    }
    connectData(toConnect) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: (data) => data });
    }
    connect(toConnect) {
        return React.createElement(StateConnect, { from: this, into: toConnect });
    }
    connectLive(renderer, fallbackValue) {
        return React.createElement(StateLive, { from: this, renderer: renderer, fallbackValue: fallbackValue });
    }
    addAsyncReaction(def) {
        return this.monitor.addAsyncReaction(def);
    }
    addDataReaction(def) {
        return this.monitor.addReaction(def);
    }
    get do() {
        return this.monitor.do;
    }
    start() {
        this.monitor.start();
        return this;
    }
    stop(eventsConsumer) {
        this.monitor.stop(eventsConsumer);
        return this;
    }
    get actions() {
        return this.monitor.actions;
    }
    getData() {
        return this.monitor.getData();
    }
    asyncMerge(baseValue, monitorMerger, dataMerger) {
        let mergedThread = Pipes.fromMonitor(`monitor[${this.getName()}]`, this.monitor, monitorMerger, dataMerger, {
            initialData: baseValue,
            nature: FlowEventNature.HELPER
        });
        return new ConanState(Monitors.fromThread(new ThreadFacade(mergedThread, this.actions)));
    }
    filter(mapper) {
        let state = Pipes.filter(`filter=>${this.getName()}`, this.mainThread, mapper);
        return new ConanState(Monitors.fromThread(state));
    }
    map(mapper) {
        let state = Pipes.map(`map=>${this.getName()}`, this.mainThread, mapper);
        return new ConanState(Monitors.fromThread(state));
    }
    merge(toMerge$, merger) {
        let state = Pipes.merge(`merge=>${this.getName()}`, this.mainThread, merger, toMerge$.mainThread, (right, left, current) => merger(left, right, current));
        return new ConanState(Monitors.fromThread(state));
    }
    tuple(toMerge$) {
        let state = Pipes.tupleCombine(`mergeTuple=>${this.getName()}`, this.mainThread, toMerge$.mainThread);
        return new ConanState(Monitors.fromThread(state));
    }
    get mainThread() {
        return this.monitor.mainThread;
    }
    get asyncState() {
        return __.Conan.fromThread(this.monitor.asyncThread);
    }
    get metaFlow() {
        return __.Conan.fromFlow(this.monitor.metaFlow);
    }
    static combine(name, fromState, pipeThreadDef) {
        let threadFacade = Pipes.combine(name, Objects.mapKeys(fromState, conanState => conanState.mainThread), pipeThreadDef);
        return new ConanState(Monitors.fromThread(threadFacade));
    }
    getEvents() {
        return this.mainThread.getEvents();
    }
    always(dataConsumer) {
        this.addDataReaction({
            name: `always`,
            dataConsumer: (data) => dataConsumer(data)
        });
    }
    openTransaction(name) {
        this.monitor.openTransaction(name);
    }
    closeTransaction(callback) {
        this.monitor.closeTransaction(callback);
    }
}

class Conan {
    static light(name, initialData, nature = FlowEventNature.MAIN) {
        return new ConanState(Monitors.create(Object.assign({ name,
            initialData }, (nature ? { nature } : undefined))));
    }
    static state(data) {
        return new ConanState(Monitors.create(data));
    }
    static fromThread(thread) {
        let conanState = Conan.state(thread.getDefinition());
        thread.addReaction({
            name: `pipe`,
            dataConsumer: (data) => conanState.do.update(data)
        });
        return conanState;
    }
    static flow(flowDef) {
        let conanFlow = new ConanFlow(__.Flows.create(flowDef));
        conanFlow.start();
        return conanFlow;
    }
    static fromFlow(flow) {
        return new ConanFlow(flow);
    }
}

class Lists {
    static mergeCombine(from, toMerge, comparator, merger) {
        let result = [];
        let anythingChanged = false;
        result = toMerge.map(it => {
            for (let inSrc of from) {
                if (comparator(inSrc, it)) {
                    anythingChanged = true;
                    return merger(inSrc, it);
                }
            }
            return it;
        });
        return anythingChanged ? result : toMerge;
    }
}

exports.AsapParser = AsapParser;
exports.Asaps = Asaps;
exports.Conan = Conan;
exports.ConanState = ConanState;
exports.ContextStateConnect = ContextStateConnect;
exports.ContextStateLive = ContextStateLive;
exports.ContextStateMapConnect = ContextStateMapConnect;
exports.DiAnnotationsMetadataFactory = DiAnnotationsMetadataFactory;
exports.DiContextFactory = DiContextFactory;
exports.DynamicOrStatics = DynamicOrStatics;
exports.Flows = Flows;
exports.InjectByName = InjectByName;
exports.InjectByType = InjectByType;
exports.InjectDynamic = InjectDynamic;
exports.Lists = Lists;
exports.ReactStateContext = ReactStateContext;
exports.StateConnect = StateConnect;
exports.StateLive = StateLive;
exports.StateMapConnect = StateMapConnect;
exports.contextStateConnect = contextStateConnect;
exports.contextStateLive = contextStateLive;
exports.contextStateMapConnect = contextStateMapConnect;
exports.diAnnotationsCrud = diAnnotationsCrud;
exports.isAsap = isAsap;
exports.stateConnect = stateConnect;
exports.stateLive = stateLive;
exports.stateMapConnect = stateMapConnect;
exports.useConanState = useConanState;
exports.useContextConanState = useContextConanState;
exports.useFlow = useFlow;
exports.useFlowStatus = useFlowStatus;
