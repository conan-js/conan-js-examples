import { InjectableType } from './annotations/diAnnotationsDomain';
import { DiRuntime } from './diRuntime';
export class DiInvocationResolver {
    constructor(diInvocationFactory, diCache, diEnricher) {
        this.diInvocationFactory = diInvocationFactory;
        this.diCache = diCache;
        this.diEnricher = diEnricher;
    }
    resolve(invocation, context, diRuntime) {
        if (this.causesCircularDependency(invocation)) {
            return {
                circularDependencyEndOf: invocation.diMetadata.dependencyName,
                result: null,
                pendingDependencies: {}
            };
        }
        // @ts-ignore
        let freshInvocationResult = null;
        let bean = this.diCache.resolve(invocation.diMetadata.dependencyName, () => {
            freshInvocationResult = this.doCreate(invocation, context, diRuntime);
            if (this.diEnricher) {
                freshInvocationResult.result = this.diEnricher(invocation.diMetadata, freshInvocationResult.result);
            }
            if (Object.keys(freshInvocationResult.pendingDependencies).indexOf(invocation.diMetadata.dependencyName) > -1) {
                freshInvocationResult.pendingDependencies[invocation.diMetadata.dependencyName].forEach(childDependency => {
                    this.diCache.resolve(childDependency, null)[invocation.diMetadata.dependencyName] = freshInvocationResult.result;
                });
            }
            return freshInvocationResult.result;
        });
        return freshInvocationResult == null ? {
            result: bean,
            pendingDependencies: {}
        } : freshInvocationResult;
    }
    causesCircularDependency(invocation) {
        return invocation.inProcessDiInvocations.indexOf(invocation.diMetadata.dependencyName) > -1;
    }
    doCreate(invocation, context, diRuntime) {
        const useConstructorOrFn = (invocation, params) => {
            let constructor = invocation.diMetadata.constructor;
            if (!!constructor.prototype && !!constructor.prototype.constructor.name) {
                return params ? new constructor(...params) : new constructor();
            }
            else {
                return params ? constructor(...params) : constructor();
            }
        };
        if (invocation.diMetadata.argumentNames.length === 0) {
            let result = useConstructorOrFn(invocation, undefined);
            return {
                result: result,
                pendingDependencies: {}
            };
        }
        let childrenInvocationResults = this.invokeChildren(invocation, context, diRuntime);
        let params = [];
        let startsCircularDependencies = {};
        childrenInvocationResults.forEach(child => {
            params.push(child.result);
            if (child.circularDependencyEndOf != null) {
                DiInvocationResolver.addValueToKeyValuePairs(startsCircularDependencies, child.circularDependencyEndOf, invocation.diMetadata.dependencyName);
            }
            if (child.pendingDependencies) {
                Object.keys(child.pendingDependencies).forEach(key => {
                    DiInvocationResolver.addValuesToKeyValuePairs(startsCircularDependencies, key, child.pendingDependencies[key]);
                });
            }
        });
        return {
            result: useConstructorOrFn(invocation, params),
            pendingDependencies: startsCircularDependencies
        };
    }
    static addValueToKeyValuePairs(keyValuePairs, key, value) {
        if (!keyValuePairs[key]) {
            keyValuePairs[key] = [];
        }
        if (keyValuePairs[key].indexOf(value) > -1)
            return;
        keyValuePairs[key].push(value);
    }
    static addValuesToKeyValuePairs(keyValuePairs, key, values) {
        if (!keyValuePairs[key]) {
            keyValuePairs[key] = values;
            return;
        }
        values.forEach(value => DiInvocationResolver.addValueToKeyValuePairs(keyValuePairs, key, value));
    }
    invokeChildren(invocation, context, diRuntime) {
        let params = [];
        invocation
            .diMetadata
            .argumentNames
            .forEach(argumentName => {
            let resolvedParam = this.resolveParamDef(invocation, argumentName);
            params.push(this.invokeChild(invocation, resolvedParam, context, diRuntime));
        });
        return params;
    }
    resolveParamDef(invocation, argumentName) {
        let fromAnnotation = invocation.diMetadata.diParams[argumentName];
        if (fromAnnotation == null) {
            return {
                name: argumentName,
                propsProvider: null,
                payload: argumentName,
                type: InjectableType.NAME
            };
        }
        return fromAnnotation;
    }
    invokeChild(invocation, resolvedParam, context, diRuntime) {
        if (resolvedParam.name === DiRuntime.PROPS_PROPERTY_NAME) {
            return this.resolveChildProps(invocation);
        }
        if (resolvedParam.type === InjectableType.TYPE) {
            return this.resolveChildByType(invocation, resolvedParam, context, diRuntime);
        }
        if (resolvedParam.type === InjectableType.DYNAMIC) {
            return this.resolveDynamicChild(invocation, resolvedParam, context, diRuntime);
        }
        return this.resolveChildByName(invocation, resolvedParam, context, diRuntime);
    }
    resolveChildProps(invocation) {
        if (invocation.properties == null) {
            throw Error(`can't resolve properties for $props - There are no properties passed to the beanRuntime`);
        }
        return {
            result: invocation.properties,
            pendingDependencies: {}
        };
    }
    resolveChildByType(invocation, childParamMetadata, context, diRuntime) {
        return this.resolve(this.diInvocationFactory.childrenOf(invocation, childParamMetadata.payload, childParamMetadata.propsProvider), context, diRuntime);
    }
    resolveDynamicChild(invocation, resolvedParam, context, diRuntime) {
        return this.resolveChildByType(invocation, {
            payload: resolvedParam.payload(),
            type: InjectableType.TYPE,
            propsProvider: resolvedParam.propsProvider,
            name: resolvedParam.name
        }, context, diRuntime);
    }
    resolveChildByName(invocation, resolvedParam, context, diRuntime) {
        let nameToResolve = resolvedParam.payload;
        if (invocation.transitiveBeans == null || invocation.transitiveBeans[nameToResolve] == null) {
            if (context[nameToResolve] != null) {
                let byName = diRuntime.invoke(context[nameToResolve], invocation.transitiveBeans, context);
                return {
                    result: byName,
                    pendingDependencies: {}
                };
            }
            else {
                throw Error(`can't resolve param '${nameToResolve}' - There are no transitive beans passed into the runtime`);
            }
        }
        return {
            result: invocation.transitiveBeans[nameToResolve],
            pendingDependencies: {}
        };
    }
}
//# sourceMappingURL=diInvocationResolver.js.map