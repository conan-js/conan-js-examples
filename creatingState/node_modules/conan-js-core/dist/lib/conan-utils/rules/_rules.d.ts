import { IPredicate } from "../typesHelper";
export declare type RuleLike<T> = Rule<T> | IPredicate<T>;
export declare class RuleLikeParser {
    static parse<T = any>(toParse: RuleLike<T>): Rule<T>;
    static isRule<T = any>(toParse: RuleLike<T>): boolean;
}
export declare enum RuleType {
    COMBINED = "COMBINED",
    SIMPLE = "SIMPLE"
}
export interface Rule<T = any> {
    test(value: T): boolean;
    negate: boolean;
    ruleType: RuleType;
    name: string;
    inverse(): Rule<T>;
    and(rule: Rule<T>): Rule<T>;
    or(rule: Rule<T>): Rule<T>;
    split(additionalRule: Rule<T>): [Rule<T>, Rule<T>];
}
export declare enum LOGIC_OPERATOR {
    OR = "OR",
    AND = "AND"
}
export declare abstract class BaseRule<T> implements Rule<T> {
    readonly negate: boolean;
    readonly baseName: string;
    abstract ruleType: RuleType;
    protected constructor(negate: boolean, baseName: string);
    abstract inverse(): Rule<T>;
    split(additionalRule: Rule<T>): [Rule<T>, Rule<T>];
    test(value: T): boolean;
    abstract doEvaluate(value: T): boolean;
    or(rule: Rule<T>): Rule<T>;
    and(rule: Rule<T>): Rule<T>;
    get name(): string;
}
export declare class CombinedRule<T = any> extends BaseRule<T> implements Rule<T> {
    private readonly rules;
    private readonly operator;
    readonly ruleType: RuleType;
    constructor(name: string, rules: Rule<T>[], operator: LOGIC_OPERATOR, negate?: boolean);
    doEvaluate(value: T): boolean;
    inverse(): Rule<T>;
    get name(): string;
}
export declare class SimpleRule<T = any> extends BaseRule<T> implements Rule<T> {
    private readonly predicate;
    readonly ruleType: RuleType;
    constructor(name: string, predicate: IPredicate<T>, negate?: boolean);
    inverse(): Rule<T>;
    doEvaluate(value: T): boolean;
}
