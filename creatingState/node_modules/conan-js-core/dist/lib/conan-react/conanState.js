import * as React from "react";
import { StateConnect, StateMapConnect } from "./connect/stateConnect";
import { Conan } from "..";
import { StateLive } from "./live/stateLive";
import { Pipes } from "../conan-pipe/factories/pipes";
import { ThreadFacade } from "../conan-thread/domain/threadFacade";
import { Objects } from "../conan-utils/objects";
import { FlowEventNature } from "../conan-flow/domain/flowRuntimeEvents";
import { Monitors } from "../conan-monitor/factories/monitors";
export class ConanState {
    constructor(monitor) {
        this.monitor = monitor;
    }
    getName() {
        return this.monitor.getName();
    }
    connectMap(toConnect, mapper) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: mapper });
    }
    connectData(toConnect) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: (data) => data });
    }
    connect(toConnect) {
        return React.createElement(StateConnect, { from: this, into: toConnect });
    }
    connectLive(renderer, fallbackValue) {
        return React.createElement(StateLive, { from: this, renderer: renderer, fallbackValue: fallbackValue });
    }
    addAsyncReaction(def) {
        return this.monitor.addAsyncReaction(def);
    }
    addDataReaction(def) {
        return this.monitor.addReaction(def);
    }
    get do() {
        return this.monitor.do;
    }
    start() {
        this.monitor.start();
        return this;
    }
    stop(eventsConsumer) {
        this.monitor.stop(eventsConsumer);
        return this;
    }
    get actions() {
        return this.monitor.actions;
    }
    getData() {
        return this.monitor.getData();
    }
    asyncMerge(baseValue, monitorMerger, dataMerger) {
        let mergedThread = Pipes.fromMonitor(`monitor[${this.getName()}]`, this.monitor, monitorMerger, dataMerger, {
            initialData: baseValue,
            nature: FlowEventNature.HELPER
        });
        return new ConanState(Monitors.fromThread(new ThreadFacade(mergedThread, this.actions)));
    }
    filter(mapper) {
        let state = Pipes.filter(`filter=>${this.getName()}`, this.mainThread, mapper);
        return new ConanState(Monitors.fromThread(state));
    }
    map(mapper) {
        let state = Pipes.map(`map=>${this.getName()}`, this.mainThread, mapper);
        return new ConanState(Monitors.fromThread(state));
    }
    merge(toMerge$, merger) {
        let state = Pipes.merge(`merge=>${this.getName()}`, this.mainThread, merger, toMerge$.mainThread, (right, left, current) => merger(left, right, current));
        return new ConanState(Monitors.fromThread(state));
    }
    tuple(toMerge$) {
        let state = Pipes.tupleCombine(`mergeTuple=>${this.getName()}`, this.mainThread, toMerge$.mainThread);
        return new ConanState(Monitors.fromThread(state));
    }
    get mainThread() {
        return this.monitor.mainThread;
    }
    get asyncState() {
        return Conan.fromThread(this.monitor.asyncThread);
    }
    get metaFlow() {
        return Conan.fromFlow(this.monitor.metaFlow);
    }
    static combine(name, fromState, pipeThreadDef) {
        let threadFacade = Pipes.combine(name, Objects.mapKeys(fromState, conanState => conanState.mainThread), pipeThreadDef);
        return new ConanState(Monitors.fromThread(threadFacade));
    }
    getEvents() {
        return this.mainThread.getEvents();
    }
    always(dataConsumer) {
        this.addDataReaction({
            name: `always`,
            dataConsumer: (data) => dataConsumer(data)
        });
    }
    openTransaction(name) {
        this.monitor.openTransaction(name);
    }
    closeTransaction(callback) {
        this.monitor.closeTransaction(callback);
    }
}
//# sourceMappingURL=conanState.js.map