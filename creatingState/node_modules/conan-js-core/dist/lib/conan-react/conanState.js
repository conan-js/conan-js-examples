import * as React from "react";
import { StateConnect, StateMapConnect } from "./connect/stateConnect";
import { StateLive } from "./live/stateLive";
import { Pipes } from "../conan-pipe/factories/factories";
import { ThreadFacade } from "../conan-thread/domain/threadFacade";
export class ConanState {
    constructor(state) {
        this.state = state;
    }
    getName() {
        return this.state.getName();
    }
    connectMap(toConnect, mapper) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: mapper });
    }
    connectLive(renderer, fallbackValue) {
        return React.createElement(StateLive, { from: this, renderer: renderer, fallbackValue: fallbackValue });
    }
    connectData(toConnect) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: (data) => data });
    }
    connect(toConnect) {
        return React.createElement(StateConnect, { from: this, into: toConnect });
    }
    addAsyncReaction(def) {
        if (this.state instanceof ThreadFacade) {
            return;
        }
        return this.state.addAsyncReaction(def);
    }
    addDataReaction(def) {
        return this.state.addReaction(def);
    }
    get do() {
        return this.state.do;
    }
    start() {
        this.state.start();
        return this;
    }
    stop(eventsConsumer) {
        this.state.stop(eventsConsumer);
        return this;
    }
    get actions() {
        return this.state.actions;
    }
    getData() {
        return this.state.getData();
    }
    asyncMerge(baseValue, monitorMerger, dataMerger) {
        if (this.state instanceof ThreadFacade) {
            throw new Error(`this conan state is not ready for async`);
        }
        let mergedThread = Pipes.fromMonitor(this.state, baseValue, monitorMerger, dataMerger);
        return new ConanState(new ThreadFacade(mergedThread, this.actions));
    }
}
//# sourceMappingURL=conanState.js.map