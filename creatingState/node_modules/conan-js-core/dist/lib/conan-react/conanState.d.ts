import * as React from "react";
import { ReactElement } from "react";
import { DataReactionDef, DataReactionLock } from "../conan-thread/domain/dataReaction";
import { ConnectedState } from "./connect/stateConnect";
import { IBiFunction, IConsumer, IFunction } from "../index";
import { DefaultActionsFn } from "../conan-flow/domain/actions";
import { MonitorFacade } from "../conan-monitor/domain/monitorFacade";
import { MonitorInfo } from "../conan-monitor/domain/monitorInfo";
import { ThreadFacade } from "../conan-thread/domain/threadFacade";
import { ITriFunction } from "../conan-utils/typesHelper";
import { PipeThreadDef } from "../conan-pipe/domain/pipeThreadDef";
import { FlowEventsTracker } from "../conan-flow/logic/flowEventsTracker";
import { MonitorActions } from "../conan-monitor/domain/monitorActions";
import { ConanFlow } from "./conanFlow";
import { MetaMutators, MetaStatuses } from "../conan-monitor/domain/metaFlow";
export declare class ConanState<DATA, ACTIONS = DefaultActionsFn<DATA>> {
    private readonly monitor;
    constructor(monitor: MonitorFacade<DATA, any, ACTIONS>);
    getName(): string;
    connectMap<PROPS>(toConnect: React.ComponentType<PROPS>, mapper: IBiFunction<DATA, ACTIONS, PROPS>): ReactElement<PROPS>;
    connectData(toConnect: React.ComponentType<DATA>): ReactElement<DATA>;
    connect(toConnect: React.ComponentType<ConnectedState<DATA, ACTIONS>>): ReactElement<ConnectedState<DATA, ACTIONS>>;
    connectLive(renderer: IBiFunction<DATA, ACTIONS, ReactElement | ReactElement[]>, fallbackValue?: DATA): ReactElement;
    addAsyncReaction(def: DataReactionDef<DATA>): DataReactionLock;
    addDataReaction(def: DataReactionDef<DATA>): DataReactionLock;
    get do(): ACTIONS & DefaultActionsFn<DATA>;
    start(): this;
    stop(eventsConsumer: (events: any) => void): this;
    get actions(): ACTIONS & DefaultActionsFn<DATA>;
    getData(): DATA;
    asyncMerge<T>(baseValue: T, monitorMerger: (ITriFunction<MonitorInfo, DATA, T, T>), dataMerger: ITriFunction<DATA, MonitorInfo, T, T>): ConanState<T, ACTIONS>;
    filter(mapper: (current: DATA, previous: DATA) => boolean): ConanState<DATA>;
    map<T>(mapper: IFunction<DATA, T>): ConanState<T>;
    merge<T, TO_MERGE>(toMerge$: ConanState<TO_MERGE, any>, merger: ITriFunction<DATA, TO_MERGE, T, T>): ConanState<T>;
    tuple<TO_MERGE>(toMerge$: ConanState<TO_MERGE, any>): ConanState<[DATA, TO_MERGE]>;
    get mainThread(): ThreadFacade<DATA, any, ACTIONS>;
    get asyncState(): ConanState<MonitorInfo, MonitorActions>;
    get metaFlow(): ConanFlow<MetaStatuses, MetaMutators>;
    static combine<T extends {}, ACTIONS = void>(name: string, fromState: {
        [KEY in keyof T]: ConanState<T[KEY], any>;
    }, pipeThreadDef?: PipeThreadDef<T, {}, ACTIONS>): ConanState<T, ACTIONS>;
    getEvents(): FlowEventsTracker<{
        nextData: DATA;
    }>;
    always(dataConsumer: IConsumer<DATA>): void;
    openTransaction(name?: string): void;
    closeTransaction(callback?: IConsumer<DATA>): void;
}
