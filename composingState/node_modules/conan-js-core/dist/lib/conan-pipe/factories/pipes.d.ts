import { Thread } from "../../conan-thread/logic/thread";
import { MonitorFacade } from "../../conan-monitor/domain/monitorFacade";
import { IFunction } from "../..";
import { MonitorInfo } from "../../conan-monitor/domain/monitorInfo";
import { PipeThreadDef } from "../domain/pipeThreadDef";
import { ThreadFacade } from "../../conan-thread/domain/threadFacade";
import { ITriFunction } from "../../conan-utils/typesHelper";
export declare class Pipes {
    static fromMonitor<FROM, INTO, ACTIONS = void>(name: string, monitor: MonitorFacade<FROM>, monitorMerger: (ITriFunction<MonitorInfo, FROM, INTO, INTO>), dataMerger: ITriFunction<FROM, MonitorInfo, INTO, INTO>, pipeThreadDef?: PipeThreadDef<INTO, {}, ACTIONS>): ThreadFacade<INTO, {}, ACTIONS>;
    static map<SRC, TARGET, ACTIONS = void>(name: string, src$: ThreadFacade<SRC>, mapper: IFunction<SRC, TARGET>, pipeThreadDef?: PipeThreadDef<TARGET, {}, ACTIONS>): ThreadFacade<TARGET, {}, ACTIONS>;
    static merge<LEFT, RIGHT, INTO, ACTIONS = void>(name: string, left$: Thread<LEFT>, leftMerger: (ITriFunction<LEFT, RIGHT, INTO, INTO>), right$: Thread<RIGHT>, rightMerger: (ITriFunction<RIGHT, LEFT, INTO, INTO>), pipeThreadDef?: PipeThreadDef<INTO, {}, ACTIONS>): ThreadFacade<INTO, {}, ACTIONS>;
    static tupleCombine<LEFT, RIGHT, ACTIONS = void>(name: string, left$: Thread<LEFT>, right$: Thread<RIGHT>, pipeThreadDef?: PipeThreadDef<[LEFT, RIGHT], {}, ACTIONS>): ThreadFacade<[LEFT, RIGHT], {}, ACTIONS>;
    static combine<T extends {}, ACTIONS = void>(name: string, fromState: {
        [KEY in keyof T]: ThreadFacade<T[KEY], any, any>;
    }, pipeThreadDef?: PipeThreadDef<T, {}, ACTIONS>): ThreadFacade<T, {}, ACTIONS>;
    static filter<T, ACTIONS = void>(name: string, toFilter$: ThreadFacade<T, {}, ACTIONS>, predicate: (current: T, previous: T) => boolean, pipeThreadDef?: PipeThreadDef<T, {}, ACTIONS>): ThreadFacade<T, {}, ACTIONS>;
}
