import { Objects } from "../../conan-utils/objects";
import { PipeImpl } from "../logic/pipeImpl";
import { Threads } from "../../conan-thread/factories/threads";
export class Pipes {
    static fromMonitor(monitor, monitorMerger, dataMerger, pipeThreadDef) {
        return Pipes.filter(`unique-monitor`, Pipes.merge(`pipeMonitor=>raw[${monitor.getName()}]`, monitor.asyncThread, monitorMerger, monitor.mainThread, dataMerger, pipeThreadDef), (current, previous) => !Objects.deepEquals(current, previous));
    }
    static map(name, src$, mapper, pipeThreadDef) {
        return new PipeImpl(name, thread => src$.addReaction({
            name: `mapper`,
            dataConsumer: (data) => thread.do.update(mapper(data))
        }), pipeThreadDef).start();
    }
    static merge(name, left$, leftMerger, right$, rightMerger, pipeThreadDef) {
        let statesHistory$ = Threads.create({ name: 'last states' });
        let leftHistory$ = Threads.create({ name: 'last states' });
        let rightHistory$ = Threads.create({ name: 'last states' });
        return new PipeImpl(name, thread => {
            thread.addReaction({
                name: `append state`,
                dataConsumer: (data) => statesHistory$.do.update(data)
            });
            [
                [left$, leftMerger, leftHistory$, rightHistory$],
                [right$, rightMerger, rightHistory$, leftHistory$],
            ].forEach(toConnect => {
                let state$ = toConnect[0];
                let mapper = toConnect[1];
                let thisHistory$ = toConnect[2];
                let oppositeHistory$ = toConnect[3];
                state$.addReaction({
                    name: `merge`,
                    dataConsumer: (data) => {
                        thisHistory$.reducers.$update(data);
                        thread.do.update(mapper(data, oppositeHistory$.getData(), statesHistory$.getData()));
                    }
                });
            });
        }, pipeThreadDef).start();
    }
    static tupleCombine(name, left$, right$, pipeThreadDef) {
        let leftHistory$ = Threads.create({ name: 'last states' });
        let rightHistory$ = Threads.create({ name: 'last states' });
        return new PipeImpl(`combineArray => [${left$.getName()}, ${right$.getName()}]`, thread => {
            thread.addReaction({
                name: name,
                dataConsumer: (data) => {
                    leftHistory$.do.update(data[0]);
                    rightHistory$.do.update(data[1]);
                }
            });
            [
                [left$, rightHistory$, 'left'],
                [right$, leftHistory$, 'right'],
            ].forEach(toProcess => {
                let state$ = toProcess[0];
                let oppositeHistory$ = toProcess[1];
                let currentlyProcessing = toProcess[2];
                state$.addReaction({
                    name: `tuple=>${currentlyProcessing}`,
                    dataConsumer: (data) => {
                        let newValue;
                        if (currentlyProcessing === 'left') {
                            let oppositeValue = oppositeHistory$.getData();
                            let thisValue = data;
                            newValue = [thisValue, oppositeValue];
                        }
                        else {
                            let oppositeValue = oppositeHistory$.getData();
                            let thisValue = data;
                            newValue = [oppositeValue, thisValue];
                        }
                        thread.do.update(newValue);
                    }
                });
            });
        }, pipeThreadDef).start();
    }
    static combine(name, fromState, pipeThreadDef) {
        return new PipeImpl(name, (thread) => Objects.foreachEntry(fromState, (threadFrom, key) => threadFrom.addReaction({
            name: `combine`,
            dataConsumer: (data) => {
                thread.reducers.$update((current) => {
                    return Object.assign(Object.assign({}, current), { [key]: data });
                });
            }
        })), pipeThreadDef).start();
    }
    static filter(name, toFilter$, predicate, pipeThreadDef) {
        let statesHistory$ = Threads.create({ name: 'last states' });
        return new PipeImpl(name, (thread) => {
            thread.addReaction({
                name: `save state`,
                dataConsumer: (data) => statesHistory$.reducers.$update(data)
            });
            toFilter$.addReaction({
                name: `pipe-filter`,
                dataConsumer: (toFilter) => {
                    let previousState = statesHistory$.getData();
                    if (predicate(toFilter, previousState)) {
                        thread.reducers.$update(toFilter);
                    }
                },
            });
        }, pipeThreadDef).start();
    }
}
//# sourceMappingURL=pipes.js.map