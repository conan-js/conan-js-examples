import { FlowThread } from "./flowThread";
import { FlowEventsTracker } from "./flowEventsTracker";
export var BindBackType;
(function (BindBackType) {
    BindBackType["STEP"] = "STEP";
    BindBackType["TRANSITION"] = "TRANSITION";
})(BindBackType || (BindBackType = {}));
export class FlowAnchor {
    createNewThread(flowController, flowOrchestrator) {
        let flowEvents = new FlowEventsTracker();
        let flowThread = new FlowThread(flowController, flowOrchestrator, flowEvents);
        this.currentThread = {
            flowEvents: flowEvents,
            flowThread: flowThread,
        };
        return flowThread;
    }
    getCurrentEvents() {
        return this.currentThread.flowEvents;
    }
    get currentStatus() {
        if (!this.currentThread)
            return undefined;
        return this.currentThread.flowEvents.currentStatus;
    }
    getStatusDataProducerFn() {
        return (statusName, defaultValue) => {
            let statusData = this.currentThread.flowEvents.getLastStates();
            if (Object.keys(statusData).indexOf(statusName) === -1) {
                return defaultValue;
            }
            return statusData[statusName];
        };
    }
    getDataFn(status) {
        return () => {
            if (this.currentThread == null) {
                throw new Error(`error getting the data function associated to this flow, this might happen if you try to mutate the state of the flow before it has been started.`);
            }
            let currentStatus = this.currentThread.flowEvents.currentStatus.name;
            if (currentStatus === '$init') {
                return undefined;
            }
            if (status !== currentStatus) {
                throw new Error(`unexpected error trying to retrieve the last status for [${status}, but the current status is [${currentStatus}]]`);
            }
            return this.currentThread.flowEvents.getLastState(status);
        };
    }
    bindBack(expectedStatusName, param, type) {
        if (!this.currentThread.flowThread.flowController.isRunning) {
            return;
        }
        let isNotGoingToStop = param.result && param.result.name != "$stop";
        let isNotCurrentlyOnInit = this.currentStatus && this.currentStatus.name != "$init";
        if (isNotGoingToStop && isNotCurrentlyOnInit && (!this.currentStatus || this.currentStatus.name !== expectedStatusName)) {
            throw Error(`unable to request [${param.methodName}] as is meant for status [${expectedStatusName}], but the current status is [${this.currentStatus ? this.currentStatus.name : '-'}]`);
        }
        if (type === BindBackType.STEP) {
            let initialStep = this.currentThread.flowThread.getCurrentStatusName() === '$init';
            if (initialStep) {
                this.currentThread.flowThread.requestTransition({
                    into: {
                        name: expectedStatusName,
                        data: param.result
                    },
                    payload: param.payload,
                    transitionName: param.methodName
                }, false);
            }
            else {
                this.currentThread.flowThread.requestStep(param.statusName, param.methodName, param.payload, param.result);
            }
        }
        else {
            this.currentThread.flowThread.requestTransition({
                into: param.result,
                payload: param.payload,
                transitionName: param.methodName
            }, false);
        }
    }
    getStatusData() {
        return this.currentThread.flowEvents.getLastStates();
    }
}
//# sourceMappingURL=flowAnchor.js.map