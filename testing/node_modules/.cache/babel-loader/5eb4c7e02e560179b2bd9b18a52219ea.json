{"ast":null,"code":"import*as React from\"react\";import{Asaps,Conan}from\"conan-js-core\";import{StatusEventType}from\"conan-js-core\";var asyncValue$=Conan.light('test-async-number-value');var numberValue$=Conan.light('test-number-value',undefined);var timesIdle$=Conan.light('timesIdle',0);numberValue$.metaFlow.toState('idle').always(function(){return timesIdle$.do.update(function(current){return++current;});});export function TestButton(_ref){var action=_ref.action,labels=_ref.labels;return/*#__PURE__*/React.createElement(\"button\",{style:{textAlign:\"left\"},onClick:action},/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"b\",null,labels[0])),/*#__PURE__*/React.createElement(\"div\",null,labels[1]));}export function TestingApp(){return/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"h1\",null,\"Testing synchronous values\"),/*#__PURE__*/React.createElement(\"p\",null,\"All you have to do is to call getData() on the Conan.State after you perform all of your synchronous operations, in conan everything that is synchronous is kept synchronous\"),/*#__PURE__*/React.createElement(TestButton,{labels:['test - success','counter$.do.update (3);'],action:function action(){numberValue$.do.update(3);}}),/*#__PURE__*/React.createElement(TestButton,{labels:['test - fail','counter$.do.update (5);'],action:function action(){numberValue$.do.update(5);}}),numberValue$.connectLive(function(value){return/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"h3\",null,\"Expected Value: 3\"),/*#__PURE__*/React.createElement(\"h3\",null,\"Actual Value: \",value),/*#__PURE__*/React.createElement(\"h3\",null,\"Result: \",value===3?'pass':'fail'));}),/*#__PURE__*/React.createElement(\"h1\",null,\"Testing asynchronous values\"),/*#__PURE__*/React.createElement(\"h2\",null,\"Chaining\"),/*#__PURE__*/React.createElement(\"p\",null,\"If you define your async actions using monitors, the return of your action would be an ASAP that you can use to test as soon as it is completed\"),/*#__PURE__*/React.createElement(TestButton,{labels:['1.5s-> (4)','counter$.do.updateAsap (Asaps.delayed(4, 1500)).then...;'],action:function action(){return numberValue$.do.updateAsap(Asaps.delayed(4,1500),'1.5s-> (4)').then(asyncValue$.do.update);}}),/*#__PURE__*/React.createElement(TestButton,{labels:['2.5s-> (3)','counter$.do.updateAsap (Asaps.delayed(3, 2500)).then...;'],action:function action(){return numberValue$.do.updateAsap(Asaps.delayed(3,2500),'2.5s-> (3)').then(asyncValue$.do.update);}}),/*#__PURE__*/React.createElement(\"h3\",null,\"updateAsap.then: Latest Async value [\",asyncValue$.connectLive(function(data){return/*#__PURE__*/React.createElement(\"span\",null,data);}),\"]\"),/*#__PURE__*/React.createElement(\"h1\",null,\"Testing - getting events\"),/*#__PURE__*/React.createElement(\"p\",null,\"You can check all events that have been raised on a Conan State by calling getEvents. To return only state events: you can pass options: eventTypes: [StatusEventType.STATE], excludeInit: true\"),/*#__PURE__*/React.createElement(\"h3\",null,\"latest values: \",numberValue$.connectLive(function(){return/*#__PURE__*/React.createElement(\"div\",null,numberValue$.getEvents().serialize({eventTypes:[StatusEventType.STATE],excludeInit:true}).map(function(it,i){return it.data!=null?it.data:'[undefined]';}).join(', '));})),/*#__PURE__*/React.createElement(\"h3\",null,\"async state: \",numberValue$.asyncState.connectLive(function(data){var asyncOps=data.inProgressActions.map(function(it){return it.name;}).join(', ');return/*#__PURE__*/React.createElement(\"div\",null,\"current async ops: \",asyncOps);})),/*#__PURE__*/React.createElement(\"h1\",null,\"Waiting for onIdle + transactions\"),/*#__PURE__*/React.createElement(\"p\",null,\"If you need to perform many actions chained, and specially if some of them are async, it might be difficult to know when to test your state, with this in mind, you can listen to the idle state, but you will find out that in between operations, the conan state will be back to IDLE, so it would not really help to know when to run your tests (you are likely to be interested in the last idle). There is a handy method in ConanState for this: .transaction. When ran inside a transaction, only when all actions are completed including the async operation\"),/*#__PURE__*/React.createElement(TestButton,{labels:['open transaction','counter$.openTransaction();'],action:function action(){return numberValue$.openTransaction(\"test-transaction\");}}),/*#__PURE__*/React.createElement(TestButton,{labels:['close transaction','counter$.closeTransaction();'],action:function action(){return numberValue$.closeTransaction();}}),/*#__PURE__*/React.createElement(\"h3\",null,numberValue$.metaFlow.toStateAll().connectLive(function(data){return/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"div\",null,\"current status:  \",data.data.status),/*#__PURE__*/React.createElement(\"div\",null,\"transactions open: \",data.data.transactionCount));})),/*#__PURE__*/React.createElement(\"h3\",null,\"times idle: \",timesIdle$.connectLive(function(data){return/*#__PURE__*/React.createElement(\"span\",null,data);})));}","map":{"version":3,"sources":["/Users/albertoalmansa/Projects/conan-js/tmp/conan-js-examples/testing/src/app.tsx"],"names":["React","Asaps","Conan","StatusEventType","asyncValue$","light","numberValue$","undefined","timesIdle$","metaFlow","toState","always","do","update","current","TestButton","action","labels","textAlign","TestingApp","connectLive","value","updateAsap","delayed","then","data","getEvents","serialize","eventTypes","STATE","excludeInit","map","it","i","join","asyncState","asyncOps","inProgressActions","name","openTransaction","closeTransaction","toStateAll","status","transactionCount"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {Asaps, Conan, ICallback} from \"conan-js-core\";\nimport {StateEvent, StatusEventType} from \"conan-js-core\";\n\nlet asyncValue$ = Conan.light<number>(\n    'test-async-number-value',\n);\n\nlet numberValue$ = Conan.light<number>(\n    'test-number-value',\n    undefined\n);\n\nlet timesIdle$ = Conan.light<number>('timesIdle', 0);\n\nnumberValue$.metaFlow.toState('idle').always(()=>\n    timesIdle$.do.update(current=>++current)\n);\n\n\nexport interface TestButtonProps {\n    action: ICallback\n    labels: [string, string]\n}\n\nexport function TestButton({action, labels}: TestButtonProps): React.ReactElement {\n    return <button\n        style={{textAlign: \"left\"}}\n        onClick={action}\n    >\n        <div><b>{labels[0]}</b></div>\n        <div>{labels[1]}</div>\n    </button>;\n}\n\nexport function TestingApp(): React.ReactElement {\n    return (<div>\n        <h1>Testing synchronous values</h1>\n        <p>All you have to do is to call getData() on the Conan.State after you perform all of your synchronous\n            operations,\n            in conan everything that is synchronous is kept synchronous</p>\n        <TestButton\n            labels={[\n                'test - success',\n                'counter$.do.update (3);'\n            ]}\n            action={() => {\n                numberValue$.do.update(3);\n            }}\n        />\n        <TestButton\n            labels={[\n                'test - fail',\n                'counter$.do.update (5);'\n            ]}\n            action={() => {\n                numberValue$.do.update(5);\n            }}\n        />\n        {numberValue$.connectLive(value => (<div>\n            <h3>Expected Value: 3</h3>\n            <h3>Actual Value: {value}</h3>\n            <h3>Result: {\n                value === 3 ? 'pass' : 'fail'\n            }</h3>\n        </div>))}\n\n        <h1>Testing asynchronous values</h1>\n        <h2>Chaining</h2>\n        <p>If you define your async actions using monitors, the return of your action would be an ASAP that you can use\n        to test as soon as it is completed</p>\n        <TestButton\n            labels={[\n                '1.5s-> (4)',\n                'counter$.do.updateAsap (Asaps.delayed(4, 1500)).then...;'\n            ]}\n            action={() => numberValue$.do.updateAsap(\n                Asaps.delayed(4, 1500),\n                '1.5s-> (4)'\n            ).then(asyncValue$.do.update)}\n        />\n        <TestButton\n            labels={[\n                '2.5s-> (3)',\n                'counter$.do.updateAsap (Asaps.delayed(3, 2500)).then...;'\n            ]}\n            action={() => numberValue$.do.updateAsap(\n                Asaps.delayed(3, 2500),\n                '2.5s-> (3)'\n            ).then(asyncValue$.do.update)}\n        />\n\n        <h3>updateAsap.then: Latest Async value [{asyncValue$.connectLive(data=>(<span>{data}</span>))}]</h3>\n\n        <h1>Testing - getting events</h1>\n        <p>You can check all events that have been raised on a Conan State by calling getEvents. To return only state\n            events:\n            you can pass options: eventTypes: [StatusEventType.STATE], excludeInit: true</p>\n        <h3>latest values: {numberValue$.connectLive(() => (<div>\n            {numberValue$.getEvents().serialize({\n                eventTypes: [StatusEventType.STATE],\n                excludeInit: true,\n            })\n                .map((it: StateEvent, i) => it.data != null ? it.data : '[undefined]')\n                .join(', ')\n            }\n        </div>))}\n        </h3>\n\n        <h3>async state: {numberValue$.asyncState.connectLive((data)=> {\n            let asyncOps = data.inProgressActions.map((it) => {\n                return it.name\n            }).join(', ');\n\n            return (<div>\n                current async ops: {asyncOps}\n            </div>);\n        })}\n        </h3>\n\n\n\n        <h1>Waiting for onIdle + transactions</h1>\n        <p>If you need to perform many actions chained, and specially if some of them are async, it might be difficult to\n        know when to test your state, with this in mind, you can listen to the idle state, but you will find out that\n        in between operations, the conan state will be back to IDLE, so it would not really help to know when to run your tests\n        (you are likely to be interested in the last idle).\n\n        There is a handy method in ConanState for this: .transaction. When ran inside a transaction, only when all actions are\n        completed including the async operation</p>\n\n        <TestButton\n            labels={[\n                'open transaction',\n                'counter$.openTransaction();'\n            ]}\n            action={() => numberValue$.openTransaction(`test-transaction`)}\n        />\n        <TestButton\n            labels={[\n                'close transaction',\n                'counter$.closeTransaction();'\n            ]}\n            action={() => numberValue$.closeTransaction()}\n        />\n\n\n\n        <h3>{numberValue$.metaFlow.toStateAll().connectLive((data)=> <div>\n            <div>current status:  {data.data.status}</div>\n            <div>transactions open: {data.data.transactionCount}</div>\n        </div>)}</h3>\n        <h3>times idle: {timesIdle$.connectLive((data)=> (<span>{data}</span>))}</h3>\n\n    </div>)\n}\n"]},"metadata":{},"sourceType":"module"}