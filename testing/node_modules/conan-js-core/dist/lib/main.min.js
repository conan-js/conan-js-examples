"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var InjectableType,React=require("react");!function(t){t.TRANSITION="TRANSITION",t.STEP="STEP",t.STATUS="STATUS",t.PROCESSING_STATUS="PROCESSING_STATUS",t.STATE="STATE",t.PROCESSING_STATE="PROCESSING_STATE"}(exports.StatusEventType||(exports.StatusEventType={}));class DynamicOrStatics{static result(t,e){return"function"==typeof t?t(e):t}}class Objects{static mapKeys(t,e,a){let n={};return Object.keys(t).forEach(r=>{let s=a?a(r):r;n[s]=e(t[r])}),n}static foreachEntry(t,e){Object.keys(t).forEach(a=>{e(t[a],a)})}static keyfy(t,e){return t.reduce((t,a)=>Object.assign(Object.assign({},t),{[e(a)]:a}),{})}static navigate(t,e){let a=[],n=t;for(;n;)null!==(n=e(n))&&a.push(n);return a}static deepEqualsArrays(t,e){if(t.length!==e.length)return!1;for(let a of t)if(-1===e.indexOf(a))return!1;return!0}static deepEqualsObjects(t,e){for(let a of Object.keys(t))if(!Objects.deepEquals(t[a],e[a]))return!1;return!0}static deepEquals(t,e){return null==t&&null==e||(null!=t||null==e)&&((null==t||null!=e)&&("string"==typeof t&&"string"==typeof e?t===e:"number"==typeof t&&"number"==typeof e?t===e:"function"==typeof t&&"function"==typeof e?t===e:"boolean"==typeof t&&"boolean"==typeof e?t===e:void 0===t&&void 0===e?t===e:Array.isArray(t)&&Array.isArray(e)?Objects.deepEqualsArrays(t,e):!(Array.isArray(t)&&!Array.isArray(e))&&(!(!Array.isArray(t)&&Array.isArray(e))&&("object"==typeof t&&"object"==typeof e?Objects.deepEqualsObjects(t,e):t===e))))}}class Strings{static firstCharToLowerCase(t){return t.substring(0,1).toLowerCase()+t.substring(1,t.length)}static firstCharToUpperCase(t){return t.substring(0,1).toUpperCase()+t.substring(1,t.length)}static camelCaseWithPrefix(t,e){return t+this.firstCharToUpperCase(e)}static repeat(t,e){let a="";for(let n=0;n<e;n++)a+=t;return a}static padEnd(t,e){if(null==t)return t;let a=e-t.length;if(a<1){let a="...",n=1,r=n+(t.length+a.length-e);return t.substring(0,n)+a+t.substring(r,t.length)}return t+" ".repeat(a)}}class DiUtils{static beanName(t){return Strings.firstCharToLowerCase(t.name)}}!function(t){t.DYNAMIC="dynamic",t.NAME="name",t.TYPE="type"}(InjectableType||(InjectableType={}));class MetadataCrudUtils{constructor(t,e){this.spaceName=t,this.defaultProvider=e}updateMetadata(t,e){let a=this.getOrCreateMetadata(t);if(null==a)throw Error("can't get or create metaData");return e(a),a}assignMetaDataToConstructor(t,e){let a=this.getPrototype(t);null==a.$a&&(a.$a={}),null==a.$a[this.spaceName]&&(a.$a[this.spaceName]={});let n=MetadataCrudUtils.extractName(t);a.$a[this.spaceName][n]=e}getAnnotationsMetaData(t){let e=t;e.$a||(e=this.getPrototype(t));let a=e.$a;if(null==a)return null;let n=a[this.spaceName];return null==n?null:n[MetadataCrudUtils.extractName(t)]}getOrCreateMetadata(t){if(null==this.getAnnotationsMetaData(t)){let e=this.defaultProvider();this.assignMetaDataToConstructor(t,e)}return this.getAnnotationsMetaData(t)}getPrototype(t){return"object"==typeof t?t:"object"==typeof t.prototype?t.prototype:this.getPrototype(Object.getPrototypeOf(t))}static extractName(t){let e=t.name;return null==e&&(e=t.constructor.name),e.substring(0,1).toLowerCase()+e.substring(1,e.length)}}let diAnnotationsCrud=new MetadataCrudUtils("$di",()=>({diAnnotations:[]}));function InjectByType(t,e){return(a,n,r)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:r,injectable:t,type:InjectableType.TYPE,cascadeProperties:e}))}}function InjectDynamic(t,e){return(a,n,r)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:r,injectable:t,type:InjectableType.DYNAMIC,cascadeProperties:e}))}}function InjectByName(t,e){return console.log("Inject by name",t),(a,n,r)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:r,injectable:t,type:InjectableType.NAME,cascadeProperties:e}))}}const STRIP_COMMENTS=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,ARGUMENT_NAMES=/([^\s,]+)/g;class Functions{static extractArgNames(t){if(0===t.length)return[];let e=t.toString().replace(STRIP_COMMENTS,""),a=e.slice(e.indexOf("(")+1,e.indexOf(")")).match(ARGUMENT_NAMES);return null===a&&(a=[]),a}}class DiAnnotationsMetadataFactory{create(t){let e=DiUtils.beanName(t),a=Functions.extractArgNames(t),n={},r=diAnnotationsCrud.getAnnotationsMetaData(t);return r&&r.diAnnotations.forEach(t=>{let e=a[t.onConstructorParamIndex];n[e]={name:e,type:t.type,payload:t.injectable,propsProvider:t.cascadeProperties}}),{dependencyName:e,argumentNames:a,diParams:n,constructor:t}}}class DiRuntime{constructor(t,e){this.diInvocationResolver=t,this.diInvocationBuilderFactory=e}invoke(t,e,a){if("object"==typeof t)return t;let n=this.diInvocationBuilderFactory.root(t).if(null!=e,t=>t.withTransitiveBeans(e)).build(),r=this.diInvocationResolver.resolve(n,a,this).result;if(null==r)throw Error("Can't invoke");return r}invokeWithProps(t,e,a,n){let r=this.diInvocationBuilderFactory.root(t).withProperties(e).if(null!=a,t=>t.withTransitiveBeans(a)).build(),s=this.diInvocationResolver.resolve(r,n,this).result;if(null==s)throw Error("Can't invoke");return s}}DiRuntime.PROPS_PROPERTY_NAME="$props";class DiInvocationResolver{constructor(t,e,a){this.diInvocationFactory=t,this.diCache=e,this.diEnricher=a}resolve(t,e,a){if(this.causesCircularDependency(t))return{circularDependencyEndOf:t.diMetadata.dependencyName,result:null,pendingDependencies:{}};let n=null,r=this.diCache.resolve(t.diMetadata.dependencyName,()=>(n=this.doCreate(t,e,a),this.diEnricher&&(n.result=this.diEnricher(t.diMetadata,n.result)),Object.keys(n.pendingDependencies).indexOf(t.diMetadata.dependencyName)>-1&&n.pendingDependencies[t.diMetadata.dependencyName].forEach(e=>{this.diCache.resolve(e,null)[t.diMetadata.dependencyName]=n.result}),n.result));return null==n?{result:r,pendingDependencies:{}}:n}causesCircularDependency(t){return t.inProcessDiInvocations.indexOf(t.diMetadata.dependencyName)>-1}doCreate(t,e,a){const n=(t,e)=>{let a=t.diMetadata.constructor;return a.prototype&&a.prototype.constructor.name?e?new a(...e):new a:e?a(...e):a()};if(0===t.diMetadata.argumentNames.length){return{result:n(t,void 0),pendingDependencies:{}}}let r=[],s={};return this.invokeChildren(t,e,a).forEach(e=>{r.push(e.result),null!=e.circularDependencyEndOf&&DiInvocationResolver.addValueToKeyValuePairs(s,e.circularDependencyEndOf,t.diMetadata.dependencyName),e.pendingDependencies&&Object.keys(e.pendingDependencies).forEach(t=>{DiInvocationResolver.addValuesToKeyValuePairs(s,t,e.pendingDependencies[t])})}),{result:n(t,r),pendingDependencies:s}}static addValueToKeyValuePairs(t,e,a){t[e]||(t[e]=[]),t[e].indexOf(a)>-1||t[e].push(a)}static addValuesToKeyValuePairs(t,e,a){t[e]?a.forEach(a=>DiInvocationResolver.addValueToKeyValuePairs(t,e,a)):t[e]=a}invokeChildren(t,e,a){let n=[];return t.diMetadata.argumentNames.forEach(r=>{let s=this.resolveParamDef(t,r);n.push(this.invokeChild(t,s,e,a))}),n}resolveParamDef(t,e){let a=t.diMetadata.diParams[e];return null==a?{name:e,propsProvider:null,payload:e,type:InjectableType.NAME}:a}invokeChild(t,e,a,n){return e.name===DiRuntime.PROPS_PROPERTY_NAME?this.resolveChildProps(t):e.type===InjectableType.TYPE?this.resolveChildByType(t,e,a,n):e.type===InjectableType.DYNAMIC?this.resolveDynamicChild(t,e,a,n):this.resolveChildByName(t,e,a,n)}resolveChildProps(t){if(null==t.properties)throw Error("can't resolve properties for $props - There are no properties passed to the beanRuntime");return{result:t.properties,pendingDependencies:{}}}resolveChildByType(t,e,a,n){return this.resolve(this.diInvocationFactory.childrenOf(t,e.payload,e.propsProvider),a,n)}resolveDynamicChild(t,e,a,n){return this.resolveChildByType(t,{payload:e.payload(),type:InjectableType.TYPE,propsProvider:e.propsProvider,name:e.name},a,n)}resolveChildByName(t,e,a,n){let r=e.payload;if(null==t.transitiveBeans||null==t.transitiveBeans[r]){if(null!=a[r]){return{result:n.invoke(a[r],t.transitiveBeans,a),pendingDependencies:{}}}throw Error(`can't resolve param '${r}' - There are no transitive beans passed into the runtime`)}return{result:t.transitiveBeans[r],pendingDependencies:{}}}}class DiInvocationBuilderFactory{constructor(t){this.diAnnotationsMetadataFactory=t}childrenOf(t,e,a){let n=t.inProcessDiInvocations.slice(0);return n.push(t.diMetadata.dependencyName),new DiInvocationBuilder(this.diAnnotationsMetadataFactory,e).withInProcessDiInvocations(n).withTransitiveBeans(t.transitiveBeans).if(null!=a,t=>t.withProperties(a()))}root(t){return new DiInvocationBuilder(this.diAnnotationsMetadataFactory,t)}}class DiInvocationFactory{constructor(t){this.diInvocationBuilderFactory=t}childrenOf(t,e,a){return this.diInvocationBuilderFactory.childrenOf(t,e,a).build()}}class DiInvocationBuilder{constructor(t,e){this.diAnnotationsMetadataFactory=t,this._constructor=e,this.inProcessDiInvocations=[],this.transitiveBeans={},this.properties=null}if(t,e){return t&&e(this),this}withInProcessDiInvocations(t){return this.inProcessDiInvocations=t,this}withTransitiveBeans(t){return this.transitiveBeans=t,this}withProperties(t){return this.properties=t,this}build(){return{diMetadata:this.diAnnotationsMetadataFactory.create(this._constructor),inProcessDiInvocations:this.inProcessDiInvocations,transitiveBeans:this.transitiveBeans,properties:this.properties}}}class KeyValueCache{constructor(){this.cache={}}resolve(t,e){if(this.cache[t])return this.cache[t];if(null==e)throw Error("Can't resolve cache");let a=e();return this.cache[t]=a,a}}class DiRuntimeFactory{static create(t){return new DiRuntime(DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER(new KeyValueCache,t||null),DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY)}}DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY=new DiInvocationBuilderFactory(new DiAnnotationsMetadataFactory),DiRuntimeFactory.cacheTBR=(()=>new KeyValueCache),DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER=((t,e)=>new DiInvocationResolver(new DiInvocationFactory(DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY),DiRuntimeFactory.cacheTBR(),e));class DiContextFactory{static createContext(t,e){let a,n=DiRuntimeFactory.create(),r=Object.assign(Object.assign({},t),e);a=e?[...Object.keys(t),...Object.keys(e)]:Object.keys(t);let s={},i=Object.assign(Object.assign({},t),e);return a.forEach(t=>{let e=r[t];s[t]=n.invoke(e,s,i)}),s}}!function(t){t.IDLE="IDLE",t.ASYNC_START="ASYNC_START",t.ASYNC_FULFILLED="ASYNC_FULFILLED",t.ASYNC_CANCELLED="ASYNC_CANCELLED"}(exports.MonitorStatus||(exports.MonitorStatus={}));const ReactStateContext=React.createContext(null);class StateMapConnect extends React.Component{constructor(t){super(t),this._isMounted=!1,this.lastMonitorInfo=void 0,this.lastState=void 0;let e=!0,a=this.props.into.prototype?this.props.into.prototype:this.props.into.name;this._mainDataReactionLock=this.props.from.addDataReaction({name:`connect | ${a}`,dataConsumer:t=>{this.lastState=t;let a=this.props.mapper(t,Object.assign({},this.props.from.actions),this.lastMonitorInfo);this._isMounted?this.setState(a):(e=!1,this.state=a)}}),this._asyncDataReactionLock=this.props.from.addAsyncReaction({name:`connect monitor| ${a}`,dataConsumer:t=>{this.lastMonitorInfo=t;let a=this.props.mapper(this.lastState,Object.assign({},this.props.from.actions),t);this._isMounted?this.setState(a):(e=!1,this.state=a)}}),e&&this.props.fallbackValue&&(this.state=this.props.fallbackValue(this.props.from.actions))}componentDidMount(){this._isMounted=!0}componentWillUnmount(){this._isMounted=!1,this._mainDataReactionLock.release(),this._asyncDataReactionLock&&this._asyncDataReactionLock.release()}render(){let t=this.props.into;return React.createElement(ReactStateContext.Provider,{value:this.props.from},React.createElement(t,Object.assign({},this.state)))}}const StateConnect=t=>React.createElement(StateMapConnect,{mapper:(t,e,a)=>({data:t,actions:e,monitorInfo:a}),into:t.into,from:t.from,fallbackValue:e=>({data:t.fallbackValue,actions:e,monitorInfo:{status:exports.MonitorStatus.IDLE}})}),stateConnect=(t,e,a)=>React.createElement(StateConnect,{from:t,into:e,fallbackValue:a}),stateMapConnect=(t,e,a,n)=>React.createElement(StateMapConnect,{from:t,into:e,fallbackValue:n,mapper:a});function useFlow(t,e,a){React.useEffect(()=>{t.reactOnStatusChanged(t=>{e(e=>a?a(t,e):t.name)})},[])}function useFlowStatus(t,e,a,n){React.useEffect(()=>{t.alwaysOn(e,t=>{a(e=>n?n(t.getData(),e):t.getData())})},[])}function useConanState(t,e){let a=t.getData();const[n,r]=React.useState(null==a?e:a);return React.useEffect(()=>{const e=t.addDataReaction({dataConsumer:r,name:`useConanState[${t.getName()}]`});return()=>e.release()},[]),[n,t.actions,({children:e})=>React.createElement(ReactStateContext.Provider,{value:t},e)]}function useContextConanState(){let t=useConanState(React.useContext(ReactStateContext));return[t[0],t[1]]}class ContextStateMapConnect extends React.Component{render(){return React.createElement(ReactStateContext.Consumer,null,t=>{if(null==t)throw new Error("trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?");return React.createElement(StateMapConnect,{from:t,into:this.props.into,mapper:this.props.mapper,fallbackValue:this.props.fallbackValue})})}}class ContextStateConnect extends React.Component{render(){return React.createElement(ReactStateContext.Consumer,null,t=>{if(null==t)throw new Error("trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?");return React.createElement(StateConnect,{from:t,into:this.props.into,fallbackValue:this.props.fallbackValue})})}}const contextStateConnect=(t,e)=>React.createElement(ContextStateConnect,{into:t,fallbackValue:e}),contextStateMapConnect=(t,e,a)=>React.createElement(ContextStateMapConnect,{into:t,fallbackValue:a,mapper:e}),ContextStateLive=t=>{return React.createElement(ContextStateConnect,{into:e=>t.renderer(e.data,e.actions),fallbackValue:t.fallbackValue})},StateLive=t=>{return React.createElement(StateConnect,{from:t.from,into:e=>{let a=t.renderer(e.data,e.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:t.fallbackValue})},contextStateLive=(t,e)=>{return React.createElement(ContextStateConnect,{into:e=>{let a=t(e.data,e.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:e})},stateLive=(t,e,a)=>{return React.createElement(StateConnect,{from:t,into:t=>{let a=e(t.data,t.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:a})};var ReactionType,FlowEventNature,FlowEventSource,FlowEventLevel,FlowEventTiming,FlowEventType,BindBackType;!function(t){t.ONCE="ONCE",t.ALWAYS="ALWAYS"}(ReactionType||(ReactionType={}));class ThreadImpl{constructor(t,e){this.flow=t,this.def=e}start(t){return this.flow.start(t?{name:"nextData",data:t}:void 0),this}next(t){this.flow.onceOn("nextData",t)}stop(t){this.flow.stop(t)}chain(t,e){return this.flow.chainInto("nextData","nextData",t,e).map(t=>t.getData())}monitor(t,e,a,n){let r=t.map(t=>a=>e(t,a)),s={payload:n,name:null==a?"anonymous":a,action:r};return this.flow.deferInto("nextData","nextData",s).map(t=>t.getData())}get isRunning(){return this.flow.isRunning}get reducers(){return this.flow.on("nextData").steps}addReaction(t){let e={name:t.name,reactionType:ReactionType.ALWAYS,action:e=>t.dataConsumer(e.getData())};return this.flow.addReaction("nextData",e),{release:()=>{this.flow.removeReaction("nextData",e)}}}getData(){return this.flow.getStatusData().nextData}getEvents(){return this.flow.getEvents()}getName(){return this.flow.getName()}changeLoggingNature(t){this.flow.changeLoggingNature(t)}log(t){this.flow.log(t)}once(t,e){return this.flow.onceOn("nextData",e=>t(e.getData()),e),this}createRuntimeTracker(t,e){return this.flow.createRuntimeTracker(t,e)}addReactionNext(t){return this.flow.addReactionNext(this.flow.on("nextData"),{name:t.name,reactionType:ReactionType.ALWAYS,action:e=>t.dataConsumer(e.getData())}),this}getDefinition(){return this.def}}class StatusLikeParser{static parse(t){return"string"==typeof t?{name:t}:t}}class FlowRequest{constructor(t,e,a,n){this.flowThread=t,this.id=e,this.status=a,this.isStep=n,this.queuedReactions=[],this.queuedTransitions=[],this.queuedSteps=[],this.queuedStatuses=[],this.queuedStates=[],this.started=!1,this.processingStatus={id:this.id,status:this.status}}static statusRequest(t,e,a,n){return new FlowRequest(t,e,a,n)}static transitionRequest(t,e,a,n){return new FlowRequest(t,e,StatusLikeParser.parse(a.into),n)}start(){if(this.started)throw new Error("unexpected");this.started=!0,this.flowThread.processStateAndReactions(this.processingStatus,this.isStep),this.flowThread.flagAsSettled(this.processingStatus,this.isStep),this.flowThread.onStateRequestCompleted(this,this.queuedReactions,this.queuedStatuses,this.queuedStates,this.queuedTransitions,this.queuedSteps)}queueStatus(t){this.queuedStatuses.push(t)}queueTransition(t){return this.queuedTransitions.push(t),this}queueStep(t){return this.queuedSteps.push(t),this}queueState(t){this.queuedStates.push(t)}queueReaction(t,e){this.queuedReactions.push([t,e])}}!function(t){t.MAIN="MAIN",t.META="META",t.HELPER="HELPER",t.ASYNC="ASYNC",t.AUX="AUX",t.ASAP="ASAP"}(FlowEventNature||(FlowEventNature={})),function(t){t.FLOW_CONTROLLER="FLOW_CONTROLLER",t.FLOW_THREAD="FLOW_THREAD",t.CONTEXT="CONTEXT",t.USER_MSG="USER_MSG",t.FLOW_FACTORY="FLOW_FACTORY"}(FlowEventSource||(FlowEventSource={})),function(t){t.DEBUG="DEBUG",t.TRACE="TRACE",t.INFO="INFO",t.MILESTONE="MILESTONE",t.WARN="WARN",t.ERROR="ERROR"}(FlowEventLevel||(FlowEventLevel={})),function(t){t.CONTINUE="CONTINUE",t.START="START",t.END="END",t.CANCEL="CANCEL",t.IN_PROCESS="IN_PROCESS"}(FlowEventTiming||(FlowEventTiming={})),function(t){t.MONITORING="MONITORING",t.PROCESSING_REACTIONS="PROCESSING_REACTIONS",t.STARTING="STARTING",t.ONCE_ON="ONCE_ON",t.RUN_IF="RUN_IF",t.RUN="RUN",t.ADDING_REACTION="ADDING_REACTION",t.ERROR_USER_CODE="ERROR_USER_CODE",t.MONITOR_TRANSACTION="MONITOR_TRANSACTION",t.REQUESTING_STATUS="REQUESTING_STATUS",t.SETTLING_STATUS="SETTLING_STATUS",t.PROCESSING_STATUS="PROCESSING_STATUS",t.STATUS_REQUEST_COMPLETED="STATUS_REQUEST_COMPLETED",t.REQUESTING_TRANSITION="REQUESTING_TRANSITION",t.ROOT_REQUEST="ROOT_REQUEST",t.CREATING="CREATING",t.USER_REACTIONS="USER_REACTIONS",t.USER_CODE="USER_CODE"}(FlowEventType||(FlowEventType={}));class FlowThread{constructor(t,e,a){this.flowController=t,this.flowOrchestrator=e,this.flowEvents=a,this.ids={},this.requestStack=[]}requestStatus(t,e){let a=StatusLikeParser.parse(t),n=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.REQUESTING_STATUS,t).start(`${a.name}`);if(this.assertValidStatus(a.name),null!=this.currentRequest)return void(e?(n.debug(`queueing state [${a.name}]`),this.currentRequest.queueState(a)):(n.debug(`queueing status [${a.name}]`),this.currentRequest.queueStatus(a)));let r=this.getNextId(a);this.currentRequest=FlowRequest.statusRequest(this,r+"",a,e),this.currentRequest.start(),n.end()}requestTransition(t,e){let a=StatusLikeParser.parse(t.into).name,n=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.REQUESTING_TRANSITION,t).start(`${t.transitionName}`);if(n.info(e?"step":"transition",[t.transitionName,t.payload]),this.assertValidStatus(a),null!=this.currentRequest)return void(e?(n.debug(`queueing step [${t.transitionName}]`),this.currentRequest.queueStep(t)):(n.debug(`queueing transition [${t.transitionName}]`),this.currentRequest.queueTransition(t)));let r=this.getNextId(StatusLikeParser.parse(t.into));this.currentRequest=FlowRequest.transitionRequest(this,r+"",t,e),this.onTransitionRequested(t,e),this.currentRequest.start(),n.end()}requestStep(t,e,a,n){this.assertValidStatus(t);let r=this.getCurrentStatusName();if(r!==t)throw new Error(`car't request step on [${t}] as the current status is[${r}]`);this.requestTransition({transitionName:e,payload:a,into:{name:t,data:n}},!0)}requestState(t,e){this.assertValidStatus(t);let a=this.getCurrentStatusName();if(a!==t)throw new Error(`car't request state on [${t}] as the current status is[${a}]`);this.requestStatus({name:t,data:e},!0)}tryToQueue(t,e){return null!=this.currentRequest&&(this.currentRequest.queueReaction(t,e),!0)}onTransitionRequested(t,e){this.flowEvents.addTransition(t,e)}getNextId(t,e=!1){null==this.ids[t.name]&&(this.ids[t.name]=0);let a=this.ids[t.name]+1;return e?a:(this.ids[t.name]=a,this.ids[t.name])}processStateAndReactions(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.PROCESSING_STATUS).start(`${t.status.name}`);a.info(`processing status - ${t.status.name}`,this.flowController.flowDef.nature===FlowEventNature.MAIN?t.status.data:void 0),this.flowEvents.addProcessingStatus(t,e),a.end(),this.flowController.processReactions(t.status.name)}flagAsSettled(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.SETTLING_STATUS).start(`${t.status.name}`);this.flowEvents.settleProcessingStatus(t,e);let n=this.flowController.flowDef.nature!==FlowEventNature.ASYNC?t.status.data:t.status.data?t.status.data.status:void 0;e?a.milestone("STATE",n):a.milestone(`STATUS - ${t.status.name}`,n),a.end()}onStateRequestCompleted(t,e,a,n,r,s){let i=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.STATUS_REQUEST_COMPLETED).start(`${t.status.name}`),o=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.ROOT_REQUEST);if(0===this.requestStack.length?(o.debug(`creating new execution stack: [${t.status.name}]`),o.start(`${t.status.name}`)):(o.debug(`adding to current execution stack [${this.requestStack.length}-${this.requestStack[0].status.name}]`),o.continue(`${t.status.name}`)),null==this.currentRequest)throw new Error(`can't complete the request for [${this.flowController.getName()} - ${t.status.name}] as is not flagged as currently in process`);if(this.currentRequest!=t)throw new Error(`can't complete the request for [${this.flowController.getName()} - ${t.status.name}] as it does not match [${this.currentRequest.status.name}]`);if(r.length>0&&a.length>0)throw new Error("can't have transitions and states forked at the same time!");if(this.requestStack.push(this.currentRequest),this.currentRequest=void 0,r.length>1||a.length>1)throw new Error("TBI");function u(t,e,a){i.withLevel(0===e.length?FlowEventLevel.DEBUG:FlowEventLevel.INFO,`executing ${t}: [(${e.length}) - ${e.map(a).join(",")}]`)}u("queued transitions",r,t=>t.transitionName),r.forEach(t=>this.flowController.requestTransition(t)),u("queued statuses",a,t=>t.name),a.forEach(t=>this.flowController.requestStatus(t)),u("queued states",n,t=>t.name),n.forEach(t=>this.flowController.requestState(t.name,t.data)),u("queued steps",s,t=>t.transitionName),s.forEach(t=>{let e=StatusLikeParser.parse(t.into);this.flowController.requestStep(e.name,t.transitionName,t.payload,e.data)}),u("queued reactions",e,t=>t[1].name),e.forEach(t=>this.flowController.addReaction(t[0],t[1])),this.requestStack.pop(),0===this.requestStack.length&&(o.debug(`execution stack completed: [${t.status.name}]`),o.end()),i.end()}createContext(t,e){let a=StatusLikeParser.parse(t);return{getData:this.flowController.getState.bind(this.flowController),getStatusData:this.flowController.getStatusData.bind(this.flowController),do:Object.assign(Object.assign({},this.flowController.on(a.name).transitions),this.flowController.on(a.name).steps),chain(t){e(t)},interruptFlow:()=>{this.flowController.stop()},log:t=>this.flowController.log(t)}}getCurrentStatusName(){let t=this.flowEvents.currentStatus;return null==t?void 0:t.name}getCurrentState(){let t=this.flowEvents.currentStatus;return null==t?void 0:t.data}assertValidStatus(t){if(null==this.flowController.on(t))throw new Error(`error requesting a transition into [${t}] unknown status, valid statuses are: [${Object.keys(this.flowController.getStatusDefs()).join(", ")}]`)}}class FlowEventsTracker{constructor(){this.eventsByStatus={},this.events=[]}addTransition(t,e){let a,n=StatusLikeParser.parse(t.into);a=e?{type:exports.StatusEventType.STEP,reducerName:t.transitionName,newData:n.data,reducerPayload:t.payload}:{type:exports.StatusEventType.TRANSITION,fromStatus:this.currentStatus.name,intoStatus:n,transitionName:t.transitionName,transitionPayload:t.payload},this.lastEvent=a,this.process(a)}addStateFromStatus(t){this.lastEvent=t,this.process(t)}addProcessingStatus(t,e){let a;a=e?{type:exports.StatusEventType.PROCESSING_STATE,data:t.status.data}:{type:exports.StatusEventType.PROCESSING_STATUS,status:t.status},this.currentStatus=t.status,this.lastEvent=a,this.process(a)}settleProcessingStatus(t,e){if(e){if(this.lastEvent.data!==t.status.data)throw new Error("unexpected error settling events");this.lastEvent.type=exports.StatusEventType.STATE,this.eventsByStatus[this.currentStatus.name].lastState=t.status.data}else{if(this.lastEvent.status!==t.status)throw new Error("unexpected error settling events");this.lastEvent.type=exports.StatusEventType.STATUS,this.addStateFromStatus({data:t.status.data,type:exports.StatusEventType.STATE})}}process(t){null==this.eventsByStatus[this.currentStatus.name]&&(this.eventsByStatus[this.currentStatus.name]={allEvents:[],statusName:this.currentStatus.name,lastState:void 0});let e={event:t,statusName:this.currentStatus.name};this.eventsByStatus[this.currentStatus.name].allEvents.push(e),t.type!==exports.StatusEventType.STATE&&t.type!==exports.StatusEventType.PROCESSING_STATE||(this.eventsByStatus[this.currentStatus.name].lastState=t.data),this.events.push(e)}serializeStatesWithStatus(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[exports.StatusEventType.STATE]}))}serializeStates(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[exports.StatusEventType.STATE]})).map(t=>t.event)}serializeStatuses(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[exports.StatusEventType.STATUS]})).map(t=>t.event)}serialize(t){return this.serializeWithStatusInfo(t).map(t=>t.event)}serializeWithStatusInfo(t){if(!t)return this.events;let e=[];return this.events.forEach(a=>{let n=!0;n&&(t.excludeInit&&this.eventsByStatus.$init.allEvents.indexOf(a)>-1&&(n=!1),n&&(t.excludeStop&&this.eventsByStatus.$stop&&this.eventsByStatus.$stop.allEvents.indexOf(a)>-1&&(n=!1),n&&(t.statuses&&t.statuses.forEach(t=>{n||-1===this.eventsByStatus[t].allEvents.indexOf(a)&&(n=!1)}),n&&(t.eventTypes&&-1===t.eventTypes.indexOf(a.event.type)&&(n=!1),n&&e.push(a)))))}),e}getLastStates(){let t={};return Object.keys(this.eventsByStatus).forEach(e=>{t[e]=this.eventsByStatus[e].lastState}),t}getLastState(t){let e=this.eventsByStatus[t];if(null!=e)return e.lastState}}!function(t){t.STEP="STEP",t.TRANSITION="TRANSITION"}(BindBackType||(BindBackType={}));class FlowAnchor{createNewThread(t,e){let a=new FlowEventsTracker,n=new FlowThread(t,e,a);return this.currentThread={flowEvents:a,flowThread:n},n}getCurrentEvents(){return this.currentThread.flowEvents}get currentStatus(){if(this.currentThread)return this.currentThread.flowEvents.currentStatus}getStatusDataProducerFn(){return(t,e)=>{let a=null!=t?t:this.currentStatus.name,n=this.currentThread.flowEvents.getLastStates();return-1===Object.keys(n).indexOf(a)?e:n[a]}}getDataFn(t){return()=>{if(null==this.currentThread)throw new Error("error getting the data function associated to this flow, this might happen if you try to mutate the state of the flow before it has been started.");let e=this.currentThread.flowEvents.currentStatus.name;if("$init"!==e){if(t!==e)throw new Error(`unexpected error trying to retrieve the last status for [${t}, but the current status is [${e}]]`);return this.currentThread.flowEvents.getLastState(t)}}}bindBack(t,e,a){if(!this.currentThread.flowThread.flowController.isRunning)return;let n=e.result&&"$stop"!=e.result.name,r=this.currentStatus&&"$init"!=this.currentStatus.name;if(n&&r&&(!this.currentStatus||this.currentStatus.name!==t))throw Error(`unable to request [${e.methodName}] as is meant for status [${t}], but the current status is [${this.currentStatus?this.currentStatus.name:"-"}]`);if(a===BindBackType.STEP){"$init"===this.currentThread.flowThread.getCurrentStatusName()?this.currentThread.flowThread.requestTransition({into:{name:t,data:e.result},payload:e.payload,transitionName:e.methodName},!1):this.currentThread.flowThread.requestStep(e.statusName,e.methodName,e.payload,e.result)}else this.currentThread.flowThread.requestTransition({into:e.result,payload:e.payload,transitionName:e.methodName},!1)}getStatusData(){return this.currentThread.flowEvents.getLastStates()}createRuntimeTracker(t,e){let a=this.currentThread.flowThread;return a.flowOrchestrator.createRuntimeTracker(a.flowController,FlowEventSource.FLOW_CONTROLLER,t,e)}}class Proxyfier{static proxy(t,e){let a={},n=Object.getPrototypeOf(t),r="Object"===n.constructor.name?t:n;return Object.getOwnPropertyNames(r).forEach(n=>{if("constructor"===n)return;"function"==typeof r[n]&&(a[n]=((...a)=>{return e(()=>{return t[n](...a)},{methodName:n,payload:a})}))}),a}}class MutatorsFactory{static createDefaultStepsDef(t){return e=>({$update(a){let n,r=t.currentThread.flowThread,s=r.flowOrchestrator.createRuntimeTracker(r.flowController,FlowEventSource.CONTEXT,FlowEventType.USER_CODE,n).start();return n="function"!=typeof a?a:a(e()),s.debug("$update",n).end(),n}})}static createDefaultTransitionDef(t){return()=>({$toStatus(e){let a=StatusLikeParser.parse(e),n=t.currentThread.flowThread;return n.flowOrchestrator.createRuntimeTracker(n.flowController,FlowEventSource.CONTEXT,FlowEventType.USER_CODE,a).start().debug("$toStatus",a).end(),a}})}static createDefaultSteps(t,e){return this.createSteps(t,e,this.createDefaultStepsDef(e))}static createTransitions(t,e,a){let n=this.createDefaultTransitionDef(e);return this.doCreateTransitions(t,e,a?[a,n]:[n])}static createSteps(t,e,a){let n=this.createDefaultStepsDef(e);return this.doCreateSteps(t,e,a?[a,n]:[n])}static doCreateSteps(t,e,a){let n=e.getDataFn(t),r={};return a.forEach(t=>{let e=t(n);r=Object.assign(Object.assign({},r),e)}),this.bindToAnchor(t,e,r,BindBackType.STEP)}static doCreateTransitions(t,e,a){let n=e.getStatusDataProducerFn(),r={};return a.forEach(t=>{let e=t(n);r=Object.assign(Object.assign({},r),e)}),this.bindToAnchor(t,e,r,BindBackType.TRANSITION)}static bindToAnchor(t,e,a,n){return Proxyfier.proxy(a,(a,r)=>{let s=e.currentThread.flowThread.flowController,i=e.currentThread.flowThread.flowOrchestrator.createRuntimeTracker(s,FlowEventSource.CONTEXT,FlowEventType.USER_REACTIONS,s.flowDef.nature).start(),o=s.flowDef.nature===FlowEventNature.MAIN&&"$update"!==r.methodName?FlowEventLevel.MILESTONE:FlowEventLevel.DEBUG;i.withLevel(o,`calling: ${r.methodName}`,"object"==typeof r.payload?r.payload:"[reducer]");try{let s=a();return e.bindBack(t,{statusName:e.currentStatus.name,methodName:r.methodName,payload:r.payload,result:s},n),i.end(),s}catch(t){return void e.createRuntimeTracker(FlowEventType.ERROR_USER_CODE,t).start().milestone(`error running ${r.methodName}`,t).end()}})}}const $INIT="$init",$STOP="$stop";class ReactionDefLikeParser{static parse(t,e,a){return"object"==typeof t?t:{name:a||"anonymous",reactionType:e,action:t}}}class FlowDefFactory{static create(t,e){let a=FlowDefFactory.statusesByName(t.statuses,e);return a[$INIT]={name:$INIT,steps:MutatorsFactory.createDefaultSteps($INIT,e),transitions:MutatorsFactory.createTransitions($INIT,e),reactions:t.$onInit?t.$onInit.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,"on init")):[]},a[$STOP]={name:$STOP,steps:MutatorsFactory.createDefaultSteps($STOP,e),transitions:MutatorsFactory.createTransitions($STOP,e),reactions:t.$onStop?t.$onStop.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,"on stop")):[]},Object.assign(Object.assign({statusesByStatusName:a,name:t.name,nature:t.nature?t.nature:FlowEventNature.MAIN},t.hasOwnProperty("initialStatus")?{starter:()=>t.initialStatus}:void 0),t.hasOwnProperty("loggingRule")?{loggingRule:t.loggingRule}:void 0)}static statusesByName(t,e){let a={};return Array.isArray(t)?t.forEach(t=>{a[t]={name:t,steps:[],reactions:[]}}):Objects.foreachEntry(t,(t,n)=>{a[n]={name:n,steps:MutatorsFactory.createSteps(n,e,t.steps),transitions:MutatorsFactory.createTransitions(n,e,t.transitions),reactions:t.reactions?t.reactions.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,`on[${n}]`)):[],getLastData:e.getDataFn(n)}}),a}}class FlowRuntimeTracker{constructor(t,e){this.orchestrator=t,this.event=e}end(t,e){return this.doTick(FlowEventLevel.TRACE,FlowEventTiming.END,t,e)}cancel(t,e){return this.doTick(FlowEventLevel.TRACE,FlowEventTiming.CANCEL,t,e)}continue(t,e){return this.doTick(FlowEventLevel.TRACE,FlowEventTiming.CONTINUE,t,e)}start(t,e){return this.doTick(FlowEventLevel.TRACE,FlowEventTiming.START,t,e)}debug(t,e){return this.doTick(FlowEventLevel.DEBUG,FlowEventTiming.IN_PROCESS,t,e)}info(t,e){return this.doTick(FlowEventLevel.INFO,FlowEventTiming.IN_PROCESS,t,e)}milestone(t,e){return this.doTick(FlowEventLevel.MILESTONE,FlowEventTiming.IN_PROCESS,t,e)}withLevel(t,e,a){return this.doTick(t,FlowEventTiming.IN_PROCESS,e,a)}fork(t,e,a,n){let r=this.orchestrator.createRuntimeTracker(this.event.flowController,this.event.source,t,n).start();r.withLevel(e,a,n),r.end()}doTick(t,e,a,n,r){let s=Object.assign(Object.assign(Object.assign(Object.assign({},this.event),null!=r?{type:r}:void 0),{shortDesc:a,timing:e,level:t}),null!=n?{payload:n}:void 0);return this.orchestrator.onRuntimeEvent(this,s),this}}class FlowOrchestrator{constructor(t){this.eventsProcessor=t}onRuntimeEvent(t,e){this.eventsProcessor.forEach(t=>t(e))}createRuntimeTracker(t,e,a,n){return new FlowRuntimeTracker(this,{flowController:t,source:e,type:a,payload:n,nature:t.flowDef.nature})}}class RuleLikeParser{static parse(t){return RuleLikeParser.isRule(t)?t:BaseRules.if("-anonymous-",t)}static isRule(t){return"test"in t}}var RuleType,LOGIC_OPERATOR;!function(t){t.COMBINED="COMBINED",t.SIMPLE="SIMPLE"}(RuleType||(RuleType={})),function(t){t.OR="OR",t.AND="AND"}(LOGIC_OPERATOR||(LOGIC_OPERATOR={}));class BaseRule{constructor(t=!1,e){this.negate=t,this.baseName=e}split(t){return[this.and(t),this.and(t.inverse())]}test(t){let e=this.doEvaluate(t);return!0===this.negate?!e:e}or(t){return BaseRules.combineOr("OR",this,t)}and(t){return BaseRules.combineAnd("AND",this,t)}get name(){return`${!0===this.negate?"!":""}${this.baseName}`}}class CombinedRule extends BaseRule{constructor(t,e,a,n=!1){super(n,t),this.rules=e,this.operator=a,this.ruleType=RuleType.COMBINED}doEvaluate(t){for(let e of this.rules){let a=e.test(t);if(!0===a&&this.operator===LOGIC_OPERATOR.OR)return!0;if(!1===a&&this.operator===LOGIC_OPERATOR.AND)return!1}return this.operator===LOGIC_OPERATOR.AND}inverse(){let t=!this.negate;return new CombinedRule(this.baseName,this.rules,this.operator,t)}get name(){return`${!0===this.negate?"!":""}${this.baseName}=[${this.rules.map(t=>t.name).join(",")}]`}}class SimpleRule extends BaseRule{constructor(t,e,a=!1){super(a,t),this.predicate=e,this.ruleType=RuleType.SIMPLE}inverse(){let t=!this.negate;return new SimpleRule(this.baseName,this.predicate,t)}doEvaluate(t){return this.predicate(t)}}class BasePredicates{static isUndefined(){return BasePredicates.compareByReference(void 0)}static isNull(){return BasePredicates.compareByReference(null)}static isNullUn(){return t=>null==t}static compareByReference(t){return e=>e===t}static isInitialised(){return t=>null!=t}}class BaseRules{static if(t,e){return new SimpleRule(t,e)}static ifNot(t,e){return new SimpleRule(t,e,!0)}static ifUndefined(){return BaseRules.if("ifUndefined",BasePredicates.isUndefined())}static ifNull(){return BaseRules.if("ifNull",BasePredicates.isNull())}static ifNullUn(){return BaseRules.if("ifNullUn",BasePredicates.isNullUn())}static ifInitialised(){return BaseRules.if("ifInitialised",BasePredicates.isInitialised())}static compareByReference(t,e){return BaseRules.if(t,BasePredicates.compareByReference(e))}static combineAnd(t,...e){let a=e.map(RuleLikeParser.parse);return new CombinedRule(t,a,LOGIC_OPERATOR.AND)}static combineOr(t,...e){return new CombinedRule(t,e.map(RuleLikeParser.parse),LOGIC_OPERATOR.OR)}static join(t,e){return BaseRules.if(`join{${e.name}`,a=>{let n=t(a);return e.test(n)})}}class FlowLogger{constructor(t){this.Rule$=t}log(t){if(!this.Rule$().test(t)){let e=t.flowController.flowDef.loggingRule;if(!e)return!1;if(!e.test(t))return!1}let e=t.flowController.getCurrentStatusName();return e=e||"<stopped>",null!=t.payload?(console.log(Strings.padEnd(`${t.type}`,30),Strings.padEnd(`${t.flowController.getName()}`,50),Strings.padEnd(`${e}`,30),Strings.padEnd(`${t.nature}`,10),Strings.padEnd(`${t.level}`,10),Strings.padEnd(`${t.timing}`,12)),null==t.payload&&null==t.shortDesc||(null!=t.shortDesc&&null!=t.payload?(console.log(`  =>${t.shortDesc}`),console.log(" ",t.payload)):null!=t.shortDesc&&null!=!t.payload?console.log(`  =>${t.shortDesc}`):console.log(`  =>${t.payload}`)),console.log("------------------------------------------------------------------------------------------------------------------------------------------------")):null!=t.shortDesc&&(console.log(Strings.padEnd(`${t.type}`,30),Strings.padEnd(`${t.flowController.getName()}`,50),Strings.padEnd(`${e}`,30),Strings.padEnd(`${t.level}`,10),Strings.padEnd(`${t.nature}`,10),Strings.padEnd(`${t.timing}`,10)),console.log(`  =>${t.shortDesc}`)),!0}}class LoggerFilters{static trace(){return BaseRules.if("ifTrace",t=>t.level===FlowEventLevel.TRACE)}static debug(){return BaseRules.if("ifDebug",t=>t.level===FlowEventLevel.DEBUG)}static milestone(){return BaseRules.if("ifMilestone",t=>t.level===FlowEventLevel.MILESTONE)}static info(){return BaseRules.if("ifInfo",t=>t.level===FlowEventLevel.INFO)}static logName(t){return BaseRules.combineOr(`main/async/meta[${t}]`,LoggerFilters.mainLogName(t),LoggerFilters.asyncLogName(t),LoggerFilters.metaLogName(t))}static mainLogName(t){return BaseRules.if(`ifLogName={${t}`,e=>e.flowController.getName()===t)}static asyncLogName(t){return BaseRules.if(`ifLogName={${t}`,e=>e.flowController.getName()===`${t}=>[async]`)}static metaLogName(t){return BaseRules.if(`ifLogName={${t}`,e=>e.flowController.getName()===`${t}=>[meta]`)}static eventType(t){return BaseRules.combineAnd(`eventType[${t}]`,LoggerFilters.trace().inverse(),BaseRules.if(`ifEventType={${t}`,e=>e.type===t))}static statusName(t){return BaseRules.if(`ifStatusName={${t}`,e=>e.flowController.getCurrentStatusName()===t)}static notInitialising(){return LoggerFilters.initialising().inverse()}static initialising(){return LoggerFilters.statusName("$init")}static nextData(){return LoggerFilters.statusName("nextData")}static aux(){return BaseRules.if("ifAux",t=>t.nature===FlowEventNature.AUX)}static async(){return BaseRules.if("ifAsync",t=>t.nature===FlowEventNature.ASYNC)}static helper(){return BaseRules.if("ifHelper",t=>t.nature===FlowEventNature.HELPER)}static main(){return BaseRules.if("ifMain",t=>t.nature===FlowEventNature.MAIN)}static all(){return BaseRules.if("all",()=>!0)}static fromInfo(){return BaseRules.combineOr("info and milestone",LoggerFilters.info(),LoggerFilters.milestone())}static allExceptTraces(){return BaseRules.combineOr("all except traces",LoggerFilters.debug(),LoggerFilters.info(),LoggerFilters.milestone())}static never(){return BaseRules.if("never",()=>!1)}static default(){return BaseRules.combineAnd("default filter",LoggerFilters.milestone(),LoggerFilters.main(),LoggerFilters.initialising().inverse())}}const FLOW_LOGGER=new FlowLogger(()=>CURRENT_LOG_FILTER.rule),CURRENT_LOG_FILTER={rule:LoggerFilters.default()};function isPromise(t){return null!=t&&("object"==typeof t&&("then"in t&&"function"==typeof t.then))}function isAsap(t){return t instanceof NowImpl||t instanceof LaterImpl}!function(t){t.NOW="NOW",t.LATER="LATER"}(exports.AsapType||(exports.AsapType={}));class NowImpl{constructor(t){this.rawValue=t,this.type=exports.AsapType.NOW}cancel(){return!1}then(t){return t(this.rawValue),this}map(t){return Asaps.now(t(this.rawValue))}chain(t){const[e,a]=Asaps.next("map",FlowEventNature.AUX);return this.then(a=>t(a).then(t=>e(t))),a}catch(t){return this}onCancel(t){return this}}class LaterImpl{constructor(t){this.flow=t,this.type=exports.AsapType.LATER}map(t){let[e,a]=Asaps.next("map",FlowEventNature.AUX);return this.then(a=>e(t(a))),this.onCancel(()=>a.cancel()),a}then(t){return"resolved"===this.flow.getCurrentStatusName()?t(this.flow.on("resolved").getLastData()):this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{then:[...e.then,t]})),this}resolve(t){if("cancelled"!==this.flow.getCurrentStatusName())try{this.flow.assertOn("resolving",e=>{e.getData().then.forEach(e=>{e(t)}),this.flow.on("resolving").transitions.$toStatus({name:"resolved",data:t})})}catch(e){console.error(e),this.flow.assertOn("resolving",a=>{a.getData().catch.forEach(a=>{a(e,t)}),a.do.$toStatus({name:"errored",data:t})})}}onCancel(t){if("cancelled"!==this.flow.getCurrentStatusName())return"resolving"===this.flow.getCurrentStatusName()&&this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{onCancel:[...e.onCancel,t]})),this;t()}cancel(){return"resolving"===this.flow.getCurrentStatusName()&&(this.flow.assertOn("resolving",t=>{t.getData().onCancel.forEach(t=>{t()}),this.flow.on("resolving").transitions.$toStatus({name:"cancelled"})}),!0)}chain(t){const[e,a]=Asaps.next("merge",FlowEventNature.AUX);return this.then(n=>t(n).then(t=>e(t)).onCancel(()=>a.cancel())).onCancel(()=>a.cancel()),a}catch(t){return"resolving"===this.flow.getCurrentStatusName()&&this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{catch:[...e.catch,t]})),this}}class ProxyThen{constructor(t,e,a){this.baseAsap=t,this.beforeThen=e,this.afterThen=a}cancel(){return this.baseAsap.cancel()}catch(t){return this.baseAsap.catch(t),this}chain(t){let e=this.baseAsap.chain(t);return Asaps.proxyThen(e,this.beforeThen,this.afterThen)}map(t){let e=this.baseAsap.map(t);return Asaps.proxyThen(e,this.beforeThen,this.afterThen)}onCancel(t){return this.baseAsap.onCancel(t),this}then(t){return this.beforeThen(),this.baseAsap.then(t),this.baseAsap.then(this.afterThen),this}get type(){return this.baseAsap.type}}class AsapParser{static from(t){return isAsap(t)?t:isPromise(t)?Asaps.fromPromise(t):Asaps.now(t)}}class Asaps{static now(t){return new NowImpl(t)}static fromPromise(t,e){let a=new LaterImpl(Flows.createController({name:`future[${e||"anonymous"}]`,statuses:{resolving:{},resolved:{},errored:{},cancelled:{}},initialStatus:{name:"resolving",data:{then:[],catch:[],onCancel:[]}},nature:FlowEventNature.ASAP}).start());return t.then(t=>a.resolve(t)),t.catch(t=>a.catch(t)),a}static delayed(t,e,a){return Asaps.fromPromise(new Promise(a=>setTimeout(()=>{a("function"==typeof t?t():t)},e)),`delay[${a||"anonymous"}]`)}static fetch(t){return Asaps.fromPromise(new Promise(e=>{fetch(t).then(t=>t.json()).then(function(t){e(t)})}),`fetch[${Strings.padEnd(t,15)}]`)}static next(t,e){let a=new LaterImpl(Flows.createController({name:`asap-${t||"anonymous"}`,statuses:{resolving:{},resolved:{},errored:{},cancelled:{}},initialStatus:{name:"resolving",data:{then:[],catch:[],onCancel:[]}},nature:e||FlowEventNature.ASAP}).start());return[t=>a.resolve(t),a]}static proxyThen(t,e,a){return new ProxyThen(t,e,a)}}function deferParser(t,e){return isAsap(t)?{action:t,name:e.name,payload:e.payload}:t}class FlowImpl{constructor(t,e,a){this.flowDef=t,this.flowAnchor=e,this.flowOrchestrator=a,this.isRunning=!1}start(t){let e=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.STARTING,t).start();if(this.isRunning)throw new Error("can't request a flow that it has been started to start again");if(this.flowThread=this.flowAnchor.createNewThread(this,this.flowOrchestrator),this.isRunning=!0,null==t&&null==this.flowDef.starter)return this.requestStatus($INIT),this;let a=t||this.flowDef.starter(),n=t=>{this.addReaction($INIT,{action:()=>{e.debug("initialStatus",t),this.requestStatus(t)},reactionType:ReactionType.ONCE,name:"to initial state"}),this.addReaction($STOP,{name:"onStop=>notifyEvents",reactionType:ReactionType.ONCE,action:t=>{t.chain(()=>{e.debug("state machine stopped"),this.flowThread=null,this.isRunning=!1})}}),this.requestStatus($INIT)};return AsapParser.from(a).then(t=>n(t)),e.end(),this}requestStatus(t){let e=StatusLikeParser.parse(t).name;if(this.isRunning){if(null==this.on(e))throw new Error(`unable to request non existing status [${e}]`);this.flowThread.requestStatus(t,!1)}}requestState(t,e){this.isRunning&&this.flowThread.requestState(t,e)}requestTransition(t){if(this.isRunning)return this.flowThread.requestTransition(t,!1),this}requestStep(t,e,a,n){this.isRunning&&this.flowThread.requestStep(t,e,a,n)}stop(t){if(!this.isRunning)throw new Error("unexpected");return this.addReaction($STOP,{name:"onStop=>notifyEvents",reactionType:ReactionType.ONCE,action:()=>{t&&t(this.flowAnchor.getCurrentEvents())}}),this.requestStatus({name:$STOP}),this}alwaysOn(t,e){return this.addReaction(t,{name:"-",reactionType:ReactionType.ALWAYS,action:e})}onceOnInit(t){return this.onceOn($INIT,t)}onceOnStop(t){return this.onceOn($STOP,t)}onceOn(t,e,a){let n=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.ONCE_ON,t).start();n.debug(`[onceOn(${t})`);let r=this.addReaction(t,{name:null!=a?a:"[userCode]",reactionType:ReactionType.ONCE,action:e});return n.end(),r}addReaction(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.ADDING_REACTION).start(),n=!0;if(this.isRunning){if(this.flowThread.tryToQueue(t,e))return a.info([`queueing reaction: ${e.name}`]),a.end(),this;this.runIf(t,{action:t=>{e.action(t),e.reactionType===ReactionType.ONCE&&(n=!1)},reactionType:e.reactionType,name:e.name})}if(n){let a=this.on(t);if(null==a)throw new Error(`unable to add reactions for unknown event [${t}]`);this.addReactionNext(a,e)}return a.end(),this}addReactionNext(t,e){return t.reactions.push(e),this}getReactions(t){let e=this.on(t);if(null==e)throw new Error(`can't getReactions for unknown status[${t}]`);return e.reactions}getCurrentStatusName(){if(void 0!=this.flowThread)return this.flowThread.getCurrentStatusName()}getEvents(){return this.flowAnchor.getCurrentEvents()}getName(){return this.flowDef.name}getState(){return this.flowThread.getCurrentState()}getStatusData(){return this.flowAnchor.getStatusData()}onInit(){return this.on($INIT)}on(t){return this.flowDef.statusesByStatusName[t]}getStatusDefs(){return this.flowDef.statusesByStatusName}removeReaction(t,e){let a=this.on(t),n=a.reactions;n&&(a.reactions=n.filter(t=>t!==e))}processReactions(t){let e,a=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.PROCESSING_REACTIONS).start(),n=this.getReactions(t),r=n.map(t=>t.name).join(",");return a.info(`ABOUT TO PROCESS: ${r}`),n.forEach(n=>{a.info(`START: ${n.name}`),n.reactionType===ReactionType.ONCE&&this.removeReaction(t,n),n.action(this.flowThread.createContext(t,t=>e=t)),a.info(`END:  ${n.name}`)}),a.info(`REACTIONS PROCESSED${r}`),e&&e(),a.end(t),this}getStateData(){throw new Error("TBI")}reactOnStatusChanged(t){return Object.keys(this.getStatusDefs()).forEach(e=>{this.addReaction(e,{name:"-",reactionType:ReactionType.ALWAYS,action:a=>t({name:e,data:a.getData()})})}),this}runIf(t,e,a){let n=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.RUN_IF,e.name).start();if(!this.isRunning)return a&&a(),void n.end();let r=this.getCurrentStatusName();if(null==r)return a&&a(),void n.end();r===t?this.doRun(e,t):a&&a(),n.end()}doRun(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.RUN,t.name).start();a.debug(`${t.name}`),t.action(this.flowThread.createContext(e,t=>t())),a.end()}assertOn(t,e){let a=this.getCurrentStatusName();if(a!==t)throw new Error(`asserting that we are on the status [${t}]. But we are currently on [${a}]`);return e&&this.onceOn(t,t=>e(t)),this}chainInto(t,e,a,n){let r=null!=n?n:`chainInto-${this.getName()}:${e}`;const[s,i]=Asaps.next(r,FlowEventNature.AUX);if(this.addReactionNext(this.on(e),{name:r,reactionType:ReactionType.ONCE,action:t=>s(t)}),"$init"!==this.getCurrentStatusName())this.assertOn(t),this.onceOn(t,t=>a(t.do),"chain-"+r);else{let t=this.getStatusDefs()[e];this.onceOn("$init",()=>a(t.steps),"chain-"+r)}return i}deferInto(t,e,a){let n=`[${this.getName()}]::${t}=>${e}`,r=deferParser(a,{name:n,payload:n}),s=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.MONITORING,{asap:r.action,name:r.name,payload:r.payload}).start();return r.action.type===exports.AsapType.LATER&&s.milestone(`START monitoring - ${r.name}`,r.payload),r.action.chain(a=>(r.action.type===exports.AsapType.LATER&&s.debug(`STOP monitoring - ${r.name}`),s.end(),this.chainInto(t,e,a))).onCancel(()=>{s.cancel()})}changeLoggingNature(t){this.flowDef.nature=t}log(t){let e=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.USER_MSG,FlowEventType.USER_CODE,t).start(),a=e.milestone(void 0,t);return e.end(),a}createRuntimeTracker(t,e){return this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,t,e)}getDefinition(){return this.flowDef}toStateAll(){let t=Threads.create({name:`${this.getName()}=>[all statuses]`});return this.reactOnStatusChanged(e=>t.do.$update(e)),t}toState(t){let e=Threads.create({name:`${this.getName()}=>[states:${t}]`});return this.alwaysOn(t,t=>e.do.$update(t.getData())),e}}class FlowFacadeImpl{constructor(t,e){this.flow=t,this.actions=e,this.do=e}addReaction(t,e){return this.flow.addReaction(t,e),this}alwaysOn(t,e){return this.flow.alwaysOn(t,e),this}assertOn(t,e){return this.flow.assertOn(t,e),this}chainInto(t,e,a,n){this.flow.chainInto(t,e,a,n)}getCurrentStatusName(){return this.flow.getCurrentStatusName()}getEvents(){return this.flow.getEvents()}getName(){return this.flow.getName()}getState(){return this.flow.getState()}getStatusData(){return this.flow.getStatusData()}on(t){return this.flow.on(t)}onceOn(t,e,a){return this.flow.onceOn(t,e,a),this}onceOnInit(t){return this.flow.onceOnInit(t),this}onceOnStop(t){return this.flow.onceOnStop(t),this}start(t){return this.flow.start(t),this}stop(t){return this.flow.stop(t),this}get isRunning(){return this.flow.isRunning}onInit(){return this.flow.onInit()}reactOnStatusChanged(t){return this.flow.reactOnStatusChanged(t),this}deferInto(t,e,a){return this.flow.deferInto(t,e,a)}removeReaction(t,e){this.flow.removeReaction(t,e)}changeLoggingNature(t){this.flow.changeLoggingNature(t)}log(t){this.flow.log(t)}createRuntimeTracker(t,e){return this.flow.createRuntimeTracker(t,e)}addReactionNext(t,e){return this.flow.addReactionNext(t,e),this}getDefinition(){return this.flow.getDefinition()}toState(t){return this.flow.toState(t)}toStateAll(){return this.flow.toStateAll()}}const FlowOrchestrator$=t=>new FlowOrchestrator([t=>FLOW_LOGGER.log(t),...t]);class Flows{static create(t){let e=this.createController(t);return this.createFacade(e,t.actions)}static createFacade(t,e){return new FlowFacadeImpl(t,e?e(t):void 0)}static createController(t){let e=new FlowAnchor,a=FlowOrchestrator$(t.pipelineListener?[t.pipelineListener]:[]),n=new FlowImpl(FlowDefFactory.create(t,e),e,a);return a.createRuntimeTracker(n,FlowEventSource.FLOW_FACTORY,FlowEventType.CREATING,t).start().end(),n}}class ThreadFacade{constructor(t,e){this.thread=t,this.actions=e}chain(t,e){this.thread.chain(t,e)}next(t){this.thread.next(t)}start(){return this.thread.start(),this}stop(t){return this.thread.stop(t),this}get do(){let t=this.reducers;return Object.assign(Object.assign({},t),this.actions)}get reducers(){return this.thread.reducers}addReaction(t){return this.thread.addReaction(t)}get isRunning(){return this.thread.isRunning}getData(){return this.thread.getData()}getEvents(){return this.thread.getEvents()}getName(){return this.thread.getName()}changeLoggingNature(t){this.thread.changeLoggingNature(t)}log(t){this.thread.log(t)}once(t,e){return this.thread.once(t,e),this}createRuntimeTracker(t,e){return this.thread.createRuntimeTracker(t,e)}monitor(t,e,a,n){return this.thread.monitor(t,e,a,n)}addReactionNext(t){return this.thread.addReactionNext(t),this}getDefinition(){return this.thread.getDefinition()}}class MethodFinder{static exists(t,e){return null!=t&&this.find(t,e).length>0}static find(t,e=""){let a=Object.getPrototypeOf(t),n="Object"===a.constructor.name?t:a;return Object.getOwnPropertyNames(n).filter(t=>t.startsWith(e))}}class Threads{static create(t,e){let a,n=Flows.createController(Object.assign(Object.assign({name:t.name,statuses:{nextData:Object.assign(Object.assign({},t.reducers?{steps:t.reducers}:void 0),t.reactions?{reactions:t.reactions}:void 0)}},t.hasOwnProperty("initialData")?{initialStatus:AsapParser.from(t.initialData).map(t=>({name:"nextData",data:t}))}:void 0),{pipelineListener:t.pipelineListener,nature:t.nature?t.nature:FlowEventNature.MAIN})),r=new ThreadImpl(n,t);if(t.actions&&t.autoBind)throw new Error("you can only use actions or autoBind. Both in conjunction is illegal");if(null!=e)a=new ThreadFacade(r,e);else if(t.autoBind){let e=[],n=Object.assign({},t.autoBind);Object.keys(r.reducers).forEach(a=>{let s=a.substring(1,a.length);MethodFinder.exists(t.autoBind,s)?(n[s]=((...e)=>t.autoBind[s](...e)),e.push(s)):n[s]=((...t)=>r.chain(e=>e[a](...t)))}),a=new ThreadFacade(r,Proxyfier.proxy(n,(t,a)=>-1===e.indexOf(a.methodName)?t():r.monitor(t(),(t,e)=>e[`$${a.methodName}`](t),a.methodName,a.payload)))}else{let e=t.actions?t.actions(r):{};Object.keys(r.reducers).forEach(t=>{let n=t.substring(1,t.length);e[n]||(e[n]=((...e)=>r.chain(a=>a[t](...e),`${a.getName()}.do.${n} ()`)))}),e.updateAsap=((t,e)=>{let a;return a="then"in t?t:t(r.getData()),r.monitor(a,(t,e)=>e.$update(t),null==e?"updateAsap":e)}),a=new ThreadFacade(r,e)}return t.cancelAutoStart||a.start(),a}}class PipeImpl{constructor(t,e,a){this.name=t,this.pipeConnector=e,this.pipeThreadDef=a}addReaction(t){return this.baseThread.addReaction(t)}chain(t){return this.baseThread.chain(t)}getData(){return this.baseThread.getData()}getEvents(){return this.baseThread.getEvents()}getName(){return this.baseThread.getName()}next(t){this.baseThread.next(t)}start(){if(null==this.baseThread){let t=Object.assign({name:this.name},this.pipeThreadDef);this.baseThread=Threads.create(t),this.pipeConnector(this.baseThread)}else this.baseThread.start();return this}stop(t){return this.baseThread.stop(void 0),this}get reducers(){return this.baseThread.reducers}get isRunning(){return this.baseThread.isRunning}get do(){return this.baseThread.do}get actions(){return this.baseThread.actions}get thread(){return this.baseThread.thread}changeLoggingNature(t){return this.baseThread.changeLoggingNature(t)}log(t){this.baseThread.log(t)}once(t,e){return this.baseThread.once(t,e),this}createRuntimeTracker(t,e){return this.baseThread.createRuntimeTracker(t,e)}monitor(t,e,a,n){return this.baseThread.monitor(t,e,a,n)}addReactionNext(t){return this.baseThread.addReactionNext(t),this}getDefinition(){return this.baseThread.getDefinition()}}class Pipes{static fromMonitor(t,e,a,n,r){return Pipes.filter(t,Pipes.merge(t,e.asyncThread,a,e.mainThread,n,r),(t,e)=>!Objects.deepEquals(t,e),{nature:FlowEventNature.AUX})}static map(t,e,a,n){return new PipeImpl(t,t=>e.addReaction({name:"mapper",dataConsumer:e=>t.do.update(a(e))}),n).start()}static merge(t,e,a,n,r,s){let i=Threads.create({name:"last states",nature:FlowEventNature.AUX}),o=Threads.create({name:"last states",nature:FlowEventNature.AUX}),u=Threads.create({name:"last states",nature:FlowEventNature.AUX});return new PipeImpl(t,t=>{t.addReaction({name:"append state",dataConsumer:t=>i.do.update(t)}),[[e,a,o,u],[n,r,u,o]].forEach(e=>{let a=e[0],n=e[1],r=e[2],s=e[3];a.addReaction({name:"merge",dataConsumer:e=>{r.reducers.$update(e),t.do.update(n(e,s.getData(),i.getData()))}})})},s).start()}static tupleCombine(t,e,a,n){let r=Threads.create({name:"last states",nature:FlowEventNature.AUX}),s=Threads.create({name:"last states",nature:FlowEventNature.AUX});return new PipeImpl(`combineArray => [${e.getName()}, ${a.getName()}]`,n=>{n.addReaction({name:t,dataConsumer:t=>{r.do.update(t[0]),s.do.update(t[1])}}),[[e,s,"left"],[a,r,"right"]].forEach(t=>{let e=t[0],a=t[1],r=t[2];e.addReaction({name:`tuple=>${r}`,dataConsumer:t=>{let e;if("left"===r){e=[t,a.getData()]}else{e=[a.getData(),t]}n.do.update(e)}})})},n).start()}static combine(t,e,a){return new PipeImpl(t,t=>Objects.foreachEntry(e,(e,a)=>e.addReaction({name:"combine",dataConsumer:e=>{t.reducers.$update(t=>Object.assign(Object.assign({},t),{[a]:e}))}})),a).start()}static filter(t,e,a,n){let r=Threads.create({name:"last states",nature:FlowEventNature.AUX});return new PipeImpl(t,t=>{t.addReaction({name:"save state",dataConsumer:t=>r.reducers.$update(t)}),e.addReaction({name:"pipe-filter",dataConsumer:e=>{let n=r.getData();a(e,n)&&t.reducers.$update(e)}})},n).start()}}class MonitorFacade{constructor(t,e){this.monitor=t,this.actions=e}start(){return this.monitor.start(),this}addAsyncReaction(t){return this.monitor.addAsyncReaction(t)}addReaction(t){return this.monitor.addReaction(t)}once(t,e){return this.monitor.once(t,e),this}get do(){return this.monitor.do}getEvents(){return this.monitor.getEvents()}getName(){return this.monitor.getName()}stop(t){this.monitor.stop(t)}getData(){return this.monitor.getData()}next(t){this.monitor.next(t)}get asyncThread(){return this.monitor.asyncThread}get mainThread(){return this.monitor.mainThread}get metaFlow(){return this.monitor.metaFlow}chain(t,e){return this.monitor.mainThread.chain(t,e)}transaction(t){return this.monitor.transaction(t)}openTransaction(t){this.monitor.openTransaction(t)}closeTransaction(t){this.monitor.closeTransaction(t)}}var MetaStatus;!function(t){t.STARTING="STARTING",t.INIT="INIT",t.RUNNING="RUNNING",t.ERROR="ERROR",t.IDLE="IDLE",t.IDLE_ON_TRANSACTION="IDLE_ON_TRANSACTION"}(MetaStatus||(MetaStatus={}));class ConanFlow{constructor(t){this.flow=t}on(t){return this.flow.on(t)}reactOnStatusChanged(t){return this.flow.reactOnStatusChanged(t),this}alwaysOn(t,e){return this.flow.alwaysOn(t,e),this}start(t){return this.flow.start(t),this}toStateAll(){let t=Conan.state({name:`${this.flow.getName()}=>[all statuses]`});return this.reactOnStatusChanged(e=>t.do.update(e)),t}toState(t){let e=Conan.light(`${this.flow.getName()}=>[states:${t}]`);return this.alwaysOn(t,t=>e.do.update(t.getData())),e}}class MonitorImpl{constructor(t,e,a){this.mainThread=t,this.asyncThread=e,this.metaFlow=a}start(){return this.mainThread.start(),this}addReaction(t){return this.mainThread.addReaction(t)}addAsyncReaction(t){return this.asyncThread.addReaction(t)}get do(){return this.mainThread.do}getEvents(){return this.mainThread.getEvents()}getName(){return this.mainThread.getName()}stop(t){this.mainThread.stop(t)}getData(){return this.mainThread.getData()}next(t){this.mainThread.next(t)}once(t,e){return this.mainThread.once(t,e),this}chain(t,e){return this.mainThread.chain(t,e)}openTransaction(t){null==this.currentTransaction&&(this.currentTransaction=this.mainThread.createRuntimeTracker(FlowEventType.MONITOR_TRANSACTION).start(),this.currentTransaction.info(`starting transaction: ${null==t?"[anonymous]":t}`))}closeTransaction(t){let e=new ConanFlow(this.metaFlow).toStateAll().map(t=>t.data),a=!1,n=!1,r=void 0;r=Pipes.tupleCombine("idleChecker",this.asyncThread,e.mainThread,{nature:FlowEventNature.AUX}).addReaction({name:"wait for both idle",dataConsumer:([e,s])=>{if(e.status===exports.MonitorStatus.IDLE&&(s.status===MetaStatus.IDLE_ON_TRANSACTION||s.status===MetaStatus.IDLE)){let e=void 0;e=this.mainThread.addReaction({name:"wait for both idle",dataConsumer:s=>{this.currentTransaction.info("finishing transaction"),this.currentTransaction.end(),this.currentTransaction=null,e?e.release():n=!0,r?r.release():a=!0,t&&t(s)}}),n&&e.release()}}}),a&&r.release()}transaction(t,e){let[a,n]=Asaps.next(`transaction[${e}]`);return this.openTransaction(),t(this.do),this.closeTransaction(t=>a(t)),n}}class MetaMutatorsFactory{static createTransitions(t,e){return{toIdle(){let e=t().transactionCount;return{name:0===e?"idle":"idleOnTransaction",data:{status:0===e?MetaStatus.IDLE:MetaStatus.IDLE_ON_TRANSACTION,transactionCount:e,lastError:t().lastError}}},toInit:()=>({name:"init",data:{status:MetaStatus.INIT,transactionCount:t().transactionCount,lastError:t().lastError}}),toRunning:()=>({name:"running",data:{status:MetaStatus.RUNNING,transactionCount:t().transactionCount,lastError:t().lastError}}),toError:e=>({name:"error",data:{status:MetaStatus.ERROR,transactionCount:t().transactionCount,lastError:e}})}}static createSteps(t){return{$onTransaction(e){let a=t();return{status:a.status,transactionCount:e===FlowEventTiming.START?++a.transactionCount:--a.transactionCount,lastError:a.lastError}}}}}class Monitors{static fromThread(t){let e=Monitors.create({name:t.getName(),initialData:t.getDefinition().initialData,nature:t.getDefinition().nature,actions:t.getDefinition().actions,autoBind:t.getDefinition().autoBind,reducers:t.getDefinition().reducers},t.actions);return t.addReaction({name:"pipe",dataConsumer:t=>e.do.$update(t)}),e}static create(t,e){let a=this.createAsyncThread(t),n=this.createMetaFlow(t.name),r=Threads.create(Object.assign(Object.assign({},t),{nature:t.nature,pipelineListener:t=>{this.orchestrate(t,a,n)}}),e),s=new MonitorImpl(r,a,n);return new MonitorFacade(s,r.actions)}static createMetaFlow(t){let e=Flows.create({name:`${t}=>[meta]`,statuses:{starting:{transitions:t=>MetaMutatorsFactory.createTransitions(t,"starting"),steps:t=>MetaMutatorsFactory.createSteps(t)},init:{transitions:t=>MetaMutatorsFactory.createTransitions(t,"init"),steps:t=>MetaMutatorsFactory.createSteps(t)},running:{transitions:t=>MetaMutatorsFactory.createTransitions(t,"running"),steps:t=>MetaMutatorsFactory.createSteps(t)},idle:{transitions:t=>MetaMutatorsFactory.createTransitions(t,"idle"),steps:t=>MetaMutatorsFactory.createSteps(t)},idleOnTransaction:{transitions:t=>MetaMutatorsFactory.createTransitions(t,"idleOnTransaction"),steps:t=>MetaMutatorsFactory.createSteps(t)},error:{transitions:t=>MetaMutatorsFactory.createTransitions(t,"error"),steps:t=>MetaMutatorsFactory.createSteps(t)}},initialStatus:{name:"starting",data:{status:MetaStatus.STARTING,transactionCount:0}},nature:FlowEventNature.META});return e.start(),e}static createAsyncThread(t){return Threads.create({name:`${t.name}=>[async]`,actions:t=>({tick(e){t.reducers.$update(t=>({status:exports.MonitorStatus.ASYNC_START,currentAction:e,inProgressActions:[...t.inProgressActions,e]}))},unTick(e,a){t.reducers.$update(t=>({status:a?exports.MonitorStatus.ASYNC_CANCELLED:exports.MonitorStatus.ASYNC_FULFILLED,currentAction:e,inProgressActions:t.inProgressActions.filter(t=>t!==e)})),0===t.getData().inProgressActions.length&&t.reducers.$update(t=>({inProgressActions:[],currentAction:void 0,status:exports.MonitorStatus.IDLE}))}}),initialData:{inProgressActions:[],status:exports.MonitorStatus.IDLE,currentAction:void 0},nature:FlowEventNature.ASYNC})}static orchestrate(t,e,a){let n=t.timing;if(t.type===FlowEventType.ERROR_USER_CODE&&a.assertOn(a.getCurrentStatusName(),t=>t.do.toError()),t.type!==FlowEventType.MONITORING){if(t.type===FlowEventType.MONITOR_TRANSACTION&&(n===FlowEventTiming.START||n===FlowEventTiming.END))switch(a.getCurrentStatusName()){case"starting":a.assertOn("starting",t=>t.do.$onTransaction(n));break;case"init":a.assertOn("init",t=>t.do.$onTransaction(n));break;case"running":a.assertOn("running",t=>t.do.$onTransaction(n));break;case"idle":a.assertOn("idle",t=>t.do.$onTransaction(n));break;case"idleOnTransaction":a.assertOn("idleOnTransaction",t=>{t.do.$onTransaction(n),0===t.getData().transactionCount&&n===FlowEventTiming.END&&t.do.toIdle()})}if(t.type===FlowEventType.ROOT_REQUEST)if(n===FlowEventTiming.START||n===FlowEventTiming.CONTINUE){if("$init"===t.flowController.getCurrentStatusName())return;switch(a.getCurrentStatusName()){case"idle":a.assertOn("idle",t=>t.do.toRunning());break;case"idleOnTransaction":a.assertOn("idleOnTransaction",t=>t.do.toRunning());break;case"init":a.assertOn("init",t=>t.do.toRunning())}}else if(n===FlowEventTiming.END)switch(a.getCurrentStatusName()){case"starting":a.assertOn("starting",t=>t.do.toInit());break;case"init":a.assertOn("init",t=>t.do.toIdle());break;case"running":e.getData().status===exports.MonitorStatus.IDLE&&a.assertOn("running",t=>t.do.toIdle());break;case"idleOnTransaction":e.getData().status===exports.MonitorStatus.IDLE&&a.assertOn("idleOnTransaction",t=>t.do.toIdle())}}else n===FlowEventTiming.START?(e.do.tick(t.payload),a.assertOn(a.getCurrentStatusName(),t=>t.do.toRunning())):n===FlowEventTiming.END?e.do.unTick(t.payload,!1):n===FlowEventTiming.CANCEL&&e.do.unTick(t.payload,!0)}}class ConanState{constructor(t){this.monitor=t}getName(){return this.monitor.getName()}connectMap(t,e){return React.createElement(StateMapConnect,{from:this,into:t,mapper:e})}connectData(t){return React.createElement(StateMapConnect,{from:this,into:t,mapper:t=>t})}connect(t){return React.createElement(StateConnect,{from:this,into:t})}connectLive(t,e){return React.createElement(StateLive,{from:this,renderer:t,fallbackValue:e})}addAsyncReaction(t){return this.monitor.addAsyncReaction(t)}addDataReaction(t){return this.monitor.addReaction(t)}get do(){return this.monitor.do}start(){return this.monitor.start(),this}stop(t){return this.monitor.stop(t),this}get actions(){return this.monitor.actions}getData(){return this.monitor.getData()}asyncMerge(t,e,a){let n=Pipes.fromMonitor(`monitor[${this.getName()}]`,this.monitor,e,a,{initialData:t,nature:FlowEventNature.HELPER});return new ConanState(Monitors.fromThread(new ThreadFacade(n,this.actions)))}filter(t){let e=Pipes.filter(`filter=>${this.getName()}`,this.mainThread,t);return new ConanState(Monitors.fromThread(e))}map(t){let e=Pipes.map(`map=>${this.getName()}`,this.mainThread,t);return new ConanState(Monitors.fromThread(e))}merge(t,e){let a=Pipes.merge(`merge=>${this.getName()}`,this.mainThread,e,t.mainThread,(t,a,n)=>e(a,t,n));return new ConanState(Monitors.fromThread(a))}tuple(t){let e=Pipes.tupleCombine(`mergeTuple=>${this.getName()}`,this.mainThread,t.mainThread);return new ConanState(Monitors.fromThread(e))}get mainThread(){return this.monitor.mainThread}get asyncState(){return Conan.fromThread(this.monitor.asyncThread)}get metaFlow(){return Conan.fromFlow(this.monitor.metaFlow)}static combine(t,e,a){let n=Pipes.combine(t,Objects.mapKeys(e,t=>t.mainThread),a);return new ConanState(Monitors.fromThread(n))}getEvents(){return this.mainThread.getEvents()}always(t){this.addDataReaction({name:"always",dataConsumer:e=>t(e)})}openTransaction(t){this.monitor.openTransaction(t)}closeTransaction(t){this.monitor.closeTransaction(t)}}class Conan{static light(t,e,a=FlowEventNature.MAIN){return new ConanState(Monitors.create(Object.assign({name:t,initialData:e},a?{nature:a}:void 0)))}static state(t){return new ConanState(Monitors.create(t))}static fromThread(t){let e=Conan.state(t.getDefinition());return t.addReaction({name:"pipe",dataConsumer:t=>e.do.update(t)}),e}static flow(t){let e=new ConanFlow(Flows.create(t));return e.start(),e}static fromFlow(t){return new ConanFlow(t)}}class Lists{static mergeCombine(t,e,a,n){let r=[],s=!1;return r=e.map(e=>{for(let r of t)if(a(r,e))return s=!0,n(r,e);return e}),s?r:e}}exports.AsapParser=AsapParser,exports.Asaps=Asaps,exports.Conan=Conan,exports.ConanState=ConanState,exports.ContextStateConnect=ContextStateConnect,exports.ContextStateLive=ContextStateLive,exports.ContextStateMapConnect=ContextStateMapConnect,exports.DiAnnotationsMetadataFactory=DiAnnotationsMetadataFactory,exports.DiContextFactory=DiContextFactory,exports.DynamicOrStatics=DynamicOrStatics,exports.Flows=Flows,exports.InjectByName=InjectByName,exports.InjectByType=InjectByType,exports.InjectDynamic=InjectDynamic,exports.Lists=Lists,exports.Objects=Objects,exports.ReactStateContext=ReactStateContext,exports.StateConnect=StateConnect,exports.StateLive=StateLive,exports.StateMapConnect=StateMapConnect,exports.contextStateConnect=contextStateConnect,exports.contextStateLive=contextStateLive,exports.contextStateMapConnect=contextStateMapConnect,exports.diAnnotationsCrud=diAnnotationsCrud,exports.isAsap=isAsap,exports.stateConnect=stateConnect,exports.stateLive=stateLive,exports.stateMapConnect=stateMapConnect,exports.useConanState=useConanState,exports.useContextConanState=useContextConanState,exports.useFlow=useFlow,exports.useFlowStatus=useFlowStatus;