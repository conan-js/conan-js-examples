import { BaseRules } from "./baseRules";
export class RuleLikeParser {
    static parse(toParse) {
        return RuleLikeParser.isRule(toParse) ? toParse : BaseRules.if('-anonymous-', toParse);
    }
    static isRule(toParse) {
        return 'test' in toParse;
    }
}
export var RuleType;
(function (RuleType) {
    RuleType["COMBINED"] = "COMBINED";
    RuleType["SIMPLE"] = "SIMPLE";
})(RuleType || (RuleType = {}));
export var LOGIC_OPERATOR;
(function (LOGIC_OPERATOR) {
    LOGIC_OPERATOR["OR"] = "OR";
    LOGIC_OPERATOR["AND"] = "AND";
})(LOGIC_OPERATOR || (LOGIC_OPERATOR = {}));
export class BaseRule {
    constructor(negate = false, baseName) {
        this.negate = negate;
        this.baseName = baseName;
    }
    split(additionalRule) {
        return [
            this.and(additionalRule),
            this.and(additionalRule.inverse()),
        ];
    }
    test(value) {
        let result = this.doEvaluate(value);
        return this.negate === true ? !result : result;
    }
    or(rule) {
        return BaseRules.combineOr(`OR`, this, rule);
    }
    and(rule) {
        return BaseRules.combineAnd(`AND`, this, rule);
    }
    get name() {
        return `${this.negate === true ? '!' : ''}${this.baseName}`;
    }
}
export class CombinedRule extends BaseRule {
    constructor(name, rules, operator, negate = false) {
        super(negate, name);
        this.rules = rules;
        this.operator = operator;
        this.ruleType = RuleType.COMBINED;
    }
    doEvaluate(value) {
        for (let rule of this.rules) {
            let partial = rule.test(value);
            if (partial === true && this.operator === LOGIC_OPERATOR.OR) {
                return true;
            }
            if (partial === false && this.operator === LOGIC_OPERATOR.AND) {
                return false;
            }
        }
        return this.operator === LOGIC_OPERATOR.AND;
    }
    inverse() {
        let newNegatedValue = !this.negate;
        return new CombinedRule(this.baseName, this.rules, this.operator, newNegatedValue);
    }
    get name() {
        return `${this.negate === true ? '!' : ''}${this.baseName}=[${this.rules.map(it => it.name).join(',')}]`;
    }
}
export class SimpleRule extends BaseRule {
    constructor(name, predicate, negate = false) {
        super(negate, name);
        this.predicate = predicate;
        this.ruleType = RuleType.SIMPLE;
    }
    inverse() {
        let newNegatedValue = !this.negate;
        return new SimpleRule(this.baseName, this.predicate, newNegatedValue);
    }
    doEvaluate(value) {
        return this.predicate(value);
    }
}
//# sourceMappingURL=_rules.js.map