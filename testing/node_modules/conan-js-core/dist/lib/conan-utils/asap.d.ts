import { ICallback, IConsumer, IFunction, IProducer } from "./typesHelper";
import { FlowEventNature } from "../conan-flow/domain/flowRuntimeEvents";
export declare enum AsapType {
    NOW = "NOW",
    LATER = "LATER"
}
export declare type AsapLike<T> = Promise<T> | T | Asap<T>;
export interface Asap<T> {
    catch(error: IConsumer<Error>): this;
    then(consumer: IConsumer<T>): this;
    onCancel(consumer: ICallback): this;
    map<Z>(mapper: IFunction<T, Z>): Asap<Z>;
    chain<Z>(chainProducer: IFunction<T, Asap<Z>>): Asap<Z>;
    type: AsapType;
    cancel(): boolean;
}
export declare function isAsap<T>(toParse: AsapLike<T>): toParse is Asap<T>;
export declare class AsapParser {
    static from<T>(toParse: AsapLike<T>): Asap<T>;
}
export declare class Asaps {
    static now<T>(value: T): Asap<T>;
    static fromPromise<T>(promise: Promise<T>, name?: string): Asap<T>;
    static delayed<T>(value: T | IProducer<T>, ms: number, name?: string): Asap<T>;
    static fetch<T>(url: string): Asap<T>;
    static next<T>(name?: string, nature?: FlowEventNature): [IConsumer<T>, Asap<T>];
    static proxyThen<T>(toProxy: Asap<T>, beforeThen: ICallback, afterThen: IConsumer<any>): Asap<T>;
}
