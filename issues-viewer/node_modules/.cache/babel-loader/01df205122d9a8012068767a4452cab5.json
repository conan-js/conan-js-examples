{"ast":null,"code":"var textarea;\n\nfunction decodeEntity(name) {\n  textarea = textarea || document.createElement('textarea');\n  textarea.innerHTML = '&' + name + ';';\n  return textarea.value;\n}\n/**\n * Utility functions\n */\n\n\nfunction typeOf(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction isString(obj) {\n  return typeOf(obj) === '[object String]';\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return object ? hasOwn.call(object, key) : false;\n} // Extend objects\n//\n\n\nfunction assign(obj\n/*from1, from2, from3, ...*/\n) {\n  var sources = [].slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n  return obj;\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nvar UNESCAPE_MD_RE = /\\\\([\\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) {\n    return str;\n  }\n\n  return str.replace(UNESCAPE_MD_RE, '$1');\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) {\n    return false;\n  } // never used\n\n\n  if (c >= 0xFDD0 && c <= 0xFDEF) {\n    return false;\n  }\n\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {\n    return false;\n  } // control codes\n\n\n  if (c >= 0x00 && c <= 0x08) {\n    return false;\n  }\n\n  if (c === 0x0B) {\n    return false;\n  }\n\n  if (c >= 0x0E && c <= 0x1F) {\n    return false;\n  }\n\n  if (c >= 0x7F && c <= 0x9F) {\n    return false;\n  } // out of range\n\n\n  if (c > 0x10FFFF) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n\n  return String.fromCharCode(c);\n}\n\nvar NAMED_ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n  var decoded = decodeEntity(name);\n\n  if (name !== decoded) {\n    return decoded;\n  } else if (name.charCodeAt(0) === 0x23\n  /* # */\n  && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n\n  return match;\n}\n\nfunction replaceEntities(str) {\n  if (str.indexOf('&') < 0) {\n    return str;\n  }\n\n  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n\n  return str;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  isString: isString,\n  has: has,\n  assign: assign,\n  unescapeMd: unescapeMd,\n  isValidEntityCode: isValidEntityCode,\n  fromCodePoint: fromCodePoint,\n  replaceEntities: replaceEntities,\n  escapeHtml: escapeHtml\n});\n/**\n * Renderer rules cache\n */\n\nvar rules = {};\n/**\n * Blockquotes\n */\n\nrules.blockquote_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<blockquote>\\n';\n};\n\nrules.blockquote_close = function (tokens, idx\n/*, options, env */\n) {\n  return '</blockquote>' + getBreak(tokens, idx);\n};\n/**\n * Code\n */\n\n\nrules.code = function (tokens, idx\n/*, options, env */\n) {\n  if (tokens[idx].block) {\n    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);\n  }\n\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n/**\n * Fenced code blocks\n */\n\n\nrules.fence = function (tokens, idx, options, env, instance) {\n  var token = tokens[idx];\n  var langClass = '';\n  var langPrefix = options.langPrefix;\n  var langName = '',\n      fences,\n      fenceName;\n  var highlighted;\n\n  if (token.params) {\n    //\n    // ```foo bar\n    //\n    // Try custom renderer \"foo\" first. That will simplify overwrite\n    // for diagrams, latex, and any other fenced block with custom look\n    //\n    fences = token.params.split(/\\s+/g);\n    fenceName = fences.join(' ');\n\n    if (has(instance.rules.fence_custom, fences[0])) {\n      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);\n    }\n\n    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));\n    langClass = ' class=\"' + langPrefix + langName + '\"';\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight.apply(options.highlight, [token.content].concat(fences)) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  return '<pre><code' + langClass + '>' + highlighted + '</code></pre>' + getBreak(tokens, idx);\n};\n\nrules.fence_custom = {};\n/**\n * Headings\n */\n\nrules.heading_open = function (tokens, idx\n/*, options, env */\n) {\n  return '<h' + tokens[idx].hLevel + '>';\n};\n\nrules.heading_close = function (tokens, idx\n/*, options, env */\n) {\n  return '</h' + tokens[idx].hLevel + '>\\n';\n};\n/**\n * Horizontal rules\n */\n\n\nrules.hr = function (tokens, idx, options\n/*, env */\n) {\n  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);\n};\n/**\n * Bullets\n */\n\n\nrules.bullet_list_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<ul>\\n';\n};\n\nrules.bullet_list_close = function (tokens, idx\n/*, options, env */\n) {\n  return '</ul>' + getBreak(tokens, idx);\n};\n/**\n * List items\n */\n\n\nrules.list_item_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<li>';\n};\n\nrules.list_item_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</li>\\n';\n};\n/**\n * Ordered list items\n */\n\n\nrules.ordered_list_open = function (tokens, idx\n/*, options, env */\n) {\n  var token = tokens[idx];\n  var order = token.order > 1 ? ' start=\"' + token.order + '\"' : '';\n  return '<ol' + order + '>\\n';\n};\n\nrules.ordered_list_close = function (tokens, idx\n/*, options, env */\n) {\n  return '</ol>' + getBreak(tokens, idx);\n};\n/**\n * Paragraphs\n */\n\n\nrules.paragraph_open = function (tokens, idx\n/*, options, env */\n) {\n  return tokens[idx].tight ? '' : '<p>';\n};\n\nrules.paragraph_close = function (tokens, idx\n/*, options, env */\n) {\n  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);\n  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');\n};\n/**\n * Links\n */\n\n\nrules.link_open = function (tokens, idx, options\n/* env */\n) {\n  var title = tokens[idx].title ? ' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"' : '';\n  var target = options.linkTarget ? ' target=\"' + options.linkTarget + '\"' : '';\n  return '<a href=\"' + escapeHtml(tokens[idx].href) + '\"' + title + target + '>';\n};\n\nrules.link_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</a>';\n};\n/**\n * Images\n */\n\n\nrules.image = function (tokens, idx, options\n/*, env */\n) {\n  var src = ' src=\"' + escapeHtml(tokens[idx].src) + '\"';\n  var title = tokens[idx].title ? ' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"' : '';\n  var alt = ' alt=\"' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '\"';\n  var suffix = options.xhtmlOut ? ' /' : '';\n  return '<img' + src + alt + title + suffix + '>';\n};\n/**\n * Tables\n */\n\n\nrules.table_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<table>\\n';\n};\n\nrules.table_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</table>\\n';\n};\n\nrules.thead_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<thead>\\n';\n};\n\nrules.thead_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</thead>\\n';\n};\n\nrules.tbody_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<tbody>\\n';\n};\n\nrules.tbody_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</tbody>\\n';\n};\n\nrules.tr_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<tr>';\n};\n\nrules.tr_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</tr>\\n';\n};\n\nrules.th_open = function (tokens, idx\n/*, options, env */\n) {\n  var token = tokens[idx];\n  return '<th' + (token.align ? ' style=\"text-align:' + token.align + '\"' : '') + '>';\n};\n\nrules.th_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</th>';\n};\n\nrules.td_open = function (tokens, idx\n/*, options, env */\n) {\n  var token = tokens[idx];\n  return '<td' + (token.align ? ' style=\"text-align:' + token.align + '\"' : '') + '>';\n};\n\nrules.td_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</td>';\n};\n/**\n * Bold\n */\n\n\nrules.strong_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<strong>';\n};\n\nrules.strong_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</strong>';\n};\n/**\n * Italicize\n */\n\n\nrules.em_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<em>';\n};\n\nrules.em_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</em>';\n};\n/**\n * Strikethrough\n */\n\n\nrules.del_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<del>';\n};\n\nrules.del_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</del>';\n};\n/**\n * Insert\n */\n\n\nrules.ins_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<ins>';\n};\n\nrules.ins_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</ins>';\n};\n/**\n * Highlight\n */\n\n\nrules.mark_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<mark>';\n};\n\nrules.mark_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</mark>';\n};\n/**\n * Super- and sub-script\n */\n\n\nrules.sub = function (tokens, idx\n/*, options, env */\n) {\n  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';\n};\n\nrules.sup = function (tokens, idx\n/*, options, env */\n) {\n  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';\n};\n/**\n * Breaks\n */\n\n\nrules.hardbreak = function (tokens, idx, options\n/*, env */\n) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\n\nrules.softbreak = function (tokens, idx, options\n/*, env */\n) {\n  return options.breaks ? options.xhtmlOut ? '<br />\\n' : '<br>\\n' : '\\n';\n};\n/**\n * Text\n */\n\n\nrules.text = function (tokens, idx\n/*, options, env */\n) {\n  return escapeHtml(tokens[idx].content);\n};\n/**\n * Content\n */\n\n\nrules.htmlblock = function (tokens, idx\n/*, options, env */\n) {\n  return tokens[idx].content;\n};\n\nrules.htmltag = function (tokens, idx\n/*, options, env */\n) {\n  return tokens[idx].content;\n};\n/**\n * Abbreviations, initialism\n */\n\n\nrules.abbr_open = function (tokens, idx\n/*, options, env */\n) {\n  return '<abbr title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\">';\n};\n\nrules.abbr_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</abbr>';\n};\n/**\n * Footnotes\n */\n\n\nrules.footnote_ref = function (tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\n};\n\nrules.footnote_block_open = function (tokens, idx, options) {\n  var hr = options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n';\n  return hr + '<section class=\"footnotes\">\\n<ol class=\"footnotes-list\">\\n';\n};\n\nrules.footnote_block_close = function () {\n  return '</ol>\\n</section>\\n';\n};\n\nrules.footnote_open = function (tokens, idx) {\n  var id = Number(tokens[idx].id + 1).toString();\n  return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\n};\n\nrules.footnote_close = function () {\n  return '</li>\\n';\n};\n\nrules.footnote_anchor = function (tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n\n  return ' <a href=\"#' + id + '\" class=\"footnote-backref\">↩</a>';\n};\n/**\n * Definition lists\n */\n\n\nrules.dl_open = function () {\n  return '<dl>\\n';\n};\n\nrules.dt_open = function () {\n  return '<dt>';\n};\n\nrules.dd_open = function () {\n  return '<dd>';\n};\n\nrules.dl_close = function () {\n  return '</dl>\\n';\n};\n\nrules.dt_close = function () {\n  return '</dt>\\n';\n};\n\nrules.dd_close = function () {\n  return '</dd>\\n';\n};\n/**\n * Helper functions\n */\n\n\nfunction nextToken(tokens, idx) {\n  if (++idx >= tokens.length - 2) {\n    return idx;\n  }\n\n  if (tokens[idx].type === 'paragraph_open' && tokens[idx].tight && tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0 && tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight) {\n    return nextToken(tokens, idx + 2);\n  }\n\n  return idx;\n}\n/**\n * Check to see if `\\n` is needed before the next token.\n *\n * @param  {Array} `tokens`\n * @param  {Number} `idx`\n * @return {String} Empty string or newline\n * @api private\n */\n\n\nvar getBreak = rules.getBreak = function getBreak(tokens, idx) {\n  idx = nextToken(tokens, idx);\n\n  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {\n    return '';\n  }\n\n  return '\\n';\n};\n/**\n * Renderer class. Renders HTML and exposes `rules` to allow\n * local modifications.\n */\n\n\nfunction Renderer() {\n  this.rules = assign({}, rules); // exported helper, for custom rules only\n\n  this.getBreak = rules.getBreak;\n}\n/**\n * Render a string of inline HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\n\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length,\n      i = 0;\n  var result = '';\n\n  while (len--) {\n    result += _rules[tokens[i].type](tokens, i++, options, env, this);\n  }\n\n  return result;\n};\n/**\n * Render a string of HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\n\nRenderer.prototype.render = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length,\n      i = -1;\n  var result = '';\n\n  while (++i < len) {\n    if (tokens[i].type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else {\n      result += _rules[tokens[i].type](tokens, i, options, env, this);\n    }\n  }\n\n  return result;\n};\n/**\n * Ruler is a helper class for building responsibility chains from\n * parse rules. It allows:\n *\n *   - easy stack rules chains\n *   - getting main chain and named chains content (as arrays of functions)\n *\n * Helper methods, should not be used directly.\n * @api private\n */\n\n\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // { name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ] }\n  //\n  this.__rules__ = []; // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - digital anchor for fast filtering by charcodes.\n  //\n\n  this.__cache__ = null;\n}\n/**\n * Find the index of a rule by `name`.\n *\n * @param  {String} `name`\n * @return {Number} Index of the given `name`\n * @api private\n */\n\n\nRuler.prototype.__find__ = function (name) {\n  var len = this.__rules__.length;\n  var i = -1;\n\n  while (len--) {\n    if (this.__rules__[++i].name === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Build the rules lookup cache\n *\n * @api private\n */\n\n\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = ['']; // collect unique names\n\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) {\n      return;\n    }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) {\n        return;\n      }\n\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n/**\n * Ruler public methods\n * ------------------------------------------------\n */\n\n/**\n * Replace rule function\n *\n * @param  {String} `name` Rule name\n * @param  {Function `fn`\n * @param  {Object} `options`\n * @api private\n */\n\n\nRuler.prototype.at = function (name, fn, options) {\n  var idx = this.__find__(name);\n\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + name);\n  }\n\n  this.__rules__[idx].fn = fn;\n  this.__rules__[idx].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n/**\n * Add a rule to the chain before given the `ruleName`.\n *\n * @param  {String}   `beforeName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\n\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var idx = this.__find__(beforeName);\n\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + beforeName);\n  }\n\n  this.__rules__.splice(idx, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Add a rule to the chain after the given `ruleName`.\n *\n * @param  {String}   `afterName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\n\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var idx = this.__find__(afterName);\n\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + afterName);\n  }\n\n  this.__rules__.splice(idx + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Add a rule to the end of chain.\n *\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @return {String}\n */\n\n\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Enable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to enable\n * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.\n * @api private\n */\n\n\nRuler.prototype.enable = function (list, strict) {\n  list = !Array.isArray(list) ? [list] : list; // In strict mode disable all existing rules first\n\n  if (strict) {\n    this.__rules__.forEach(function (rule) {\n      rule.enabled = false;\n    });\n  } // Search by name and enable\n\n\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n\n    this.__rules__[idx].enabled = true;\n  }, this);\n  this.__cache__ = null;\n};\n/**\n * Disable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to disable\n * @api private\n */\n\n\nRuler.prototype.disable = function (list) {\n  list = !Array.isArray(list) ? [list] : list; // Search by name and disable\n\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n\n    this.__rules__[idx].enabled = false;\n  }, this);\n  this.__cache__ = null;\n};\n/**\n * Get a rules list as an array of functions.\n *\n * @param  {String} `chainName`\n * @return {Object}\n * @api private\n */\n\n\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  return this.__cache__[chainName] || [];\n};\n\nfunction block(state) {\n  if (state.inlineMode) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.replace(/\\n/g, ' ').trim(),\n      level: 0,\n      lines: [0, 1],\n      children: []\n    });\n  } else {\n    state.block.parse(state.src, state.options, state.env, state.tokens);\n  }\n} // Inline parser state\n\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n  this.cache = []; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n  // \"paired\" rules (emphasis, strikes) to not skip\n  // tailing `]`\n\n  this.linkLevel = 0; // Increment for each nesting link. Used to prevent\n  // nesting in definitions\n\n  this.linkContent = ''; // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n  // (backtrack optimization)\n} // Flush pending text\n//\n\n\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n}; // Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\n\n\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n}; // Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\n\n\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n}; // Get cache value\n//\n\n\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n/**\n * Parse link labels\n *\n * This function assumes that first character (`[`) already matches;\n * returns the end of the label.\n *\n * @param  {Object} state\n * @param  {Number} start\n * @api private\n */\n\n\nfunction parseLinkLabel(state, start) {\n  var level,\n      found,\n      marker,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos,\n      oldFlag = state.isInLabel;\n\n  if (state.isInLabel) {\n    return -1;\n  }\n\n  if (state.labelUnmatchedScopes) {\n    state.labelUnmatchedScopes--;\n    return -1;\n  }\n\n  state.pos = start + 1;\n  state.isInLabel = true;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n\n    if (marker === 0x5B\n    /* [ */\n    ) {\n        level++;\n      } else if (marker === 0x5D\n    /* ] */\n    ) {\n        level--;\n\n        if (level === 0) {\n          found = true;\n          break;\n        }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n    state.labelUnmatchedScopes = 0;\n  } else {\n    state.labelUnmatchedScopes = level - 1;\n  } // restore old state\n\n\n  state.pos = oldPos;\n  state.isInLabel = oldFlag;\n  return labelEnd;\n} // Parse abbreviation definitions, i.e. `*[abbr]: description`\n\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n\n  if (str.charCodeAt(0) !== 0x2A\n  /* * */\n  ) {\n      return -1;\n    }\n\n  if (str.charCodeAt(1) !== 0x5B\n  /* [ */\n  ) {\n      return -1;\n    }\n\n  if (str.indexOf(']:') === -1) {\n    return -1;\n  }\n\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  max = state.posMax; // abbr title is always one line, so looking for ending \"\\n\" here\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) {\n      break;\n    }\n  }\n\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n\n  if (title.length === 0) {\n    return -1;\n  }\n\n  if (!env.abbreviations) {\n    env.abbreviations = {};\n  } // prepend ':' to avoid conflict with Object.prototype members\n\n\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n\n  return pos;\n}\n\nfunction abbr(state) {\n  var tokens = state.tokens,\n      i,\n      l,\n      content,\n      pos;\n\n  if (state.inlineMode) {\n    return;\n  } // Parse inlines\n\n\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' && tokens[i].type === 'inline' && tokens[i + 1].type === 'paragraph_close') {\n      content = tokens[i].content;\n\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n\n        if (pos < 0) {\n          break;\n        }\n\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction normalizeLink(url) {\n  var normalized = replaceEntities(url); // We shouldn't care about the result of malformed URIs,\n  // and should not throw an exception.\n\n  try {\n    normalized = decodeURI(normalized);\n  } catch (err) {}\n\n  return encodeURI(normalized);\n}\n/**\n * Parse link destination\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\n\nfunction parseLinkDestination(state, pos) {\n  var code,\n      level,\n      link,\n      start = pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) === 0x3C\n  /* < */\n  ) {\n      pos++;\n\n      while (pos < max) {\n        code = state.src.charCodeAt(pos);\n\n        if (code === 0x0A\n        /* \\n */\n        ) {\n            return false;\n          }\n\n        if (code === 0x3E\n        /* > */\n        ) {\n            link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));\n\n            if (!state.parser.validateLink(link)) {\n              return false;\n            }\n\n            state.pos = pos + 1;\n            state.linkContent = link;\n            return true;\n          }\n\n        if (code === 0x5C\n        /* \\ */\n        && pos + 1 < max) {\n          pos += 2;\n          continue;\n        }\n\n        pos++;\n      } // no closing '>'\n\n\n      return false;\n    } // this should be ... } else { ... branch\n\n\n  level = 0;\n\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n\n    if (code === 0x20) {\n      break;\n    } // ascii control chars\n\n\n    if (code < 0x20 || code === 0x7F) {\n      break;\n    }\n\n    if (code === 0x5C\n    /* \\ */\n    && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28\n    /* ( */\n    ) {\n        level++;\n\n        if (level > 1) {\n          break;\n        }\n      }\n\n    if (code === 0x29\n    /* ) */\n    ) {\n        level--;\n\n        if (level < 0) {\n          break;\n        }\n      }\n\n    pos++;\n  }\n\n  if (start === pos) {\n    return false;\n  }\n\n  link = unescapeMd(state.src.slice(start, pos));\n\n  if (!state.parser.validateLink(link)) {\n    return false;\n  }\n\n  state.linkContent = link;\n  state.pos = pos;\n  return true;\n}\n/**\n * Parse link title\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\n\nfunction parseLinkTitle(state, pos) {\n  var code,\n      start = pos,\n      max = state.posMax,\n      marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x22\n  /* \" */\n  && marker !== 0x27\n  /* ' */\n  && marker !== 0x28\n  /* ( */\n  ) {\n      return false;\n    }\n\n  pos++; // if opening marker is \"(\", switch it to closing marker \")\"\n\n  if (marker === 0x28) {\n    marker = 0x29;\n  }\n\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n\n    if (code === marker) {\n      state.pos = pos + 1;\n      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));\n      return true;\n    }\n\n    if (code === 0x5C\n    /* \\ */\n    && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    pos++;\n  }\n\n  return false;\n}\n\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\n\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n\n  if (str.charCodeAt(0) !== 0x5B\n  /* [ */\n  ) {\n      return -1;\n    }\n\n  if (str.indexOf(']:') === -1) {\n    return -1;\n  }\n\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  max = state.posMax; // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n\n    if (code !== 0x20 && code !== 0x0A) {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n\n\n  if (!parseLinkDestination(state, pos)) {\n    return -1;\n  }\n\n  href = state.linkContent;\n  pos = state.pos; // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n\n  start = pos;\n\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n\n    if (code !== 0x20 && code !== 0x0A) {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n\n\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  } // ensure that the end of the line is empty\n\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x20\n  /* space */\n  ) {\n    pos++;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) {\n    return -1;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = {\n      title: title,\n      href: href\n    };\n  }\n\n  return pos;\n}\n\nfunction references(state) {\n  var tokens = state.tokens,\n      i,\n      l,\n      content,\n      pos;\n  state.env.references = state.env.references || {};\n\n  if (state.inlineMode) {\n    return;\n  } // Scan definitions in paragraph inlines\n\n\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' && tokens[i - 1].type === 'paragraph_open' && tokens[i + 1].type === 'paragraph_close') {\n      content = tokens[i].content;\n\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n\n        if (pos < 0) {\n          break;\n        }\n\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction inline(state) {\n  var tokens = state.tokens,\n      tok,\n      i,\n      l; // Parse inlines\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n\n    if (tok.type === 'inline') {\n      state.inline.parse(tok.content, state.options, state.env, tok.children);\n    }\n  }\n}\n\nfunction footnote_block(state) {\n  var i,\n      l,\n      j,\n      t,\n      lastParagraph,\n      list,\n      tokens,\n      current,\n      currentLabel,\n      level = 0,\n      insideRef = false,\n      refTokens = {};\n\n  if (!state.env.footnotes) {\n    return;\n  }\n\n  state.tokens = state.tokens.filter(function (tok) {\n    if (tok.type === 'footnote_reference_open') {\n      insideRef = true;\n      current = [];\n      currentLabel = tok.label;\n      return false;\n    }\n\n    if (tok.type === 'footnote_reference_close') {\n      insideRef = false; // prepend ':' to avoid conflict with Object.prototype members\n\n      refTokens[':' + currentLabel] = current;\n      return false;\n    }\n\n    if (insideRef) {\n      current.push(tok);\n    }\n\n    return !insideRef;\n  });\n\n  if (!state.env.footnotes.list) {\n    return;\n  }\n\n  list = state.env.footnotes.list;\n  state.tokens.push({\n    type: 'footnote_block_open',\n    level: level++\n  });\n\n  for (i = 0, l = list.length; i < l; i++) {\n    state.tokens.push({\n      type: 'footnote_open',\n      id: i,\n      level: level++\n    });\n\n    if (list[i].tokens) {\n      tokens = [];\n      tokens.push({\n        type: 'paragraph_open',\n        tight: false,\n        level: level++\n      });\n      tokens.push({\n        type: 'inline',\n        content: '',\n        level: level,\n        children: list[i].tokens\n      });\n      tokens.push({\n        type: 'paragraph_close',\n        tight: false,\n        level: --level\n      });\n    } else if (list[i].label) {\n      tokens = refTokens[':' + list[i].label];\n    }\n\n    state.tokens = state.tokens.concat(tokens);\n\n    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n      lastParagraph = state.tokens.pop();\n    } else {\n      lastParagraph = null;\n    }\n\n    t = list[i].count > 0 ? list[i].count : 1;\n\n    for (j = 0; j < t; j++) {\n      state.tokens.push({\n        type: 'footnote_anchor',\n        id: i,\n        subId: j,\n        level: level\n      });\n    }\n\n    if (lastParagraph) {\n      state.tokens.push(lastParagraph);\n    }\n\n    state.tokens.push({\n      type: 'footnote_close',\n      level: --level\n    });\n  }\n\n  state.tokens.push({\n    type: 'footnote_block_close',\n    level: --level\n  });\n} // Enclose abbreviations in <abbr> tags\n//\n\n\nvar PUNCT_CHARS = ' \\n()[]\\'\".,!?-'; // from Google closure library\n// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021\n\nfunction regEscape(s) {\n  return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1');\n}\n\nfunction abbr2(state) {\n  var i,\n      j,\n      l,\n      tokens,\n      token,\n      text,\n      nodes,\n      pos,\n      level,\n      reg,\n      m,\n      regText,\n      blockTokens = state.tokens;\n\n  if (!state.env.abbreviations) {\n    return;\n  }\n\n  if (!state.env.abbrRegExp) {\n    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])' + '(' + Object.keys(state.env.abbreviations).map(function (x) {\n      return x.substr(1);\n    }).sort(function (a, b) {\n      return b.length - a.length;\n    }).map(regEscape).join('|') + ')' + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';\n    state.env.abbrRegExp = new RegExp(regText, 'g');\n  }\n\n  reg = state.env.abbrRegExp;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') {\n      continue;\n    }\n\n    tokens = blockTokens[j].children; // We scan from the end, to keep position when new tags added.\n\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      if (token.type !== 'text') {\n        continue;\n      }\n\n      pos = 0;\n      text = token.content;\n      reg.lastIndex = 0;\n      level = token.level;\n      nodes = [];\n\n      while (m = reg.exec(text)) {\n        if (reg.lastIndex > pos) {\n          nodes.push({\n            type: 'text',\n            content: text.slice(pos, m.index + m[1].length),\n            level: level\n          });\n        }\n\n        nodes.push({\n          type: 'abbr_open',\n          title: state.env.abbreviations[':' + m[2]],\n          level: level++\n        });\n        nodes.push({\n          type: 'text',\n          content: m[2],\n          level: level\n        });\n        nodes.push({\n          type: 'abbr_close',\n          level: --level\n        });\n        pos = reg.lastIndex - m[3].length;\n      }\n\n      if (!nodes.length) {\n        continue;\n      }\n\n      if (pos < text.length) {\n        nodes.push({\n          type: 'text',\n          content: text.slice(pos),\n          level: level\n        });\n      } // replace current node\n\n\n      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n    }\n  }\n} // Simple typographical replacements\n//\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  'c': '©',\n  'r': '®',\n  'p': '§',\n  'tm': '™'\n};\n\nfunction replaceScopedAbbr(str) {\n  if (str.indexOf('(') < 0) {\n    return str;\n  }\n\n  return str.replace(SCOPED_ABBR_RE, function (match, name) {\n    return SCOPED_ABBR[name.toLowerCase()];\n  });\n}\n\nfunction replace(state) {\n  var i, token, text, inlineTokens, blkIdx;\n\n  if (!state.options.typographer) {\n    return;\n  }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline') {\n      continue;\n    }\n\n    inlineTokens = state.tokens[blkIdx].children;\n\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n\n      if (token.type === 'text') {\n        text = token.content;\n        text = replaceScopedAbbr(text);\n\n        if (RARE_RE.test(text)) {\n          text = text.replace(/\\+-/g, '±') // .., ..., ....... -> …\n          // but ?..... & !..... -> ?.. & !..\n          .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',') // em-dash\n          .replace(/(^|[^-])---([^-]|$)/mg, \"$1\\u2014$2\") // en-dash\n          .replace(/(^|\\s)--(\\s|$)/mg, \"$1\\u2013$2\").replace(/(^|[^-\\s])--([^-\\s]|$)/mg, \"$1\\u2013$2\");\n        }\n\n        token.content = text;\n      }\n    }\n  }\n} // Convert straight quotation marks to typographic ones\n//\n\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar PUNCT_RE = /[-\\s()\\[\\]]/;\nvar APOSTROPHE = '’'; // This function returns true if the character at `pos`\n// could be inside a word.\n\nfunction isLetter(str, pos) {\n  if (pos < 0 || pos >= str.length) {\n    return false;\n  }\n\n  return !PUNCT_RE.test(str[pos]);\n}\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction smartquotes(state) {\n  /*eslint max-depth:0*/\n  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item, canOpen, canClose, j, isSingle, blkIdx, tokens, stack;\n\n  if (!state.options.typographer) {\n    return;\n  }\n\n  stack = [];\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline') {\n      continue;\n    }\n\n    tokens = state.tokens[blkIdx].children;\n    stack.length = 0;\n\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n\n      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) {\n        continue;\n      }\n\n      thisLevel = tokens[i].level;\n\n      for (j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].level <= thisLevel) {\n          break;\n        }\n      }\n\n      stack.length = j + 1;\n      text = token.content;\n      pos = 0;\n      max = text.length;\n      /*eslint no-labels:0,block-scoped-var:0*/\n\n      OUTER: while (pos < max) {\n        QUOTE_RE.lastIndex = pos;\n        t = QUOTE_RE.exec(text);\n\n        if (!t) {\n          break;\n        }\n\n        lastSpace = !isLetter(text, t.index - 1);\n        pos = t.index + 1;\n        isSingle = t[0] === \"'\";\n        nextSpace = !isLetter(text, pos);\n\n        if (!nextSpace && !lastSpace) {\n          // middle of word\n          if (isSingle) {\n            token.content = replaceAt(token.content, t.index, APOSTROPHE);\n          }\n\n          continue;\n        }\n\n        canOpen = !nextSpace;\n        canClose = !lastSpace;\n\n        if (canClose) {\n          // this could be a closing quote, rewind the stack to get a match\n          for (j = stack.length - 1; j >= 0; j--) {\n            item = stack[j];\n\n            if (stack[j].level < thisLevel) {\n              break;\n            }\n\n            if (item.single === isSingle && stack[j].level === thisLevel) {\n              item = stack[j];\n\n              if (isSingle) {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);\n              } else {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);\n              }\n\n              stack.length = j;\n              continue OUTER;\n            }\n          }\n        }\n\n        if (canOpen) {\n          stack.push({\n            token: i,\n            pos: t.index,\n            single: isSingle,\n            level: thisLevel\n          });\n        } else if (canClose && isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n      }\n    }\n  }\n}\n/**\n * Core parser `rules`\n */\n\n\nvar _rules = [['block', block], ['abbr', abbr], ['references', references], ['inline', inline], ['footnote_tail', footnote_block], ['abbr2', abbr2], ['replacements', replace], ['smartquotes', smartquotes]];\n/**\n * Class for top level (`core`) parser rules\n *\n * @api private\n */\n\nfunction Core() {\n  this.options = {};\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n/**\n * Process rules with the given `state`\n *\n * @param  {Object} `state`\n * @api private\n */\n\n\nCore.prototype.process = function (state) {\n  var i, l, rules;\n  rules = this.ruler.getRules('');\n\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n}; // Parser state class\n\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n  this.src = src; // Shortcuts to simplify nested calls\n\n  this.parser = parser;\n  this.options = options;\n  this.env = env; //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n\n  this.eMarks = []; // line end offsets for fast jumps\n\n  this.tShift = []; // indent for each line\n  // block parser variables\n\n  this.blkIndent = 0; // required block content indent\n  // (for example, if we are in list)\n\n  this.line = 0; // line index in src\n\n  this.lineMax = 0; // lines count\n\n  this.tight = false; // loose/tight mode for lists\n\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0; // renderer\n\n  this.result = ''; // Create caches\n  // Generate markers.\n\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20\n      /* space */\n      ) {\n          indent++;\n          continue;\n        } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  } // Push fake entry to simplify cache bounds checks\n\n\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n\n  return from;\n}; // Skip spaces from given position.\n\n\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20\n    /* space */\n    ) {\n        break;\n      }\n  }\n\n  return pos;\n}; // Skip char codes from given position\n\n\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip char codes reverse from given position - 1\n\n\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // cut lines range from source.\n\n\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i,\n      first,\n      last,\n      queue,\n      shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  } // Opt: don't use push queue for single line;\n\n\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n\n    if (shift > indent) {\n      shift = indent;\n    }\n\n    if (shift < 0) {\n      shift = 0;\n    }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n}; // Code block (4 spaces padded)\n\n\nfunction code(state, startLine, endLine\n/*, silent*/\n) {\n  var nextLine, last;\n\n  if (state.tShift[startLine] - state.blkIndent < 4) {\n    return false;\n  }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n\n    break;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'code',\n    content: state.getLines(startLine, last, 4 + state.blkIndent, true),\n    block: true,\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n} // fences (``` lang, ~~~ lang)\n\n\nfunction fences(state, startLine, endLine, silent) {\n  var marker,\n      len,\n      params,\n      nextLine,\n      mem,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 3 > max) {\n    return false;\n  }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x60\n  /* ` */\n  ) {\n      return false;\n    } // scan marker length\n\n\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n  len = pos - mem;\n\n  if (len < 3) {\n    return false;\n  }\n\n  params = state.src.slice(pos, max).trim();\n\n  if (params.indexOf('`') >= 0) {\n    return false;\n  } // Since start is found, we can report success here in validation mode\n\n\n  if (silent) {\n    return true;\n  } // search end of block\n\n\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue;\n    }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker); // closing code fence must be at least as long as the opening one\n\n    if (pos - mem < len) {\n      continue;\n    } // make sure tail has spaces only\n\n\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) {\n      continue;\n    }\n\n    haveEndMarker = true; // found!\n\n    break;\n  } // If a fence has heading spaces, they should be removed from its inner block\n\n\n  len = state.tShift[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  state.tokens.push({\n    type: 'fence',\n    params: params,\n    content: state.getLines(startLine + 1, nextLine, len, true),\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n} // Block quotes\n\n\nfunction blockquote(state, startLine, endLine, silent) {\n  var nextLine,\n      lastLineEmpty,\n      oldTShift,\n      oldBMarks,\n      oldIndent,\n      oldParentType,\n      lines,\n      terminatorRules,\n      i,\n      l,\n      terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) {\n    return false;\n  } // check the block quote marker\n\n\n  if (state.src.charCodeAt(pos++) !== 0x3E\n  /* > */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n\n\n  if (silent) {\n    return true;\n  } // skip one optional space after '>'\n\n\n  if (state.src.charCodeAt(pos) === 0x20) {\n    pos++;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  oldBMarks = [state.bMarks[startLine]];\n  state.bMarks[startLine] = pos; // check if we have an empty blockquote\n\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n  oldTShift = [state.tShift[startLine]];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n  terminatorRules = state.parser.ruler.getRules('blockquote'); // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E\n    /* > */\n    ) {\n        // This line is inside the blockquote.\n        // skip one optional space after '>'\n        if (state.src.charCodeAt(pos) === 0x20) {\n          pos++;\n        }\n\n        oldBMarks.push(state.bMarks[nextLine]);\n        state.bMarks[nextLine] = pos;\n        pos = pos < max ? state.skipSpaces(pos) : pos;\n        lastLineEmpty = pos >= max;\n        oldTShift.push(state.tShift[nextLine]);\n        state.tShift[nextLine] = pos - state.bMarks[nextLine];\n        continue;\n      } // Case 2: line is not inside the blockquote, and the last line was empty.\n\n\n    if (lastLineEmpty) {\n      break;\n    } // Case 3: another tag found.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]); // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [startLine, 0],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n\n  state.blkIndent = oldIndent;\n  return true;\n} // Horizontal rule\n\n\nfunction hr(state, startLine, endLine, silent) {\n  var marker,\n      cnt,\n      ch,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine];\n  pos += state.tShift[startLine];\n\n  if (pos > max) {\n    return false;\n  }\n\n  marker = state.src.charCodeAt(pos++); // Check hr marker\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x5F\n  /* _ */\n  ) {\n      return false;\n    } // markers can be mixed with spaces, but there should be at least 3 one\n\n\n  cnt = 1;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch !== marker && ch !== 0x20\n    /* space */\n    ) {\n        return false;\n      }\n\n    if (ch === marker) {\n      cnt++;\n    }\n  }\n\n  if (cnt < 3) {\n    return false;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'hr',\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n} // Lists\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n\n\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) {\n    return -1;\n  }\n\n  marker = state.src.charCodeAt(pos++); // Check bullet\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x2B\n  /* + */\n  ) {\n      return -1;\n    }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n} // Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n\n\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) {\n    return -1;\n  }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30\n  /* 0 */\n  || ch > 0x39\n  /* 9 */\n  ) {\n      return -1;\n    }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30\n    /* 0 */\n    && ch <= 0x39\n    /* 9 */\n    ) {\n        continue;\n      } // found valid marker\n\n\n    if (ch === 0x29\n    /* ) */\n    || ch === 0x2e\n    /* . */\n    ) {\n        break;\n      }\n\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20\n  /* space */\n  ) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nfunction list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i,\n      l,\n      terminate; // Detect list type and position after marker\n\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // We should terminate list on style change. Remember first one to compare.\n\n\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately\n\n  if (silent) {\n    return true;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } //\n  // Iterate list items\n  //\n\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    } // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n\n\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    } // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n\n\n    if (indentAfterMarker < 1) {\n      indentAfterMarker = 1;\n    } // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n\n\n    indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker; // Run subparser & write tokens\n\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [startLine, 0],\n      level: state.level++\n    });\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n    state.parser.tokenize(state, startLine, endLine, true); // If any of list item is tight, mark list as tight\n\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    } // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n\n\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    } //\n    // Try to check if list is terminated or continued.\n    //\n\n\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    } // fail if terminating block found\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    } // fail if list has another type\n\n\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  } // Finilize list\n\n\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n} // Process footnote reference list\n\n\nfunction footnote(state, startLine, endLine, silent) {\n  var oldBMark,\n      oldTShift,\n      oldParentType,\n      pos,\n      label,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine]; // line should be at least 5 chars - \"[^x]:\"\n\n  if (start + 4 > max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.src.charCodeAt(start + 1) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) {\n      return false;\n    }\n\n    if (state.src.charCodeAt(pos) === 0x5D\n    /* ] */\n    ) {\n        break;\n      }\n  }\n\n  if (pos === start + 2) {\n    return false;\n  } // no empty footnote labels\n\n\n  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A\n  /* : */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return true;\n  }\n\n  pos++;\n\n  if (!state.env.footnotes) {\n    state.env.footnotes = {};\n  }\n\n  if (!state.env.footnotes.refs) {\n    state.env.footnotes.refs = {};\n  }\n\n  label = state.src.slice(start + 2, pos - 2);\n  state.env.footnotes.refs[':' + label] = -1;\n  state.tokens.push({\n    type: 'footnote_reference_open',\n    label: label,\n    level: state.level++\n  });\n  oldBMark = state.bMarks[startLine];\n  oldTShift = state.tShift[startLine];\n  oldParentType = state.parentType;\n  state.tShift[startLine] = state.skipSpaces(pos) - pos;\n  state.bMarks[startLine] = pos;\n  state.blkIndent += 4;\n  state.parentType = 'footnote';\n\n  if (state.tShift[startLine] < state.blkIndent) {\n    state.tShift[startLine] += state.blkIndent;\n    state.bMarks[startLine] -= state.blkIndent;\n  }\n\n  state.parser.tokenize(state, startLine, endLine, true);\n  state.parentType = oldParentType;\n  state.blkIndent -= 4;\n  state.tShift[startLine] = oldTShift;\n  state.bMarks[startLine] = oldBMark;\n  state.tokens.push({\n    type: 'footnote_reference_close',\n    level: --state.level\n  });\n  return true;\n} // heading (#, ##, ...)\n\n\nfunction heading(state, startLine, endLine, silent) {\n  var ch,\n      level,\n      tmp,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos >= max) {\n    return false;\n  }\n\n  ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23\n  /* # */\n  || pos >= max) {\n    return false;\n  } // count heading level\n\n\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n\n  while (ch === 0x23\n  /* # */\n  && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || pos < max && ch !== 0x20\n  /* space */\n  ) {\n    return false;\n  }\n\n  if (silent) {\n    return true;\n  } // Let's cut tails like '    ###  ' from the end of string\n\n\n  max = state.skipCharsBack(max, 0x20, pos); // space\n\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n\n  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20\n  /* space */\n  ) {\n      max = tmp;\n    }\n\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: level,\n    lines: [startLine, state.line],\n    level: state.level\n  }); // only if header is not empty\n\n  if (pos < max) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.slice(pos, max).trim(),\n      level: state.level + 1,\n      lines: [startLine, state.line],\n      children: []\n    });\n  }\n\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: level,\n    level: state.level\n  });\n  return true;\n} // lheading (---, ===)\n\n\nfunction lheading(state, startLine, endLine\n/*, silent*/\n) {\n  var marker,\n      pos,\n      max,\n      next = startLine + 1;\n\n  if (next >= endLine) {\n    return false;\n  }\n\n  if (state.tShift[next] < state.blkIndent) {\n    return false;\n  } // Scan next line\n\n\n  if (state.tShift[next] - state.blkIndent > 3) {\n    return false;\n  }\n\n  pos = state.bMarks[next] + state.tShift[next];\n  max = state.eMarks[next];\n\n  if (pos >= max) {\n    return false;\n  }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x2D\n  /* - */\n  && marker !== 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  pos = state.skipChars(pos, marker);\n  pos = state.skipSpaces(pos);\n\n  if (pos < max) {\n    return false;\n  }\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  state.line = next + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: marker === 0x3D\n    /* = */\n    ? 1 : 2,\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  state.tokens.push({\n    type: 'inline',\n    content: state.src.slice(pos, state.eMarks[startLine]).trim(),\n    level: state.level + 1,\n    lines: [startLine, state.line - 1],\n    children: []\n  });\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: marker === 0x3D\n    /* = */\n    ? 1 : 2,\n    level: state.level\n  });\n  return true;\n} // List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\n\nvar html_blocks = {};\n['article', 'aside', 'button', 'blockquote', 'body', 'canvas', 'caption', 'col', 'colgroup', 'dd', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'iframe', 'li', 'map', 'object', 'ol', 'output', 'p', 'pre', 'progress', 'script', 'section', 'style', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'tr', 'thead', 'ul', 'video'].forEach(function (name) {\n  html_blocks[name] = true;\n}); // HTML block\n\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\n\nfunction isLetter$1(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n\n  return lc >= 0x61\n  /* a */\n  && lc <= 0x7a\n  /* z */\n  ;\n}\n\nfunction htmlblock(state, startLine, endLine, silent) {\n  var ch,\n      match,\n      nextLine,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine],\n      shift = state.tShift[startLine];\n  pos += shift;\n\n  if (!state.options.html) {\n    return false;\n  }\n\n  if (shift > 3 || pos + 2 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(pos) !== 0x3C\n  /* < */\n  ) {\n      return false;\n    }\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch === 0x21\n  /* ! */\n  || ch === 0x3F\n  /* ? */\n  ) {\n      // Directive start / comment start / processing instruction start\n      if (silent) {\n        return true;\n      }\n    } else if (ch === 0x2F\n  /* / */\n  || isLetter$1(ch)) {\n    // Probably start or end of tag\n    if (ch === 0x2F\n    /* \\ */\n    ) {\n        // closing tag\n        match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n\n        if (!match) {\n          return false;\n        }\n      } else {\n      // opening tag\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n\n      if (!match) {\n        return false;\n      }\n    } // Make sure tag name is valid\n\n\n    if (html_blocks[match[1].toLowerCase()] !== true) {\n      return false;\n    }\n\n    if (silent) {\n      return true;\n    }\n  } else {\n    return false;\n  } // If we are here - we detected HTML block.\n  // Let's roll down till empty line (block end).\n\n\n  nextLine = startLine + 1;\n\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n    nextLine++;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'htmlblock',\n    level: state.level,\n    lines: [startLine, state.line],\n    content: state.getLines(startLine, nextLine, 0, true)\n  });\n  return true;\n} // GFM table, non-standard\n\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n  return state.src.substr(pos, max - pos);\n}\n\nfunction table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, rows, cell, aligns, t, tableLines, tbodyLines; // should have at least three lines\n\n  if (startLine + 2 > endLine) {\n    return false;\n  }\n\n  nextLine = startLine + 1;\n\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  } // first character of the second line should be '|' or '-'\n\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n\n  ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x7C\n  /* | */\n  && ch !== 0x2D\n  /* - */\n  && ch !== 0x3A\n  /* : */\n  ) {\n      return false;\n    }\n\n  lineText = getLine(state, startLine + 1);\n\n  if (!/^[-:| ]+$/.test(lineText)) {\n    return false;\n  }\n\n  rows = lineText.split('|');\n\n  if (rows <= 2) {\n    return false;\n  }\n\n  aligns = [];\n\n  for (i = 0; i < rows.length; i++) {\n    t = rows[i].trim();\n\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === rows.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) {\n      return false;\n    }\n\n    if (t.charCodeAt(t.length - 1) === 0x3A\n    /* : */\n    ) {\n        aligns.push(t.charCodeAt(0) === 0x3A\n        /* : */\n        ? 'center' : 'right');\n      } else if (t.charCodeAt(0) === 0x3A\n    /* : */\n    ) {\n        aligns.push('left');\n      } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n\n  if (lineText.indexOf('|') === -1) {\n    return false;\n  }\n\n  rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n\n  if (aligns.length !== rows.length) {\n    return false;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  state.tokens.push({\n    type: 'table_open',\n    lines: tableLines = [startLine, 0],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'thead_open',\n    lines: [startLine, startLine + 1],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'tr_open',\n    lines: [startLine, startLine + 1],\n    level: state.level++\n  });\n\n  for (i = 0; i < rows.length; i++) {\n    state.tokens.push({\n      type: 'th_open',\n      align: aligns[i],\n      lines: [startLine, startLine + 1],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: rows[i].trim(),\n      lines: [startLine, startLine + 1],\n      level: state.level,\n      children: []\n    });\n    state.tokens.push({\n      type: 'th_close',\n      level: --state.level\n    });\n  }\n\n  state.tokens.push({\n    type: 'tr_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'thead_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'tbody_open',\n    lines: tbodyLines = [startLine + 2, 0],\n    level: state.level++\n  });\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    }\n\n    lineText = getLine(state, nextLine).trim();\n\n    if (lineText.indexOf('|') === -1) {\n      break;\n    }\n\n    rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n    state.tokens.push({\n      type: 'tr_open',\n      level: state.level++\n    });\n\n    for (i = 0; i < rows.length; i++) {\n      state.tokens.push({\n        type: 'td_open',\n        align: aligns[i],\n        level: state.level++\n      }); // 0x7c === '|'\n\n      cell = rows[i].substring(rows[i].charCodeAt(0) === 0x7c ? 1 : 0, rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length).trim();\n      state.tokens.push({\n        type: 'inline',\n        content: cell,\n        level: state.level,\n        children: []\n      });\n      state.tokens.push({\n        type: 'td_close',\n        level: --state.level\n      });\n    }\n\n    state.tokens.push({\n      type: 'tr_close',\n      level: --state.level\n    });\n  }\n\n  state.tokens.push({\n    type: 'tbody_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'table_close',\n    level: --state.level\n  });\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n} // Definition lists\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\n\nfunction skipMarker(state, line) {\n  var pos,\n      marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) {\n    return -1;\n  } // Check bullet\n\n\n  marker = state.src.charCodeAt(start++);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  pos = state.skipSpaces(start); // require space after \":\"\n\n  if (start === pos) {\n    return -1;\n  } // no empty definitions, e.g. \"  : \"\n\n\n  if (pos >= max) {\n    return -1;\n  }\n\n  return pos;\n}\n\nfunction markTightParagraphs$1(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nfunction deflist(state, startLine, endLine, silent) {\n  var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) {\n      return false;\n    }\n\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) {\n      return false;\n    }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  }\n\n  contentStart = skipMarker(state, nextLine);\n\n  if (contentStart < 0) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [startLine, 0],\n    level: state.level++\n  }); //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine; // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n\n  /*eslint no-labels:0,block-scoped-var:0*/\n\n  OUTER: for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [dtLine, dtLine],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [dtLine, dtLine],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [nextLine, 0],\n        level: state.level++\n      });\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n      state.parser.tokenize(state, ddLine, endLine, true); // If any of list item is tight, mark list as tight\n\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      } // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n\n\n      prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) {\n        break OUTER;\n      }\n\n      if (state.tShift[nextLine] < state.blkIndent) {\n        break OUTER;\n      }\n\n      contentStart = skipMarker(state, nextLine);\n\n      if (contentStart < 0) {\n        break;\n      }\n\n      ddLine = nextLine; // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) {\n      break;\n    }\n\n    if (state.tShift[dtLine] < state.blkIndent) {\n      break;\n    }\n\n    ddLine = dtLine + 1;\n\n    if (ddLine >= endLine) {\n      break;\n    }\n\n    if (state.isEmpty(ddLine)) {\n      ddLine++;\n    }\n\n    if (ddLine >= endLine) {\n      break;\n    }\n\n    if (state.tShift[ddLine] < state.blkIndent) {\n      break;\n    }\n\n    contentStart = skipMarker(state, ddLine);\n\n    if (contentStart < 0) {\n      break;\n    } // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n\n  } // Finilize list\n\n\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs$1(state, listTokIdx);\n  }\n\n  return true;\n} // Paragraph\n\n\nfunction paragraph(state, startLine\n/*, endLine*/\n) {\n  var endLine,\n      content,\n      terminate,\n      i,\n      l,\n      nextLine = startLine + 1,\n      terminatorRules;\n  endLine = state.lineMax; // jump line-by-line until empty one or EOF\n\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) {\n        continue;\n      } // Some tags can terminate paragraph without empty line.\n\n\n      terminate = false;\n\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n\n      if (terminate) {\n        break;\n      }\n    }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [startLine, state.line],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [startLine, state.line],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n\n  return true;\n}\n/**\n * Parser rules\n */\n\n\nvar _rules$1 = [['code', code], ['fences', fences, ['paragraph', 'blockquote', 'list']], ['blockquote', blockquote, ['paragraph', 'blockquote', 'list']], ['hr', hr, ['paragraph', 'blockquote', 'list']], ['list', list, ['paragraph', 'blockquote']], ['footnote', footnote, ['paragraph']], ['heading', heading, ['paragraph', 'blockquote']], ['lheading', lheading], ['htmlblock', htmlblock, ['paragraph', 'blockquote']], ['table', table, ['paragraph']], ['deflist', deflist, ['paragraph']], ['paragraph', paragraph]];\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules$1.length; i++) {\n    this.ruler.push(_rules$1[i][0], _rules$1[i][1], {\n      alt: (_rules$1[i][2] || []).slice()\n    });\n  }\n}\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n\n    if (line >= endLine) {\n      break;\n    } // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n\n\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    } // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n\n      if (ok) {\n        break;\n      }\n    } // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n\n\n    state.tight = !hasEmptyLines; // paragraph might \"eat\" one newline after it in nested lists\n\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++; // two empty lines should stop the parser in list mode\n\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) {\n        break;\n      }\n\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE = /\\u00a0/g;\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state,\n      lineStart = 0,\n      lastTabPos = 0;\n\n  if (!str) {\n    return [];\n  } // Normalize spaces\n\n\n  str = str.replace(SPACES_RE, ' '); // Normalize newlines\n\n  str = str.replace(NEWLINES_RE, '\\n'); // Replace tabs with proper number of spaces (1..4)\n\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n}; // Skip text characters for text token, place those to pending buffer\n// and increment current pos\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A\n    /* \\n */\n    :\n    case 0x5C\n    /* \\ */\n    :\n    case 0x60\n    /* ` */\n    :\n    case 0x2A\n    /* * */\n    :\n    case 0x5F\n    /* _ */\n    :\n    case 0x5E\n    /* ^ */\n    :\n    case 0x5B\n    /* [ */\n    :\n    case 0x5D\n    /* ] */\n    :\n    case 0x21\n    /* ! */\n    :\n    case 0x26\n    /* & */\n    :\n    case 0x3C\n    /* < */\n    :\n    case 0x3E\n    /* > */\n    :\n    case 0x7B\n    /* { */\n    :\n    case 0x7D\n    /* } */\n    :\n    case 0x24\n    /* $ */\n    :\n    case 0x25\n    /* % */\n    :\n    case 0x40\n    /* @ */\n    :\n    case 0x7E\n    /* ~ */\n    :\n    case 0x2B\n    /* + */\n    :\n    case 0x3D\n    /* = */\n    :\n    case 0x3A\n    /* : */\n    :\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) {\n    return false;\n  }\n\n  if (!silent) {\n    state.pending += state.src.slice(state.pos, pos);\n  }\n\n  state.pos = pos;\n  return true;\n} // Proceess '\\n'\n\n\nfunction newline(state, silent) {\n  var pmax,\n      max,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A\n  /* \\n */\n  ) {\n      return false;\n    }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax; // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        // Strip out all trailing spaces on this line.\n        for (var i = pmax - 2; i >= 0; i--) {\n          if (state.pending.charCodeAt(i) !== 0x20) {\n            state.pending = state.pending.substring(0, i + 1);\n            break;\n          }\n        }\n\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push({\n          type: 'softbreak',\n          level: state.level\n        });\n      }\n    } else {\n      state.push({\n        type: 'softbreak',\n        level: state.level\n      });\n    }\n  }\n\n  pos++; // skip heading spaces for next line\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x20) {\n    pos++;\n  }\n\n  state.pos = pos;\n  return true;\n} // Proceess escaped chars and hardbreaks\n\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) {\n  ESCAPED.push(0);\n}\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {\n  ESCAPED[ch.charCodeAt(0)] = 1;\n});\n\nfunction escape(state, silent) {\n  var ch,\n      pos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C\n  /* \\ */\n  ) {\n      return false;\n    }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) {\n        state.pending += state.src[pos];\n      }\n\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      }\n\n      pos++; // skip leading whitespaces from next line\n\n      while (pos < max && state.src.charCodeAt(pos) === 0x20) {\n        pos++;\n      }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) {\n    state.pending += '\\\\';\n  }\n\n  state.pos++;\n  return true;\n} // Parse backticks\n\n\nfunction backticks(state, silent) {\n  var start,\n      max,\n      marker,\n      matchStart,\n      matchEnd,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60\n  /* ` */\n  ) {\n      return false;\n    }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60\n  /* ` */\n  ) {\n    pos++;\n  }\n\n  marker = state.src.slice(start, pos);\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60\n    /* ` */\n    ) {\n      matchEnd++;\n    }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        state.push({\n          type: 'code',\n          content: state.src.slice(pos, matchStart).replace(/[ \\n]+/g, ' ').trim(),\n          block: false,\n          level: state.level\n        });\n      }\n\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) {\n    state.pending += marker;\n  }\n\n  state.pos += marker.length;\n  return true;\n} // Process ~~deleted text~~\n\n\nfunction del(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 4 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start + 1) !== 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n\n  pos = start + 2;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x7E\n  /* ~ */\n  ) {\n    pos++;\n  }\n\n  if (pos > start + 3) {\n    // sequence of 4+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E\n    /* ~ */\n    ) {\n        if (state.src.charCodeAt(state.pos + 1) === 0x7E\n        /* ~ */\n        ) {\n            lastChar = state.src.charCodeAt(state.pos - 1);\n            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n\n            if (nextChar !== 0x7E\n            /* ~ */\n            && lastChar !== 0x7E\n            /* ~ */\n            ) {\n                if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                  // closing '~~'\n                  stack--;\n                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                  // opening '~~'\n                  stack++;\n                } // else {\n                //  // standalone ' ~~ ' indented with spaces\n                // }\n\n\n                if (stack <= 0) {\n                  found = true;\n                  break;\n                }\n              }\n          }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({\n      type: 'del_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'del_close',\n      level: --state.level\n    });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n} // Process ++inserted text++\n\n\nfunction ins(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 4 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start + 1) !== 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n\n  pos = start + 2;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x2B\n  /* + */\n  ) {\n    pos++;\n  }\n\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x2B\n    /* + */\n    ) {\n        if (state.src.charCodeAt(state.pos + 1) === 0x2B\n        /* + */\n        ) {\n            lastChar = state.src.charCodeAt(state.pos - 1);\n            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n\n            if (nextChar !== 0x2B\n            /* + */\n            && lastChar !== 0x2B\n            /* + */\n            ) {\n                if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                  // closing '++'\n                  stack--;\n                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                  // opening '++'\n                  stack++;\n                } // else {\n                //  // standalone ' ++ ' indented with spaces\n                // }\n\n\n                if (stack <= 0) {\n                  found = true;\n                  break;\n                }\n              }\n          }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({\n      type: 'ins_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'ins_close',\n      level: --state.level\n    });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n} // Process ==highlighted text==\n\n\nfunction mark(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 4 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start + 1) !== 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n\n  pos = start + 2;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x3D\n  /* = */\n  ) {\n    pos++;\n  }\n\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x3D\n    /* = */\n    ) {\n        if (state.src.charCodeAt(state.pos + 1) === 0x3D\n        /* = */\n        ) {\n            lastChar = state.src.charCodeAt(state.pos - 1);\n            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n\n            if (nextChar !== 0x3D\n            /* = */\n            && lastChar !== 0x3D\n            /* = */\n            ) {\n                if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                  // closing '=='\n                  stack--;\n                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                  // opening '=='\n                  stack++;\n                } // else {\n                //  // standalone ' == ' indented with spaces\n                // }\n\n\n                if (stack <= 0) {\n                  found = true;\n                  break;\n                }\n              }\n          }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({\n      type: 'mark_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'mark_close',\n      level: --state.level\n    });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n} // Process *this* and _that_\n\n\nfunction isAlphaNum(code) {\n  return code >= 0x30\n  /* 0 */\n  && code <= 0x39\n  /* 9 */\n  || code >= 0x41\n  /* A */\n  && code <= 0x5A\n  /* Z */\n  || code >= 0x61\n  /* a */\n  && code <= 0x7A\n  /* z */\n  ;\n} // parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\n\n\nfunction scanDelims(state, start) {\n  var pos = start,\n      lastChar,\n      nextChar,\n      count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n\n  if (pos >= max) {\n    can_open = false;\n  }\n\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1; // check whitespace conditions\n\n    if (nextChar === 0x20 || nextChar === 0x0A) {\n      can_open = false;\n    }\n\n    if (lastChar === 0x20 || lastChar === 0x0A) {\n      can_close = false;\n    }\n\n    if (marker === 0x5F\n    /* _ */\n    ) {\n        // check if we aren't inside the word\n        if (isAlphaNum(lastChar)) {\n          can_open = false;\n        }\n\n        if (isAlphaNum(nextChar)) {\n          can_close = false;\n        }\n      }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nfunction emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F\n  /* _ */\n  && marker !== 0x2A\n  /* * */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n\n  if (!res.can_open) {\n    state.pos += startCount;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, state.pos);\n    }\n\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + startCount;\n  stack = [startCount];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          } // assert(newCount > oldCount)\n\n\n          newCount -= oldCount;\n\n          if (stack.length === 0) {\n            break;\n          }\n\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) {\n        stack.push(count);\n      }\n\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_open',\n        level: state.level++\n      });\n    }\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_open',\n        level: state.level++\n      });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_close',\n        level: --state.level\n      });\n    }\n\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_close',\n        level: --state.level\n      });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n} // Process ~subscript~\n// same as UNESCAPE_MD_RE plus a space\n\n\nvar UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sub(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 2 >= max) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E\n    /* ~ */\n    ) {\n        found = true;\n        break;\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos); // don't allow unescaped spaces/newlines inside\n\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sub',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n} // Process ^superscript^\n// same as UNESCAPE_MD_RE plus a space\n\n\nvar UNESCAPE_RE$1 = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sup(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 2 >= max) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x5E\n    /* ^ */\n    ) {\n        found = true;\n        break;\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos); // don't allow unescaped spaces/newlines inside\n\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sup',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE$1, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n} // Process [links](<to> \"stuff\")\n\n\nfunction links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21\n  /* ! */\n  ) {\n      isImage = true;\n      marker = state.src.charCodeAt(++start);\n    }\n\n  if (marker !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start); // parser failed to find ']', so it's not a valid link\n\n  if (labelEnd < 0) {\n    return false;\n  }\n\n  pos = labelEnd + 1;\n\n  if (pos < max && state.src.charCodeAt(pos) === 0x28\n  /* ( */\n  ) {\n      //\n      // Inline link\n      //\n      // [link](  <href>  \"title\"  )\n      //        ^^ skipping these spaces\n      pos++;\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (code !== 0x20 && code !== 0x0A) {\n          break;\n        }\n      }\n\n      if (pos >= max) {\n        return false;\n      } // [link](  <href>  \"title\"  )\n      //          ^^^^^^ parsing link destination\n\n\n      start = pos;\n\n      if (parseLinkDestination(state, pos)) {\n        href = state.linkContent;\n        pos = state.pos;\n      } else {\n        href = '';\n      } // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n\n\n      start = pos;\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (code !== 0x20 && code !== 0x0A) {\n          break;\n        }\n      } // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n\n\n      if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n        title = state.linkContent;\n        pos = state.pos; // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n\n        for (; pos < max; pos++) {\n          code = state.src.charCodeAt(pos);\n\n          if (code !== 0x20 && code !== 0x0A) {\n            break;\n          }\n        }\n      } else {\n        title = '';\n      }\n\n      if (pos >= max || state.src.charCodeAt(pos) !== 0x29\n      /* ) */\n      ) {\n          state.pos = oldPos;\n          return false;\n        }\n\n      pos++;\n    } else {\n    //\n    // Link reference\n    //\n    // do not allow nested reference links\n    if (state.linkLevel > 0) {\n      return false;\n    } // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n\n\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B\n    /* [ */\n    ) {\n        start = pos + 1;\n        pos = parseLinkLabel(state, pos);\n\n        if (pos >= 0) {\n          label = state.src.slice(start, pos++);\n        } else {\n          pos = start - 1;\n        }\n      } // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n\n\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title;\n  } //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n\n\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({\n        type: 'link_close',\n        level: --state.level\n      });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n} // Process inline footnotes (^[...])\n\n\nfunction footnote_inline(state, silent) {\n  var labelStart,\n      labelEnd,\n      footnoteId,\n      oldLength,\n      max = state.posMax,\n      start = state.pos;\n\n  if (start + 2 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (state.src.charCodeAt(start + 1) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  labelStart = start + 2;\n  labelEnd = parseLinkLabel(state, start + 1); // parser failed to find ']', so it's not a valid note\n\n  if (labelEnd < 0) {\n    return false;\n  } // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n\n\n  if (!silent) {\n    if (!state.env.footnotes) {\n      state.env.footnotes = {};\n    }\n\n    if (!state.env.footnotes.list) {\n      state.env.footnotes.list = [];\n    }\n\n    footnoteId = state.env.footnotes.list.length;\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      level: state.level\n    });\n    state.linkLevel++;\n    oldLength = state.tokens.length;\n    state.parser.tokenize(state);\n    state.env.footnotes.list[footnoteId] = {\n      tokens: state.tokens.splice(oldLength)\n    };\n    state.linkLevel--;\n  }\n\n  state.pos = labelEnd + 1;\n  state.posMax = max;\n  return true;\n} // Process footnote references ([^...])\n\n\nfunction footnote_ref(state, silent) {\n  var label,\n      pos,\n      footnoteId,\n      footnoteSubId,\n      max = state.posMax,\n      start = state.pos; // should be at least 4 chars - \"[^x]\"\n\n  if (start + 3 > max) {\n    return false;\n  }\n\n  if (!state.env.footnotes || !state.env.footnotes.refs) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.src.charCodeAt(start + 1) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) {\n      return false;\n    }\n\n    if (state.src.charCodeAt(pos) === 0x0A) {\n      return false;\n    }\n\n    if (state.src.charCodeAt(pos) === 0x5D\n    /* ] */\n    ) {\n        break;\n      }\n  }\n\n  if (pos === start + 2) {\n    return false;\n  } // no empty footnote labels\n\n\n  if (pos >= max) {\n    return false;\n  }\n\n  pos++;\n  label = state.src.slice(start + 2, pos - 1);\n\n  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') {\n    return false;\n  }\n\n  if (!silent) {\n    if (!state.env.footnotes.list) {\n      state.env.footnotes.list = [];\n    }\n\n    if (state.env.footnotes.refs[':' + label] < 0) {\n      footnoteId = state.env.footnotes.list.length;\n      state.env.footnotes.list[footnoteId] = {\n        label: label,\n        count: 0\n      };\n      state.env.footnotes.refs[':' + label] = footnoteId;\n    } else {\n      footnoteId = state.env.footnotes.refs[':' + label];\n    }\n\n    footnoteSubId = state.env.footnotes.list[footnoteId].count;\n    state.env.footnotes.list[footnoteId].count++;\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      subId: footnoteSubId,\n      level: state.level\n    });\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n} // List of valid url schemas, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#autolinks\n\n\nvar url_schemas = ['coap', 'doi', 'javascript', 'aaa', 'aaas', 'about', 'acap', 'cap', 'cid', 'crid', 'data', 'dav', 'dict', 'dns', 'file', 'ftp', 'geo', 'go', 'gopher', 'h323', 'http', 'https', 'iax', 'icap', 'im', 'imap', 'info', 'ipp', 'iris', 'iris.beep', 'iris.xpc', 'iris.xpcs', 'iris.lwz', 'ldap', 'mailto', 'mid', 'msrp', 'msrps', 'mtqp', 'mupdate', 'news', 'nfs', 'ni', 'nih', 'nntp', 'opaquelocktoken', 'pop', 'pres', 'rtsp', 'service', 'session', 'shttp', 'sieve', 'sip', 'sips', 'sms', 'snmp', 'soap.beep', 'soap.beeps', 'tag', 'tel', 'telnet', 'tftp', 'thismessage', 'tn3270', 'tip', 'tv', 'urn', 'vemmi', 'ws', 'wss', 'xcon', 'xcon-userid', 'xmlrpc.beep', 'xmlrpc.beeps', 'xmpp', 'z39.50r', 'z39.50s', 'adiumxtra', 'afp', 'afs', 'aim', 'apt', 'attachment', 'aw', 'beshare', 'bitcoin', 'bolo', 'callto', 'chrome', 'chrome-extension', 'com-eventbrite-attendee', 'content', 'cvs', 'dlna-playsingle', 'dlna-playcontainer', 'dtn', 'dvb', 'ed2k', 'facetime', 'feed', 'finger', 'fish', 'gg', 'git', 'gizmoproject', 'gtalk', 'hcp', 'icon', 'ipn', 'irc', 'irc6', 'ircs', 'itms', 'jar', 'jms', 'keyparc', 'lastfm', 'ldaps', 'magnet', 'maps', 'market', 'message', 'mms', 'ms-help', 'msnim', 'mumble', 'mvn', 'notes', 'oid', 'palm', 'paparazzi', 'platform', 'proxy', 'psyc', 'query', 'res', 'resource', 'rmi', 'rsync', 'rtmp', 'secondlife', 'sftp', 'sgn', 'skype', 'smb', 'soldat', 'spotify', 'ssh', 'steam', 'svn', 'teamspeak', 'things', 'udp', 'unreal', 'ut2004', 'ventrilo', 'view-source', 'webcal', 'wtai', 'wyciwyg', 'xfire', 'xri', 'ymsgr']; // Process autolinks '<protocol:...>'\n\n/*eslint max-len:0*/\n\nvar EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z.\\-]{1,25}):([^<>\\x00-\\x20]*)>/;\n\nfunction autolink(state, silent) {\n  var tail,\n      linkMatch,\n      emailMatch,\n      url,\n      fullUrl,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C\n  /* < */\n  ) {\n      return false;\n    }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) {\n    return false;\n  }\n\n  linkMatch = tail.match(AUTOLINK_RE);\n\n  if (linkMatch) {\n    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {\n      return false;\n    }\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = normalizeLink(url);\n\n    if (!state.parser.validateLink(url)) {\n      return false;\n    }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({\n        type: 'link_close',\n        level: state.level\n      });\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  emailMatch = tail.match(EMAIL_RE);\n\n  if (emailMatch) {\n    url = emailMatch[0].slice(1, -1);\n    fullUrl = normalizeLink('mailto:' + url);\n\n    if (!state.parser.validateLink(fullUrl)) {\n      return false;\n    }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({\n        type: 'link_close',\n        level: state.level\n      });\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n} // Regexps to match html elements\n\n\nfunction replace$1(regex, options) {\n  regex = regex.source;\n  options = options || '';\n  return function self(name, val) {\n    if (!name) {\n      return new RegExp(regex, options);\n    }\n\n    val = val.source || val;\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nvar attr_name = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;\nvar unquoted = /[^\"'=<>`\\x00-\\x20]+/;\nvar single_quoted = /'[^']*'/;\nvar double_quoted = /\"[^\"]*\"/;\n/*eslint no-spaced-func:0*/\n\nvar attr_value = replace$1(/(?:unquoted|single_quoted|double_quoted)/)('unquoted', unquoted)('single_quoted', single_quoted)('double_quoted', double_quoted)();\nvar attribute = replace$1(/(?:\\s+attr_name(?:\\s*=\\s*attr_value)?)/)('attr_name', attr_name)('attr_value', attr_value)();\nvar open_tag = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\\s*\\/?>/)('attribute', attribute)();\nvar close_tag = /<\\/[A-Za-z][A-Za-z0-9]*\\s*>/;\nvar comment = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar processing = /<[?].*?[?]>/;\nvar declaration = /<![A-Z]+\\s+[^>]*>/;\nvar cdata = /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/;\nvar HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)('open_tag', open_tag)('close_tag', close_tag)('comment', comment)('processing', processing)('declaration', declaration)('cdata', cdata)(); // Process html tags\n\nfunction isLetter$2(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n\n  return lc >= 0x61\n  /* a */\n  && lc <= 0x7a\n  /* z */\n  ;\n}\n\nfunction htmltag(state, silent) {\n  var ch,\n      match,\n      max,\n      pos = state.pos;\n\n  if (!state.options.html) {\n    return false;\n  } // Check start\n\n\n  max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x3C\n  /* < */\n  || pos + 2 >= max) {\n    return false;\n  } // Quick fail on second char\n\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch !== 0x21\n  /* ! */\n  && ch !== 0x3F\n  /* ? */\n  && ch !== 0x2F\n  /* / */\n  && !isLetter$2(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n\n  if (!match) {\n    return false;\n  }\n\n  if (!silent) {\n    state.push({\n      type: 'htmltag',\n      content: state.src.slice(pos, pos + match[0].length),\n      level: state.level\n    });\n  }\n\n  state.pos += match[0].length;\n  return true;\n} // Process html entity - &#123;, &#xAF;, &quot;, ...\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;\n\nfunction entity(state, silent) {\n  var ch,\n      code,\n      match,\n      pos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26\n  /* & */\n  ) {\n      return false;\n    }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23\n    /* # */\n    ) {\n        match = state.src.slice(pos).match(DIGITAL_RE);\n\n        if (match) {\n          if (!silent) {\n            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n          }\n\n          state.pos += match[0].length;\n          return true;\n        }\n      } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n\n      if (match) {\n        var decoded = decodeEntity(match[1]);\n\n        if (match[1] !== decoded) {\n          if (!silent) {\n            state.pending += decoded;\n          }\n\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) {\n    state.pending += '&';\n  }\n\n  state.pos++;\n  return true;\n}\n/**\n * Inline Parser `rules`\n */\n\n\nvar _rules$2 = [['text', text], ['newline', newline], ['escape', escape], ['backticks', backticks], ['del', del], ['ins', ins], ['mark', mark], ['emphasis', emphasis], ['sub', sub], ['sup', sup], ['links', links], ['footnote_inline', footnote_inline], ['footnote_ref', footnote_ref], ['autolink', autolink], ['htmltag', htmltag], ['entity', entity]];\n/**\n * Inline Parser class. Note that link validation is stricter\n * in Remarkable than what is specified by CommonMark. If you\n * want to change this you can use a custom validator.\n *\n * @api private\n */\n\nfunction ParserInline() {\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules$2.length; i++) {\n    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);\n  } // Can be overridden with a custom validator\n\n\n  this.validateLink = validateLink;\n}\n/**\n * Skip a single token by running all rules in validation mode.\n * Returns `true` if any rule reports success.\n *\n * @param  {Object} `state`\n * @api privage\n */\n\n\nParserInline.prototype.skipToken = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var pos = state.pos;\n  var i, cached_pos;\n\n  if ((cached_pos = state.cacheGet(pos)) > 0) {\n    state.pos = cached_pos;\n    return;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (rules[i](state, true)) {\n      state.cacheSet(pos, state.pos);\n      return;\n    }\n  }\n\n  state.pos++;\n  state.cacheSet(pos, state.pos);\n};\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state`\n * @api private\n */\n\n\nParserInline.prototype.tokenize = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var end = state.posMax;\n  var ok, i;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, the rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, false);\n\n      if (ok) {\n        break;\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) {\n        break;\n      }\n\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n/**\n * Parse the given input string.\n *\n * @param  {String} `str`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\n\nParserInline.prototype.parse = function (str, options, env, outTokens) {\n  var state = new StateInline(str, this, options, env, outTokens);\n  this.tokenize(state);\n};\n/**\n * Validate the given `url` by checking for bad protocols.\n *\n * @param  {String} `url`\n * @return {Boolean}\n */\n\n\nfunction validateLink(url) {\n  var BAD_PROTOCOLS = ['vbscript', 'javascript', 'file', 'data'];\n  var str = url.trim().toLowerCase(); // Care about digital entities \"javascript&#x3A;alert(1)\"\n\n  str = replaceEntities(str);\n\n  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n    return false;\n  }\n\n  return true;\n} // Remarkable default options\n\n\nvar defaultConfig = {\n  options: {\n    html: false,\n    // Enable HTML tags in source\n    xhtmlOut: false,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n\n  },\n  components: {\n    core: {\n      rules: ['block', 'inline', 'references', 'replacements', 'smartquotes', 'references', 'abbr2', 'footnote_tail']\n    },\n    block: {\n      rules: ['blockquote', 'code', 'fences', 'footnote', 'heading', 'hr', 'htmlblock', 'lheading', 'list', 'paragraph', 'table']\n    },\n    inline: {\n      rules: ['autolink', 'backticks', 'del', 'emphasis', 'entity', 'escape', 'footnote_ref', 'htmltag', 'links', 'newline', 'text']\n    }\n  }\n}; // Remarkable default options\n\nvar fullConfig = {\n  options: {\n    html: false,\n    // Enable HTML tags in source\n    xhtmlOut: false,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n\n  },\n  components: {\n    // Don't restrict core/block/inline rules\n    core: {},\n    block: {},\n    inline: {}\n  }\n}; // Commonmark default options\n\nvar commonmarkConfig = {\n  options: {\n    html: true,\n    // Enable HTML tags in source\n    xhtmlOut: true,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n\n  },\n  components: {\n    core: {\n      rules: ['block', 'inline', 'references', 'abbr2']\n    },\n    block: {\n      rules: ['blockquote', 'code', 'fences', 'heading', 'hr', 'htmlblock', 'lheading', 'list', 'paragraph']\n    },\n    inline: {\n      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'htmltag', 'links', 'newline', 'text']\n    }\n  }\n};\n/**\n * Preset configs\n */\n\nvar config = {\n  'default': defaultConfig,\n  'full': fullConfig,\n  'commonmark': commonmarkConfig\n};\n/**\n * The `StateCore` class manages state.\n *\n * @param {Object} `instance` Remarkable instance\n * @param {String} `str` Markdown string\n * @param {Object} `env`\n */\n\nfunction StateCore(instance, str, env) {\n  this.src = str;\n  this.env = env;\n  this.options = instance.options;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.inline = instance.inline;\n  this.block = instance.block;\n  this.renderer = instance.renderer;\n  this.typographer = instance.typographer;\n}\n/**\n * The main `Remarkable` class. Create an instance of\n * `Remarkable` with a `preset` and/or `options`.\n *\n * @param {String} `preset` If no preset is given, `default` is used.\n * @param {Object} `options`\n */\n\n\nfunction Remarkable(preset, options) {\n  if (typeof preset !== 'string') {\n    options = preset;\n    preset = 'default';\n  }\n\n  if (options && options.linkify != null) {\n    console.warn('linkify option is removed. Use linkify plugin instead:\\n\\n' + 'import Remarkable from \\'remarkable\\';\\n' + 'import linkify from \\'remarkable/linkify\\';\\n' + 'new Remarkable().use(linkify)\\n');\n  }\n\n  this.inline = new ParserInline();\n  this.block = new ParserBlock();\n  this.core = new Core();\n  this.renderer = new Renderer();\n  this.ruler = new Ruler();\n  this.options = {};\n  this.configure(config[preset]);\n  this.set(options || {});\n}\n/**\n * Set options as an alternative to passing them\n * to the constructor.\n *\n * ```js\n * md.set({typographer: true});\n * ```\n * @param {Object} `options`\n * @api public\n */\n\n\nRemarkable.prototype.set = function (options) {\n  assign(this.options, options);\n};\n/**\n * Batch loader for components rules states, and options\n *\n * @param  {Object} `presets`\n */\n\n\nRemarkable.prototype.configure = function (presets) {\n  var self = this;\n\n  if (!presets) {\n    throw new Error('Wrong `remarkable` preset, check name/content');\n  }\n\n  if (presets.options) {\n    self.set(presets.options);\n  }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enable(presets.components[name].rules, true);\n      }\n    });\n  }\n};\n/**\n * Use a plugin.\n *\n * ```js\n * var md = new Remarkable();\n *\n * md.use(plugin1)\n *   .use(plugin2, opts)\n *   .use(plugin3);\n * ```\n *\n * @param  {Function} `plugin`\n * @param  {Object} `options`\n * @return {Object} `Remarkable` for chaining\n */\n\n\nRemarkable.prototype.use = function (plugin, options) {\n  plugin(this, options);\n  return this;\n};\n/**\n * Parse the input `string` and return a tokens array.\n * Modifies `env` with definitions data.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\n\nRemarkable.prototype.parse = function (str, env) {\n  var state = new StateCore(this, str, env);\n  this.core.process(state);\n  return state.tokens;\n};\n/**\n * The main `.render()` method that does all the magic :)\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {String} Rendered HTML.\n */\n\n\nRemarkable.prototype.render = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parse(str, env), this.options, env);\n};\n/**\n * Parse the given content `string` as a single string.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\n\nRemarkable.prototype.parseInline = function (str, env) {\n  var state = new StateCore(this, str, env);\n  state.inlineMode = true;\n  this.core.process(state);\n  return state.tokens;\n};\n/**\n * Render a single content `string`, without wrapping it\n * to paragraphs\n *\n * @param  {String} `str`\n * @param  {Object} `env`\n * @return {String}\n */\n\n\nRemarkable.prototype.renderInline = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parseInline(str, env), this.options, env);\n};\n\nexport { Remarkable, utils };","map":{"version":3,"sources":["/Users/albertoalmansa/Projects/conan-js/tmp/conan-js-examples/issues-viewer/node_modules/remarkable/dist/esm/index.browser.js"],"names":["textarea","decodeEntity","name","document","createElement","innerHTML","value","typeOf","obj","Object","prototype","toString","call","isString","hasOwn","hasOwnProperty","has","object","key","assign","sources","slice","arguments","forEach","source","TypeError","keys","UNESCAPE_MD_RE","unescapeMd","str","indexOf","replace","isValidEntityCode","c","fromCodePoint","surrogate1","surrogate2","String","fromCharCode","NAMED_ENTITY_RE","DIGITAL_ENTITY_TEST_RE","replaceEntityPattern","match","code","decoded","charCodeAt","test","toLowerCase","parseInt","replaceEntities","HTML_ESCAPE_TEST_RE","HTML_ESCAPE_REPLACE_RE","HTML_REPLACEMENTS","replaceUnsafeChar","ch","escapeHtml","utils","freeze","rules","blockquote_open","blockquote_close","tokens","idx","getBreak","block","content","fence","options","env","instance","token","langClass","langPrefix","langName","fences","fenceName","highlighted","params","split","join","fence_custom","highlight","apply","concat","heading_open","hLevel","heading_close","hr","xhtmlOut","bullet_list_open","bullet_list_close","list_item_open","list_item_close","ordered_list_open","order","ordered_list_close","paragraph_open","tight","paragraph_close","addBreak","type","link_open","title","target","linkTarget","href","link_close","image","src","alt","suffix","table_open","table_close","thead_open","thead_close","tbody_open","tbody_close","tr_open","tr_close","th_open","align","th_close","td_open","td_close","strong_open","strong_close","em_open","em_close","del_open","del_close","ins_open","ins_close","mark_open","mark_close","sub","sup","hardbreak","softbreak","breaks","text","htmlblock","htmltag","abbr_open","abbr_close","footnote_ref","n","Number","id","subId","footnote_block_open","footnote_block_close","footnote_open","footnote_close","footnote_anchor","dl_open","dt_open","dd_open","dl_close","dt_close","dd_close","nextToken","length","Renderer","renderInline","_rules","len","i","result","render","children","Ruler","__rules__","__cache__","__find__","__compile__","self","chains","rule","enabled","altName","push","chain","fn","at","opt","Error","before","beforeName","ruleName","splice","after","afterName","enable","list","strict","Array","isArray","disable","getRules","chainName","state","inlineMode","trim","level","lines","parse","StateInline","parserInline","outTokens","parser","pos","posMax","pending","pendingLevel","cache","isInLabel","linkLevel","linkContent","labelUnmatchedScopes","pushPending","cacheSet","val","cacheGet","parseLinkLabel","start","found","marker","labelEnd","max","oldPos","oldFlag","skipToken","parseAbbr","label","abbreviations","abbr","l","inline","normalizeLink","url","normalized","decodeURI","err","encodeURI","parseLinkDestination","link","validateLink","parseLinkTitle","normalizeReference","toUpperCase","parseReference","references","tok","footnote_block","j","t","lastParagraph","current","currentLabel","insideRef","refTokens","footnotes","filter","pop","count","PUNCT_CHARS","regEscape","s","abbr2","nodes","reg","m","regText","blockTokens","abbrRegExp","map","x","substr","sort","a","b","RegExp","lastIndex","exec","index","RARE_RE","SCOPED_ABBR_RE","SCOPED_ABBR","replaceScopedAbbr","inlineTokens","blkIdx","typographer","QUOTE_TEST_RE","QUOTE_RE","PUNCT_RE","APOSTROPHE","isLetter","replaceAt","smartquotes","thisLevel","lastSpace","nextSpace","item","canOpen","canClose","isSingle","stack","OUTER","single","quotes","Core","ruler","process","StateBlock","indent","indent_found","bMarks","eMarks","tShift","blkIndent","line","lineMax","parentType","ddIndent","isEmpty","skipEmptyLines","from","skipSpaces","skipChars","skipCharsBack","min","getLines","begin","end","keepLastLF","first","last","queue","shift","Math","startLine","endLine","nextLine","silent","mem","haveEndMarker","blockquote","lastLineEmpty","oldTShift","oldBMarks","oldIndent","oldParentType","terminatorRules","terminate","maxNesting","tokenize","cnt","skipBulletListMarker","skipOrderedListMarker","markTightParagraphs","oldTight","posAfterMarker","indentAfterMarker","markerValue","markerCharCode","isOrdered","contentStart","listTokIdx","prevEmptyEnd","listLines","itemLines","footnote","oldBMark","refs","heading","tmp","lheading","next","html_blocks","HTML_TAG_OPEN_RE","HTML_TAG_CLOSE_RE","isLetter$1","lc","html","getLine","table","lineText","rows","cell","aligns","tableLines","tbodyLines","substring","skipMarker","markTightParagraphs$1","deflist","ddLine","dtLine","oldDDIndent","paragraph","_rules$1","ParserBlock","hasEmptyLines","ok","TABS_SCAN_RE","NEWLINES_RE","SPACES_RE","lineStart","lastTabPos","offset","isTerminatorChar","newline","pmax","ESCAPED","escape","backticks","matchStart","matchEnd","del","lastChar","nextChar","ins","mark","isAlphaNum","scanDelims","can_open","can_close","delims","emphasis","startCount","oldCount","newCount","res","UNESCAPE_RE","UNESCAPE_RE$1","links","labelStart","ref","isImage","footnote_inline","footnoteId","oldLength","footnoteSubId","url_schemas","EMAIL_RE","AUTOLINK_RE","autolink","tail","linkMatch","emailMatch","fullUrl","replace$1","regex","attr_name","unquoted","single_quoted","double_quoted","attr_value","attribute","open_tag","close_tag","comment","processing","declaration","cdata","HTML_TAG_RE","isLetter$2","DIGITAL_RE","NAMED_RE","entity","_rules$2","ParserInline","cached_pos","BAD_PROTOCOLS","defaultConfig","components","core","fullConfig","commonmarkConfig","config","StateCore","renderer","Remarkable","preset","linkify","console","warn","configure","set","presets","use","plugin","parseInline"],"mappings":"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","sourcesContent":["var textarea;\n\nfunction decodeEntity(name) {\n  textarea = textarea || document.createElement('textarea');\n  textarea.innerHTML = '&' + name + ';';\n  return textarea.value;\n}\n\n/**\n * Utility functions\n */\n\nfunction typeOf(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction isString(obj) {\n  return typeOf(obj) === '[object String]';\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return object\n    ? hasOwn.call(object, key)\n    : false;\n}\n\n// Extend objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = [].slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar UNESCAPE_MD_RE = /\\\\([\\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) { return str; }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false; }\n  if (c === 0x0B) { return false; }\n  if (c >= 0x0E && c <= 0x1F) { return false; }\n  if (c >= 0x7F && c <= 0x9F) { return false; }\n  // out of range\n  if (c > 0x10FFFF) { return false; }\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\n\nvar NAMED_ENTITY_RE   = /&([a-z#][a-z0-9]{1,31});/gi;\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n  var decoded = decodeEntity(name);\n\n  if (name !== decoded) {\n    return decoded;\n  } else if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ?\n      parseInt(name.slice(2), 16)\n    :\n      parseInt(name.slice(1), 10);\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n  return match;\n}\n\nfunction replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  isString: isString,\n  has: has,\n  assign: assign,\n  unescapeMd: unescapeMd,\n  isValidEntityCode: isValidEntityCode,\n  fromCodePoint: fromCodePoint,\n  replaceEntities: replaceEntities,\n  escapeHtml: escapeHtml\n});\n\n/**\n * Renderer rules cache\n */\n\nvar rules = {};\n\n/**\n * Blockquotes\n */\n\nrules.blockquote_open = function(/* tokens, idx, options, env */) {\n  return '<blockquote>\\n';\n};\n\nrules.blockquote_close = function(tokens, idx /*, options, env */) {\n  return '</blockquote>' + getBreak(tokens, idx);\n};\n\n/**\n * Code\n */\n\nrules.code = function(tokens, idx /*, options, env */) {\n  if (tokens[idx].block) {\n    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);\n  }\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n\n/**\n * Fenced code blocks\n */\n\nrules.fence = function(tokens, idx, options, env, instance) {\n  var token = tokens[idx];\n  var langClass = '';\n  var langPrefix = options.langPrefix;\n  var langName = '', fences, fenceName;\n  var highlighted;\n\n  if (token.params) {\n\n    //\n    // ```foo bar\n    //\n    // Try custom renderer \"foo\" first. That will simplify overwrite\n    // for diagrams, latex, and any other fenced block with custom look\n    //\n\n    fences = token.params.split(/\\s+/g);\n    fenceName = fences.join(' ');\n\n    if (has(instance.rules.fence_custom, fences[0])) {\n      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);\n    }\n\n    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));\n    langClass = ' class=\"' + langPrefix + langName + '\"';\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight.apply(options.highlight, [ token.content ].concat(fences))\n      || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  return '<pre><code' + langClass + '>'\n        + highlighted\n        + '</code></pre>'\n        + getBreak(tokens, idx);\n};\n\nrules.fence_custom = {};\n\n/**\n * Headings\n */\n\nrules.heading_open = function(tokens, idx /*, options, env */) {\n  return '<h' + tokens[idx].hLevel + '>';\n};\nrules.heading_close = function(tokens, idx /*, options, env */) {\n  return '</h' + tokens[idx].hLevel + '>\\n';\n};\n\n/**\n * Horizontal rules\n */\n\nrules.hr = function(tokens, idx, options /*, env */) {\n  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);\n};\n\n/**\n * Bullets\n */\n\nrules.bullet_list_open = function(/* tokens, idx, options, env */) {\n  return '<ul>\\n';\n};\nrules.bullet_list_close = function(tokens, idx /*, options, env */) {\n  return '</ul>' + getBreak(tokens, idx);\n};\n\n/**\n * List items\n */\n\nrules.list_item_open = function(/* tokens, idx, options, env */) {\n  return '<li>';\n};\nrules.list_item_close = function(/* tokens, idx, options, env */) {\n  return '</li>\\n';\n};\n\n/**\n * Ordered list items\n */\n\nrules.ordered_list_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  var order = token.order > 1 ? ' start=\"' + token.order + '\"' : '';\n  return '<ol' + order + '>\\n';\n};\nrules.ordered_list_close = function(tokens, idx /*, options, env */) {\n  return '</ol>' + getBreak(tokens, idx);\n};\n\n/**\n * Paragraphs\n */\n\nrules.paragraph_open = function(tokens, idx /*, options, env */) {\n  return tokens[idx].tight ? '' : '<p>';\n};\nrules.paragraph_close = function(tokens, idx /*, options, env */) {\n  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);\n  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');\n};\n\n/**\n * Links\n */\n\nrules.link_open = function(tokens, idx, options /* env */) {\n  var title = tokens[idx].title ? (' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"') : '';\n  var target = options.linkTarget ? (' target=\"' + options.linkTarget + '\"') : '';\n  return '<a href=\"' + escapeHtml(tokens[idx].href) + '\"' + title + target + '>';\n};\nrules.link_close = function(/* tokens, idx, options, env */) {\n  return '</a>';\n};\n\n/**\n * Images\n */\n\nrules.image = function(tokens, idx, options /*, env */) {\n  var src = ' src=\"' + escapeHtml(tokens[idx].src) + '\"';\n  var title = tokens[idx].title ? (' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"') : '';\n  var alt = ' alt=\"' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '\"';\n  var suffix = options.xhtmlOut ? ' /' : '';\n  return '<img' + src + alt + title + suffix + '>';\n};\n\n/**\n * Tables\n */\n\nrules.table_open = function(/* tokens, idx, options, env */) {\n  return '<table>\\n';\n};\nrules.table_close = function(/* tokens, idx, options, env */) {\n  return '</table>\\n';\n};\nrules.thead_open = function(/* tokens, idx, options, env */) {\n  return '<thead>\\n';\n};\nrules.thead_close = function(/* tokens, idx, options, env */) {\n  return '</thead>\\n';\n};\nrules.tbody_open = function(/* tokens, idx, options, env */) {\n  return '<tbody>\\n';\n};\nrules.tbody_close = function(/* tokens, idx, options, env */) {\n  return '</tbody>\\n';\n};\nrules.tr_open = function(/* tokens, idx, options, env */) {\n  return '<tr>';\n};\nrules.tr_close = function(/* tokens, idx, options, env */) {\n  return '</tr>\\n';\n};\nrules.th_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  return '<th'\n    + (token.align ? ' style=\"text-align:' + token.align + '\"' : '')\n    + '>';\n};\nrules.th_close = function(/* tokens, idx, options, env */) {\n  return '</th>';\n};\nrules.td_open = function(tokens, idx /*, options, env */) {\n  var token = tokens[idx];\n  return '<td'\n    + (token.align ? ' style=\"text-align:' + token.align + '\"' : '')\n    + '>';\n};\nrules.td_close = function(/* tokens, idx, options, env */) {\n  return '</td>';\n};\n\n/**\n * Bold\n */\n\nrules.strong_open = function(/* tokens, idx, options, env */) {\n  return '<strong>';\n};\nrules.strong_close = function(/* tokens, idx, options, env */) {\n  return '</strong>';\n};\n\n/**\n * Italicize\n */\n\nrules.em_open = function(/* tokens, idx, options, env */) {\n  return '<em>';\n};\nrules.em_close = function(/* tokens, idx, options, env */) {\n  return '</em>';\n};\n\n/**\n * Strikethrough\n */\n\nrules.del_open = function(/* tokens, idx, options, env */) {\n  return '<del>';\n};\nrules.del_close = function(/* tokens, idx, options, env */) {\n  return '</del>';\n};\n\n/**\n * Insert\n */\n\nrules.ins_open = function(/* tokens, idx, options, env */) {\n  return '<ins>';\n};\nrules.ins_close = function(/* tokens, idx, options, env */) {\n  return '</ins>';\n};\n\n/**\n * Highlight\n */\n\nrules.mark_open = function(/* tokens, idx, options, env */) {\n  return '<mark>';\n};\nrules.mark_close = function(/* tokens, idx, options, env */) {\n  return '</mark>';\n};\n\n/**\n * Super- and sub-script\n */\n\nrules.sub = function(tokens, idx /*, options, env */) {\n  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';\n};\nrules.sup = function(tokens, idx /*, options, env */) {\n  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';\n};\n\n/**\n * Breaks\n */\n\nrules.hardbreak = function(tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\nrules.softbreak = function(tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n/**\n * Text\n */\n\nrules.text = function(tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n/**\n * Content\n */\n\nrules.htmlblock = function(tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\nrules.htmltag = function(tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n/**\n * Abbreviations, initialism\n */\n\nrules.abbr_open = function(tokens, idx /*, options, env */) {\n  return '<abbr title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\">';\n};\nrules.abbr_close = function(/* tokens, idx, options, env */) {\n  return '</abbr>';\n};\n\n/**\n * Footnotes\n */\n\nrules.footnote_ref = function(tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\n};\nrules.footnote_block_open = function(tokens, idx, options) {\n  var hr = options.xhtmlOut\n    ? '<hr class=\"footnotes-sep\" />\\n'\n    : '<hr class=\"footnotes-sep\">\\n';\n  return hr + '<section class=\"footnotes\">\\n<ol class=\"footnotes-list\">\\n';\n};\nrules.footnote_block_close = function() {\n  return '</ol>\\n</section>\\n';\n};\nrules.footnote_open = function(tokens, idx) {\n  var id = Number(tokens[idx].id + 1).toString();\n  return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\n};\nrules.footnote_close = function() {\n  return '</li>\\n';\n};\nrules.footnote_anchor = function(tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n  return ' <a href=\"#' + id + '\" class=\"footnote-backref\">↩</a>';\n};\n\n/**\n * Definition lists\n */\n\nrules.dl_open = function() {\n  return '<dl>\\n';\n};\nrules.dt_open = function() {\n  return '<dt>';\n};\nrules.dd_open = function() {\n  return '<dd>';\n};\nrules.dl_close = function() {\n  return '</dl>\\n';\n};\nrules.dt_close = function() {\n  return '</dt>\\n';\n};\nrules.dd_close = function() {\n  return '</dd>\\n';\n};\n\n/**\n * Helper functions\n */\n\nfunction nextToken(tokens, idx) {\n  if (++idx >= tokens.length - 2) {\n    return idx;\n  }\n  if ((tokens[idx].type === 'paragraph_open' && tokens[idx].tight) &&\n      (tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0) &&\n      (tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight)) {\n    return nextToken(tokens, idx + 2);\n  }\n  return idx;\n}\n\n/**\n * Check to see if `\\n` is needed before the next token.\n *\n * @param  {Array} `tokens`\n * @param  {Number} `idx`\n * @return {String} Empty string or newline\n * @api private\n */\n\nvar getBreak = rules.getBreak = function getBreak(tokens, idx) {\n  idx = nextToken(tokens, idx);\n  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {\n    return '';\n  }\n  return '\\n';\n};\n\n/**\n * Renderer class. Renders HTML and exposes `rules` to allow\n * local modifications.\n */\n\nfunction Renderer() {\n  this.rules = assign({}, rules);\n\n  // exported helper, for custom rules only\n  this.getBreak = rules.getBreak;\n}\n\n/**\n * Render a string of inline HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length, i = 0;\n  var result = '';\n\n  while (len--) {\n    result += _rules[tokens[i].type](tokens, i++, options, env, this);\n  }\n\n  return result;\n};\n\n/**\n * Render a string of HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\nRenderer.prototype.render = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length, i = -1;\n  var result = '';\n\n  while (++i < len) {\n    if (tokens[i].type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else {\n      result += _rules[tokens[i].type](tokens, i, options, env, this);\n    }\n  }\n  return result;\n};\n\n/**\n * Ruler is a helper class for building responsibility chains from\n * parse rules. It allows:\n *\n *   - easy stack rules chains\n *   - getting main chain and named chains content (as arrays of functions)\n *\n * Helper methods, should not be used directly.\n * @api private\n */\n\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // { name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ] }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - digital anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n/**\n * Find the index of a rule by `name`.\n *\n * @param  {String} `name`\n * @return {Number} Index of the given `name`\n * @api private\n */\n\nRuler.prototype.__find__ = function (name) {\n  var len = this.__rules__.length;\n  var i = -1;\n\n  while (len--) {\n    if (this.__rules__[++i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Build the rules lookup cache\n *\n * @api private\n */\n\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) {\n      return;\n    }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) {\n        return;\n      }\n\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n/**\n * Ruler public methods\n * ------------------------------------------------\n */\n\n/**\n * Replace rule function\n *\n * @param  {String} `name` Rule name\n * @param  {Function `fn`\n * @param  {Object} `options`\n * @api private\n */\n\nRuler.prototype.at = function (name, fn, options) {\n  var idx = this.__find__(name);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + name);\n  }\n\n  this.__rules__[idx].fn = fn;\n  this.__rules__[idx].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the chain before given the `ruleName`.\n *\n * @param  {String}   `beforeName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var idx = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + beforeName);\n  }\n\n  this.__rules__.splice(idx, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the chain after the given `ruleName`.\n *\n * @param  {String}   `afterName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var idx = this.__find__(afterName);\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + afterName);\n  }\n\n  this.__rules__.splice(idx + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Add a rule to the end of chain.\n *\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @return {String}\n */\n\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Enable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to enable\n * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.\n * @api private\n */\n\nRuler.prototype.enable = function (list, strict) {\n  list = !Array.isArray(list)\n    ? [ list ]\n    : list;\n\n  // In strict mode disable all existing rules first\n  if (strict) {\n    this.__rules__.forEach(function (rule) {\n      rule.enabled = false;\n    });\n  }\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n  }, this);\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Disable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to disable\n * @api private\n */\n\nRuler.prototype.disable = function (list) {\n  list = !Array.isArray(list)\n    ? [ list ]\n    : list;\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n  }, this);\n\n  this.__cache__ = null;\n};\n\n/**\n * Get a rules list as an array of functions.\n *\n * @param  {String} `chainName`\n * @return {Object}\n * @api private\n */\n\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n  return this.__cache__[chainName] || [];\n};\n\nfunction block(state) {\n\n  if (state.inlineMode) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.replace(/\\n/g, ' ').trim(),\n      level: 0,\n      lines: [ 0, 1 ],\n      children: []\n    });\n\n  } else {\n    state.block.parse(state.src, state.options, state.env, state.tokens);\n  }\n}\n\n// Inline parser state\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack\n                          // optimization of pairs parse (emphasis, strikes).\n\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n                          // \"paired\" rules (emphasis, strikes) to not skip\n                          // tailing `]`\n\n  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent\n                          // nesting in definitions\n\n  this.linkContent = '';  // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n                                 // (backtrack optimization)\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n};\n\n// Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n};\n\n// Get cache value\n//\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n\n/**\n * Parse link labels\n *\n * This function assumes that first character (`[`) already matches;\n * returns the end of the label.\n *\n * @param  {Object} state\n * @param  {Number} start\n * @api private\n */\n\nfunction parseLinkLabel(state, start) {\n  var level, found, marker,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos,\n      oldFlag = state.isInLabel;\n\n  if (state.isInLabel) { return -1; }\n\n  if (state.labelUnmatchedScopes) {\n    state.labelUnmatchedScopes--;\n    return -1;\n  }\n\n  state.pos = start + 1;\n  state.isInLabel = true;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5B /* [ */) {\n      level++;\n    } else if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n    state.labelUnmatchedScopes = 0;\n  } else {\n    state.labelUnmatchedScopes = level - 1;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n  state.isInLabel = oldFlag;\n\n  return labelEnd;\n}\n\n// Parse abbreviation definitions, i.e. `*[abbr]: description`\n\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n\n  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }\n  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // abbr title is always one line, so looking for ending \"\\n\" here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) { break; }\n  }\n\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n  if (title.length === 0) { return -1; }\n  if (!env.abbreviations) { env.abbreviations = {}; }\n  // prepend ':' to avoid conflict with Object.prototype members\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n\n  return pos;\n}\n\nfunction abbr(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Parse inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i].type === 'inline' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction normalizeLink(url) {\n  var normalized = replaceEntities(url);\n  // We shouldn't care about the result of malformed URIs,\n  // and should not throw an exception.\n  try {\n    normalized = decodeURI(normalized);\n  } catch (err) {}\n  return encodeURI(normalized);\n}\n\n/**\n * Parse link destination\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\nfunction parseLinkDestination(state, pos) {\n  var code, level, link,\n      start = pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) === 0x3C /* < */) {\n    pos++;\n    while (pos < max) {\n      code = state.src.charCodeAt(pos);\n      if (code === 0x0A /* \\n */) { return false; }\n      if (code === 0x3E /* > */) {\n        link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));\n        if (!state.parser.validateLink(link)) { return false; }\n        state.pos = pos + 1;\n        state.linkContent = link;\n        return true;\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n\n      pos++;\n    }\n\n    // no closing '>'\n    return false;\n  }\n\n  // this should be ... } else { ... branch\n\n  level = 0;\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n\n    if (code === 0x20) { break; }\n\n    // ascii control chars\n    if (code < 0x20 || code === 0x7F) { break; }\n\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28 /* ( */) {\n      level++;\n      if (level > 1) { break; }\n    }\n\n    if (code === 0x29 /* ) */) {\n      level--;\n      if (level < 0) { break; }\n    }\n\n    pos++;\n  }\n\n  if (start === pos) { return false; }\n\n  link = unescapeMd(state.src.slice(start, pos));\n  if (!state.parser.validateLink(link)) { return false; }\n\n  state.linkContent = link;\n  state.pos = pos;\n  return true;\n}\n\n/**\n * Parse link title\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\nfunction parseLinkTitle(state, pos) {\n  var code,\n      start = pos,\n      max = state.posMax,\n      marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return false; }\n\n  pos++;\n\n  // if opening marker is \"(\", switch it to closing marker \")\"\n  if (marker === 0x28) { marker = 0x29; }\n\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n    if (code === marker) {\n      state.pos = pos + 1;\n      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));\n      return true;\n    }\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    pos++;\n  }\n\n  return false;\n}\n\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\n\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n\n  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }\n\n  if (str.indexOf(']:') === -1) { return -1; }\n\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n  max = state.posMax;\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  if (!parseLinkDestination(state, pos)) { return -1; }\n  href = state.linkContent;\n  pos = state.pos;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n    if (code !== 0x20 && code !== 0x0A) { break; }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  }\n\n  // ensure that the end of the line is empty\n  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = { title: title, href: href };\n  }\n\n  return pos;\n}\n\n\nfunction references(state) {\n  var tokens = state.tokens, i, l, content, pos;\n\n  state.env.references = state.env.references || {};\n\n  if (state.inlineMode) {\n    return;\n  }\n\n  // Scan definitions in paragraph inlines\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' &&\n        tokens[i - 1].type === 'paragraph_open' &&\n        tokens[i + 1].type === 'paragraph_close') {\n\n      content = tokens[i].content;\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n        if (pos < 0) { break; }\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction inline(state) {\n  var tokens = state.tokens, tok, i, l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.inline.parse(tok.content, state.options, state.env, tok.children);\n    }\n  }\n}\n\nfunction footnote_block(state) {\n  var i, l, j, t, lastParagraph, list, tokens, current, currentLabel,\n      level = 0,\n      insideRef = false,\n      refTokens = {};\n\n  if (!state.env.footnotes) { return; }\n\n  state.tokens = state.tokens.filter(function(tok) {\n    if (tok.type === 'footnote_reference_open') {\n      insideRef = true;\n      current = [];\n      currentLabel = tok.label;\n      return false;\n    }\n    if (tok.type === 'footnote_reference_close') {\n      insideRef = false;\n      // prepend ':' to avoid conflict with Object.prototype members\n      refTokens[':' + currentLabel] = current;\n      return false;\n    }\n    if (insideRef) { current.push(tok); }\n    return !insideRef;\n  });\n\n  if (!state.env.footnotes.list) { return; }\n  list = state.env.footnotes.list;\n\n  state.tokens.push({\n    type: 'footnote_block_open',\n    level: level++\n  });\n  for (i = 0, l = list.length; i < l; i++) {\n    state.tokens.push({\n      type: 'footnote_open',\n      id: i,\n      level: level++\n    });\n\n    if (list[i].tokens) {\n      tokens = [];\n      tokens.push({\n        type: 'paragraph_open',\n        tight: false,\n        level: level++\n      });\n      tokens.push({\n        type: 'inline',\n        content: '',\n        level: level,\n        children: list[i].tokens\n      });\n      tokens.push({\n        type: 'paragraph_close',\n        tight: false,\n        level: --level\n      });\n    } else if (list[i].label) {\n      tokens = refTokens[':' + list[i].label];\n    }\n\n    state.tokens = state.tokens.concat(tokens);\n    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n      lastParagraph = state.tokens.pop();\n    } else {\n      lastParagraph = null;\n    }\n\n    t = list[i].count > 0 ? list[i].count : 1;\n    for (j = 0; j < t; j++) {\n      state.tokens.push({\n        type: 'footnote_anchor',\n        id: i,\n        subId: j,\n        level: level\n      });\n    }\n\n    if (lastParagraph) {\n      state.tokens.push(lastParagraph);\n    }\n\n    state.tokens.push({\n      type: 'footnote_close',\n      level: --level\n    });\n  }\n  state.tokens.push({\n    type: 'footnote_block_close',\n    level: --level\n  });\n}\n\n// Enclose abbreviations in <abbr> tags\n//\n\nvar PUNCT_CHARS = ' \\n()[]\\'\".,!?-';\n\n\n// from Google closure library\n// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021\nfunction regEscape(s) {\n  return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1');\n}\n\n\nfunction abbr2(state) {\n  var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText,\n      blockTokens = state.tokens;\n\n  if (!state.env.abbreviations) { return; }\n  if (!state.env.abbrRegExp) {\n    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])'\n            + '(' + Object.keys(state.env.abbreviations).map(function (x) {\n                      return x.substr(1);\n                    }).sort(function (a, b) {\n                      return b.length - a.length;\n                    }).map(regEscape).join('|') + ')'\n            + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';\n    state.env.abbrRegExp = new RegExp(regText, 'g');\n  }\n  reg = state.env.abbrRegExp;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') { continue; }\n    tokens = blockTokens[j].children;\n\n    // We scan from the end, to keep position when new tags added.\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n      if (token.type !== 'text') { continue; }\n\n      pos = 0;\n      text = token.content;\n      reg.lastIndex = 0;\n      level = token.level;\n      nodes = [];\n\n      while ((m = reg.exec(text))) {\n        if (reg.lastIndex > pos) {\n          nodes.push({\n            type: 'text',\n            content: text.slice(pos, m.index + m[1].length),\n            level: level\n          });\n        }\n\n        nodes.push({\n          type: 'abbr_open',\n          title: state.env.abbreviations[':' + m[2]],\n          level: level++\n        });\n        nodes.push({\n          type: 'text',\n          content: m[2],\n          level: level\n        });\n        nodes.push({\n          type: 'abbr_close',\n          level: --level\n        });\n        pos = reg.lastIndex - m[3].length;\n      }\n\n      if (!nodes.length) { continue; }\n\n      if (pos < text.length) {\n        nodes.push({\n          type: 'text',\n          content: text.slice(pos),\n          level: level\n        });\n      }\n\n      // replace current node\n      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n    }\n  }\n}\n\n// Simple typographical replacements\n//\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  'c': '©',\n  'r': '®',\n  'p': '§',\n  'tm': '™'\n};\n\nfunction replaceScopedAbbr(str) {\n  if (str.indexOf('(') < 0) { return str; }\n\n  return str.replace(SCOPED_ABBR_RE, function(match, name) {\n    return SCOPED_ABBR[name.toLowerCase()];\n  });\n}\n\n\nfunction replace(state) {\n  var i, token, text, inlineTokens, blkIdx;\n\n  if (!state.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    inlineTokens = state.tokens[blkIdx].children;\n\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n      if (token.type === 'text') {\n        text = token.content;\n\n        text = replaceScopedAbbr(text);\n\n        if (RARE_RE.test(text)) {\n          text = text\n            .replace(/\\+-/g, '±')\n            // .., ..., ....... -> …\n            // but ?..... & !..... -> ?.. & !..\n            .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..')\n            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n            // em-dash\n            .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\n            // en-dash\n            .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2')\n            .replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\n        }\n\n        token.content = text;\n      }\n    }\n  }\n}\n\n// Convert straight quotation marks to typographic ones\n//\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar PUNCT_RE = /[-\\s()\\[\\]]/;\nvar APOSTROPHE = '’';\n\n// This function returns true if the character at `pos`\n// could be inside a word.\nfunction isLetter(str, pos) {\n  if (pos < 0 || pos >= str.length) { return false; }\n  return !PUNCT_RE.test(str[pos]);\n}\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\n\nfunction smartquotes(state) {\n  /*eslint max-depth:0*/\n  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item,\n      canOpen, canClose, j, isSingle, blkIdx, tokens,\n      stack;\n\n  if (!state.options.typographer) { return; }\n\n  stack = [];\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    tokens = state.tokens[blkIdx].children;\n    stack.length = 0;\n\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n\n      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) { continue; }\n\n      thisLevel = tokens[i].level;\n\n      for (j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].level <= thisLevel) { break; }\n      }\n      stack.length = j + 1;\n\n      text = token.content;\n      pos = 0;\n      max = text.length;\n\n      /*eslint no-labels:0,block-scoped-var:0*/\n      OUTER:\n      while (pos < max) {\n        QUOTE_RE.lastIndex = pos;\n        t = QUOTE_RE.exec(text);\n        if (!t) { break; }\n\n        lastSpace = !isLetter(text, t.index - 1);\n        pos = t.index + 1;\n        isSingle = (t[0] === \"'\");\n        nextSpace = !isLetter(text, pos);\n\n        if (!nextSpace && !lastSpace) {\n          // middle of word\n          if (isSingle) {\n            token.content = replaceAt(token.content, t.index, APOSTROPHE);\n          }\n          continue;\n        }\n\n        canOpen = !nextSpace;\n        canClose = !lastSpace;\n\n        if (canClose) {\n          // this could be a closing quote, rewind the stack to get a match\n          for (j = stack.length - 1; j >= 0; j--) {\n            item = stack[j];\n            if (stack[j].level < thisLevel) { break; }\n            if (item.single === isSingle && stack[j].level === thisLevel) {\n              item = stack[j];\n              if (isSingle) {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);\n              } else {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);\n              }\n              stack.length = j;\n              continue OUTER;\n            }\n          }\n        }\n\n        if (canOpen) {\n          stack.push({\n            token: i,\n            pos: t.index,\n            single: isSingle,\n            level: thisLevel\n          });\n        } else if (canClose && isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Core parser `rules`\n */\n\nvar _rules = [\n  [ 'block',          block          ],\n  [ 'abbr',           abbr           ],\n  [ 'references',     references     ],\n  [ 'inline',         inline         ],\n  [ 'footnote_tail',  footnote_block  ],\n  [ 'abbr2',          abbr2          ],\n  [ 'replacements',   replace   ],\n  [ 'smartquotes',    smartquotes    ],\n];\n\n/**\n * Class for top level (`core`) parser rules\n *\n * @api private\n */\n\nfunction Core() {\n  this.options = {};\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n/**\n * Process rules with the given `state`\n *\n * @param  {Object} `state`\n * @api private\n */\n\nCore.prototype.process = function (state) {\n  var i, l, rules;\n  rules = this.ruler.getRules('');\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\n// Parser state class\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n\n  this.src = src;\n\n  // Shortcuts to simplify nested calls\n  this.parser = parser;\n\n  this.options = options;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // indent for each line\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent\n                       // (for example, if we are in list)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20/* space */) {\n        indent++;\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, first, last, queue, shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  // Opt: don't use push queue for single line;\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n    if (shift > indent) { shift = indent; }\n    if (shift < 0) { shift = 0; }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n};\n\n// Code block (4 spaces padded)\n\nfunction code(state, startLine, endLine/*, silent*/) {\n  var nextLine, last;\n\n  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'code',\n    content: state.getLines(startLine, last, 4 + state.blkIndent, true),\n    block: true,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// fences (``` lang, ~~~ lang)\n\nfunction fences(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  params = state.src.slice(pos, max).trim();\n\n  if (params.indexOf('`') >= 0) { return false; }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.tShift[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  state.tokens.push({\n    type: 'fence',\n    params: params,\n    content: state.getLines(startLine + 1, nextLine, len, true),\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// Block quotes\n\nfunction blockquote(state, startLine, endLine, silent) {\n  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,\n      terminatorRules,\n      i, l, terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  // check if we have an empty blockquote\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.parser.ruler.getRules('blockquote');\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\n      // This line is inside the blockquote.\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      pos = pos < max ? state.skipSpaces(pos) : pos;\n      lastLineEmpty = pos >= max;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n\n    // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n}\n\n// Horizontal rule\n\nfunction hr(state, startLine, endLine, silent) {\n  var marker, cnt, ch,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine];\n\n  pos += state.tShift[startLine];\n\n  if (pos > max) { return false; }\n\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 one\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && ch !== 0x20/* space */) { return false; }\n    if (ch === marker) { cnt++; }\n  }\n\n  if (cnt < 3) { return false; }\n\n  if (silent) { return true; }\n\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'hr',\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  return true;\n}\n\n// Lists\n\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) { return -1; }\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\n\nfunction list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i, l, terminate;\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [ startLine, 0 ],\n      level: state.level++\n    });\n  }\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n    if (indentAfterMarker < 1) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;\n\n    // Run subparser & write tokens\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [ startLine, 0 ],\n      level: state.level++\n    });\n\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n\n    state.parser.tokenize(state, startLine, endLine, true);\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n}\n\n// Process footnote reference list\n\nfunction footnote(state, startLine, endLine, silent) {\n  var oldBMark, oldTShift, oldParentType, pos, label,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // line should be at least 5 chars - \"[^x]:\"\n  if (start + 4 > max) { return false; }\n\n  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) { return false; }\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n      break;\n    }\n  }\n\n  if (pos === start + 2) { return false; } // no empty footnote labels\n  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\n  if (silent) { return true; }\n  pos++;\n\n  if (!state.env.footnotes) { state.env.footnotes = {}; }\n  if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\n  label = state.src.slice(start + 2, pos - 2);\n  state.env.footnotes.refs[':' + label] = -1;\n\n  state.tokens.push({\n    type: 'footnote_reference_open',\n    label: label,\n    level: state.level++\n  });\n\n  oldBMark = state.bMarks[startLine];\n  oldTShift = state.tShift[startLine];\n  oldParentType = state.parentType;\n  state.tShift[startLine] = state.skipSpaces(pos) - pos;\n  state.bMarks[startLine] = pos;\n  state.blkIndent += 4;\n  state.parentType = 'footnote';\n\n  if (state.tShift[startLine] < state.blkIndent) {\n    state.tShift[startLine] += state.blkIndent;\n    state.bMarks[startLine] -= state.blkIndent;\n  }\n\n  state.parser.tokenize(state, startLine, endLine, true);\n\n  state.parentType = oldParentType;\n  state.blkIndent -= 4;\n  state.tShift[startLine] = oldTShift;\n  state.bMarks[startLine] = oldBMark;\n\n  state.tokens.push({\n    type: 'footnote_reference_close',\n    level: --state.level\n  });\n\n  return true;\n}\n\n// heading (#, ##, ...)\n\nfunction heading(state, startLine, endLine, silent) {\n  var ch, level, tmp,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos >= max) { return false; }\n\n  ch  = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }\n\n  if (silent) { return true; }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipCharsBack(max, 0x20, pos); // space\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {\n    max = tmp;\n  }\n\n  state.line = startLine + 1;\n\n  state.tokens.push({ type: 'heading_open',\n    hLevel: level,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n\n  // only if header is not empty\n  if (pos < max) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.slice(pos, max).trim(),\n      level: state.level + 1,\n      lines: [ startLine, state.line ],\n      children: []\n    });\n  }\n  state.tokens.push({ type: 'heading_close', hLevel: level, level: state.level });\n\n  return true;\n}\n\n// lheading (---, ===)\n\nfunction lheading(state, startLine, endLine/*, silent*/) {\n  var marker, pos, max,\n      next = startLine + 1;\n\n  if (next >= endLine) { return false; }\n  if (state.tShift[next] < state.blkIndent) { return false; }\n\n  // Scan next line\n\n  if (state.tShift[next] - state.blkIndent > 3) { return false; }\n\n  pos = state.bMarks[next] + state.tShift[next];\n  max = state.eMarks[next];\n\n  if (pos >= max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }\n\n  pos = state.skipChars(pos, marker);\n\n  pos = state.skipSpaces(pos);\n\n  if (pos < max) { return false; }\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n\n  state.line = next + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: marker === 0x3D/* = */ ? 1 : 2,\n    lines: [ startLine, state.line ],\n    level: state.level\n  });\n  state.tokens.push({\n    type: 'inline',\n    content: state.src.slice(pos, state.eMarks[startLine]).trim(),\n    level: state.level + 1,\n    lines: [ startLine, state.line - 1 ],\n    children: []\n  });\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: marker === 0x3D/* = */ ? 1 : 2,\n    level: state.level\n  });\n\n  return true;\n}\n\n// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\nvar html_blocks = {};\n\n[\n  'article',\n  'aside',\n  'button',\n  'blockquote',\n  'body',\n  'canvas',\n  'caption',\n  'col',\n  'colgroup',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'iframe',\n  'li',\n  'map',\n  'object',\n  'ol',\n  'output',\n  'p',\n  'pre',\n  'progress',\n  'script',\n  'section',\n  'style',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'tr',\n  'thead',\n  'ul',\n  'video'\n].forEach(function (name) { html_blocks[name] = true; });\n\n// HTML block\n\n\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\n\nfunction isLetter$1(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\nfunction htmlblock(state, startLine, endLine, silent) {\n  var ch, match, nextLine,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine],\n      shift = state.tShift[startLine];\n\n  pos += shift;\n\n  if (!state.options.html) { return false; }\n\n  if (shift > 3 || pos + 2 >= max) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {\n    // Directive start / comment start / processing instruction start\n    if (silent) { return true; }\n\n  } else if (ch === 0x2F/* / */ || isLetter$1(ch)) {\n\n    // Probably start or end of tag\n    if (ch === 0x2F/* \\ */) {\n      // closing tag\n      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n      if (!match) { return false; }\n    } else {\n      // opening tag\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n      if (!match) { return false; }\n    }\n    // Make sure tag name is valid\n    if (html_blocks[match[1].toLowerCase()] !== true) { return false; }\n    if (silent) { return true; }\n\n  } else {\n    return false;\n  }\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till empty line (block end).\n  nextLine = startLine + 1;\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n    nextLine++;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'htmlblock',\n    level: state.level,\n    lines: [ startLine, state.line ],\n    content: state.getLines(startLine, nextLine, 0, true)\n  });\n\n  return true;\n}\n\n// GFM table, non-standard\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n\n  return state.src.substr(pos, max - pos);\n}\n\nfunction table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, rows, cell,\n      aligns, t, tableLines, tbodyLines;\n\n  // should have at least three lines\n  if (startLine + 2 > endLine) { return false; }\n\n  nextLine = startLine + 1;\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n\n  // first character of the second line should be '|' or '-'\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  ch = state.src.charCodeAt(pos);\n  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\n\n  lineText = getLine(state, startLine + 1);\n  if (!/^[-:| ]+$/.test(lineText)) { return false; }\n\n  rows = lineText.split('|');\n  if (rows <= 2) { return false; }\n  aligns = [];\n  for (i = 0; i < rows.length; i++) {\n    t = rows[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === rows.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false; }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) { return false; }\n  rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n  if (aligns.length !== rows.length) { return false; }\n  if (silent) { return true; }\n\n  state.tokens.push({\n    type: 'table_open',\n    lines: tableLines = [ startLine, 0 ],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'thead_open',\n    lines: [ startLine, startLine + 1 ],\n    level: state.level++\n  });\n\n  state.tokens.push({\n    type: 'tr_open',\n    lines: [ startLine, startLine + 1 ],\n    level: state.level++\n  });\n  for (i = 0; i < rows.length; i++) {\n    state.tokens.push({\n      type: 'th_open',\n      align: aligns[i],\n      lines: [ startLine, startLine + 1 ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: rows[i].trim(),\n      lines: [ startLine, startLine + 1 ],\n      level: state.level,\n      children: []\n    });\n    state.tokens.push({ type: 'th_close', level: --state.level });\n  }\n  state.tokens.push({ type: 'tr_close', level: --state.level });\n  state.tokens.push({ type: 'thead_close', level: --state.level });\n\n  state.tokens.push({\n    type: 'tbody_open',\n    lines: tbodyLines = [ startLine + 2, 0 ],\n    level: state.level++\n  });\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n    lineText = getLine(state, nextLine).trim();\n    if (lineText.indexOf('|') === -1) { break; }\n    rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n\n    state.tokens.push({ type: 'tr_open', level: state.level++ });\n    for (i = 0; i < rows.length; i++) {\n      state.tokens.push({ type: 'td_open', align: aligns[i], level: state.level++ });\n      // 0x7c === '|'\n      cell = rows[i].substring(\n          rows[i].charCodeAt(0) === 0x7c ? 1 : 0,\n          rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length\n      ).trim();\n      state.tokens.push({\n        type: 'inline',\n        content: cell,\n        level: state.level,\n        children: []\n      });\n      state.tokens.push({ type: 'td_close', level: --state.level });\n    }\n    state.tokens.push({ type: 'tr_close', level: --state.level });\n  }\n  state.tokens.push({ type: 'tbody_close', level: --state.level });\n  state.tokens.push({ type: 'table_close', level: --state.level });\n\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n}\n\n// Definition lists\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipMarker(state, line) {\n  var pos, marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) { return -1; }\n\n  // Check bullet\n  marker = state.src.charCodeAt(start++);\n  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n  pos = state.skipSpaces(start);\n\n  // require space after \":\"\n  if (start === pos) { return -1; }\n\n  // no empty definitions, e.g. \"  : \"\n  if (pos >= max) { return -1; }\n\n  return pos;\n}\n\nfunction markTightParagraphs$1(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nfunction deflist(state, startLine, endLine, silent) {\n  var contentStart,\n      ddLine,\n      dtLine,\n      itemLines,\n      listLines,\n      listTokIdx,\n      nextLine,\n      oldIndent,\n      oldDDIndent,\n      oldParentType,\n      oldTShift,\n      oldTight,\n      prevEmptyEnd,\n      tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) { return false; }\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) { return false; }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) { return false; }\n  contentStart = skipMarker(state, nextLine);\n  if (contentStart < 0) { return false; }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [ startLine, 0 ],\n    level: state.level++\n  });\n\n  //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine;\n\n  // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n  /*eslint no-labels:0,block-scoped-var:0*/\n  OUTER:\n  for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [ dtLine, dtLine ],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [ dtLine, dtLine ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [ nextLine, 0 ],\n        level: state.level++\n      });\n\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n\n      state.parser.tokenize(state, ddLine, endLine, true);\n\n      // If any of list item is tight, mark list as tight\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      }\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) { break OUTER; }\n\n      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }\n      contentStart = skipMarker(state, nextLine);\n      if (contentStart < 0) { break; }\n\n      ddLine = nextLine;\n\n      // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) { break; }\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) { break; }\n    if (state.tShift[dtLine] < state.blkIndent) { break; }\n\n    ddLine = dtLine + 1;\n    if (ddLine >= endLine) { break; }\n    if (state.isEmpty(ddLine)) { ddLine++; }\n    if (ddLine >= endLine) { break; }\n\n    if (state.tShift[ddLine] < state.blkIndent) { break; }\n    contentStart = skipMarker(state, ddLine);\n    if (contentStart < 0) { break; }\n\n    // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n  }\n\n  // Finilize list\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs$1(state, listTokIdx);\n  }\n\n  return true;\n}\n\n// Paragraph\n\nfunction paragraph(state, startLine/*, endLine*/) {\n  var endLine, content, terminate, i, l,\n      nextLine = startLine + 1,\n      terminatorRules;\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }\n\n      // Some tags can terminate paragraph without empty line.\n      terminate = false;\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      if (terminate) { break; }\n    }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [ startLine, state.line ],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [ startLine, state.line ],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n\n  return true;\n}\n\n/**\n * Parser rules\n */\n\nvar _rules$1 = [\n  [ 'code',       code ],\n  [ 'fences',     fences,     [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'blockquote', blockquote, [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'hr',         hr,         [ 'paragraph', 'blockquote', 'list' ] ],\n  [ 'list',       list,       [ 'paragraph', 'blockquote' ] ],\n  [ 'footnote',   footnote,   [ 'paragraph' ] ],\n  [ 'heading',    heading,    [ 'paragraph', 'blockquote' ] ],\n  [ 'lheading',   lheading ],\n  [ 'htmlblock',  htmlblock,  [ 'paragraph', 'blockquote' ] ],\n  [ 'table',      table,      [ 'paragraph' ] ],\n  [ 'deflist',    deflist,    [ 'paragraph' ] ],\n  [ 'paragraph',  paragraph ]\n];\n\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules$1.length; i++) {\n    this.ruler.push(_rules$1[i][0], _rules$1[i][1], {\n      alt: (_rules$1[i][2] || []).slice()\n    });\n  }\n}\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        break;\n      }\n    }\n\n    // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n\n      // two empty lines should stop the parser in list mode\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE    = /\\u00a0/g;\n\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state, lineStart = 0, lastTabPos = 0;\n  if (!str) { return []; }\n\n  // Normalize spaces\n  str = str.replace(SPACES_RE, ' ');\n\n  // Normalize newlines\n  str = str.replace(NEWLINES_RE, '\\n');\n\n  // Replace tabs with proper number of spaces (1..4)\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x5C/* \\ */:\n    case 0x60/* ` */:\n    case 0x2A/* * */:\n    case 0x5F/* _ */:\n    case 0x5E/* ^ */:\n    case 0x5B/* [ */:\n    case 0x5D/* ] */:\n    case 0x21/* ! */:\n    case 0x26/* & */:\n    case 0x3C/* < */:\n    case 0x3E/* > */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x40/* @ */:\n    case 0x7E/* ~ */:\n    case 0x2B/* + */:\n    case 0x3D/* = */:\n    case 0x3A/* : */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n}\n\n// Proceess '\\n'\n\nfunction newline(state, silent) {\n  var pmax, max, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        // Strip out all trailing spaces on this line.\n        for (var i = pmax - 2; i >= 0; i--) {\n          if (state.pending.charCodeAt(i) !== 0x20) {\n            state.pending = state.pending.substring(0, i + 1);\n            break;\n          }\n        }\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push({\n          type: 'softbreak',\n          level: state.level\n        });\n      }\n\n    } else {\n      state.push({\n        type: 'softbreak',\n        level: state.level\n      });\n    }\n  }\n\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n  state.pos = pos;\n  return true;\n}\n\n// Proceess escaped chars and hardbreaks\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nfunction escape(state, silent) {\n  var ch, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) { state.pending += state.src[pos]; }\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      }\n\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += '\\\\'; }\n  state.pos++;\n  return true;\n}\n\n// Parse backticks\n\nfunction backticks(state, silent) {\n  var start, max, marker, matchStart, matchEnd,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        state.push({\n          type: 'code',\n          content: state.src.slice(pos, matchStart)\n                              .replace(/[ \\n]+/g, ' ')\n                              .trim(),\n          block: false,\n          level: state.level\n        });\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += marker; }\n  state.pos += marker.length;\n  return true;\n}\n\n// Process ~~deleted text~~\n\nfunction del(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x7E/* ~ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x7E/* ~ */) { return false; }\n  if (nextChar === 0x7E/* ~ */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x7E/* ~ */) { pos++; }\n  if (pos > start + 3) {\n    // sequence of 4+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x7E/* ~ */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x7E/* ~ */ && lastChar !== 0x7E/* ~ */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '~~'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '~~'\n            stack++;\n          } // else {\n            //  // standalone ' ~~ ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'del_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'del_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process ++inserted text++\n\nfunction ins(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x2B/* + */) { return false; }\n  if (nextChar === 0x2B/* + */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '++'\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '++'\n            stack++;\n          } // else {\n            //  // standalone ' ++ ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'ins_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'ins_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process ==highlighted text==\n\nfunction mark(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x3D/* = */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 4 >= max) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x3D/* = */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x3D/* = */) { return false; }\n  if (nextChar === 0x3D/* = */) { return false; }\n  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n  pos = start + 2;\n  while (pos < max && state.src.charCodeAt(pos) === 0x3D/* = */) { pos++; }\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n    if (!silent) { state.pending += state.src.slice(start, pos); }\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x3D/* = */) {\n      if (state.src.charCodeAt(state.pos + 1) === 0x3D/* = */) {\n        lastChar = state.src.charCodeAt(state.pos - 1);\n        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n        if (nextChar !== 0x3D/* = */ && lastChar !== 0x3D/* = */) {\n          if (lastChar !== 0x20 && lastChar !== 0x0A) {\n            // closing '=='\n            stack--;\n          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n            // opening '=='\n            stack++;\n          } // else {\n            //  // standalone ' == ' indented with spaces\n            // }\n          if (stack <= 0) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({ type: 'mark_open', level: state.level++ });\n    state.parser.tokenize(state);\n    state.push({ type: 'mark_close', level: --state.level });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n}\n\n// Process *this* and _that_\n\nfunction isAlphaNum(code) {\n  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||\n         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||\n         (code >= 0x61 /* a */ && code <= 0x7A /* z */);\n}\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\nfunction scanDelims(state, start) {\n  var pos = start, lastChar, nextChar, count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n  if (pos >= max) { can_open = false; }\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\n\n    // check whitespace conditions\n    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }\n    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }\n\n    if (marker === 0x5F /* _ */) {\n      // check if we aren't inside the word\n      if (isAlphaNum(lastChar)) { can_open = false; }\n      if (isAlphaNum(nextChar)) { can_close = false; }\n    }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nfunction emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n  if (!res.can_open) {\n    state.pos += startCount;\n    if (!silent) { state.pending += state.src.slice(start, state.pos); }\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + startCount;\n  stack = [ startCount ];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          }\n\n          // assert(newCount > oldCount)\n          newCount -= oldCount;\n\n          if (stack.length === 0) { break; }\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) { stack.push(count); }\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_open', level: state.level++ });\n    }\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_open', level: state.level++ });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({ type: 'em_close', level: --state.level });\n    }\n    if (startCount === 2 || startCount === 3) {\n      state.push({ type: 'strong_close', level: --state.level });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n}\n\n// Process ~subscript~\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sub(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 2 >= max) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {\n      found = true;\n      break;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sub',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process ^superscript^\n\n// same as UNESCAPE_MD_RE plus a space\nvar UNESCAPE_RE$1 = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sup(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n  if (silent) { return false; } // don't run any pairs in validation mode\n  if (start + 2 >= max) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {\n      found = true;\n      break;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos);\n\n  // don't allow unescaped spaces/newlines inside\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  }\n\n  // found!\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sup',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE$1, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process [links](<to> \"stuff\")\n\n\nfunction links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21/* ! */) {\n    isImage = true;\n    marker = state.src.charCodeAt(++start);\n  }\n\n  if (marker !== 0x5B/* [ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    if (parseLinkDestination(state, pos)) {\n      href = state.linkContent;\n      pos = state.pos;\n    } else {\n      href = '';\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n      title = state.linkContent;\n      pos = state.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (code !== 0x20 && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n\n    // do not allow nested reference links\n    if (state.linkLevel > 0) { return false; }\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (code !== 0x20 && code !== 0x0A) { break; }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = start - 1;\n      }\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({ type: 'link_close', level: --state.level });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}\n\n// Process inline footnotes (^[...])\n\n\nfunction footnote_inline(state, silent) {\n  var labelStart,\n      labelEnd,\n      footnoteId,\n      oldLength,\n      max = state.posMax,\n      start = state.pos;\n\n  if (start + 2 >= max) { return false; }\n  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  labelStart = start + 2;\n  labelEnd = parseLinkLabel(state, start + 1);\n\n  // parser failed to find ']', so it's not a valid note\n  if (labelEnd < 0) { return false; }\n\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    if (!state.env.footnotes) { state.env.footnotes = {}; }\n    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n    footnoteId = state.env.footnotes.list.length;\n\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      level: state.level\n    });\n    state.linkLevel++;\n    oldLength = state.tokens.length;\n    state.parser.tokenize(state);\n    state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };\n    state.linkLevel--;\n  }\n\n  state.pos = labelEnd + 1;\n  state.posMax = max;\n  return true;\n}\n\n// Process footnote references ([^...])\n\nfunction footnote_ref(state, silent) {\n  var label,\n      pos,\n      footnoteId,\n      footnoteSubId,\n      max = state.posMax,\n      start = state.pos;\n\n  // should be at least 4 chars - \"[^x]\"\n  if (start + 3 > max) { return false; }\n\n  if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\n  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n  if (state.level >= state.options.maxNesting) { return false; }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) { return false; }\n    if (state.src.charCodeAt(pos) === 0x0A) { return false; }\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n      break;\n    }\n  }\n\n  if (pos === start + 2) { return false; } // no empty footnote labels\n  if (pos >= max) { return false; }\n  pos++;\n\n  label = state.src.slice(start + 2, pos - 1);\n  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\n\n  if (!silent) {\n    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n\n    if (state.env.footnotes.refs[':' + label] < 0) {\n      footnoteId = state.env.footnotes.list.length;\n      state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\n      state.env.footnotes.refs[':' + label] = footnoteId;\n    } else {\n      footnoteId = state.env.footnotes.refs[':' + label];\n    }\n\n    footnoteSubId = state.env.footnotes.list[footnoteId].count;\n    state.env.footnotes.list[footnoteId].count++;\n\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      subId: footnoteSubId,\n      level: state.level\n    });\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}\n\n// List of valid url schemas, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#autolinks\n\nvar url_schemas = [\n  'coap',\n  'doi',\n  'javascript',\n  'aaa',\n  'aaas',\n  'about',\n  'acap',\n  'cap',\n  'cid',\n  'crid',\n  'data',\n  'dav',\n  'dict',\n  'dns',\n  'file',\n  'ftp',\n  'geo',\n  'go',\n  'gopher',\n  'h323',\n  'http',\n  'https',\n  'iax',\n  'icap',\n  'im',\n  'imap',\n  'info',\n  'ipp',\n  'iris',\n  'iris.beep',\n  'iris.xpc',\n  'iris.xpcs',\n  'iris.lwz',\n  'ldap',\n  'mailto',\n  'mid',\n  'msrp',\n  'msrps',\n  'mtqp',\n  'mupdate',\n  'news',\n  'nfs',\n  'ni',\n  'nih',\n  'nntp',\n  'opaquelocktoken',\n  'pop',\n  'pres',\n  'rtsp',\n  'service',\n  'session',\n  'shttp',\n  'sieve',\n  'sip',\n  'sips',\n  'sms',\n  'snmp',\n  'soap.beep',\n  'soap.beeps',\n  'tag',\n  'tel',\n  'telnet',\n  'tftp',\n  'thismessage',\n  'tn3270',\n  'tip',\n  'tv',\n  'urn',\n  'vemmi',\n  'ws',\n  'wss',\n  'xcon',\n  'xcon-userid',\n  'xmlrpc.beep',\n  'xmlrpc.beeps',\n  'xmpp',\n  'z39.50r',\n  'z39.50s',\n  'adiumxtra',\n  'afp',\n  'afs',\n  'aim',\n  'apt',\n  'attachment',\n  'aw',\n  'beshare',\n  'bitcoin',\n  'bolo',\n  'callto',\n  'chrome',\n  'chrome-extension',\n  'com-eventbrite-attendee',\n  'content',\n  'cvs',\n  'dlna-playsingle',\n  'dlna-playcontainer',\n  'dtn',\n  'dvb',\n  'ed2k',\n  'facetime',\n  'feed',\n  'finger',\n  'fish',\n  'gg',\n  'git',\n  'gizmoproject',\n  'gtalk',\n  'hcp',\n  'icon',\n  'ipn',\n  'irc',\n  'irc6',\n  'ircs',\n  'itms',\n  'jar',\n  'jms',\n  'keyparc',\n  'lastfm',\n  'ldaps',\n  'magnet',\n  'maps',\n  'market',\n  'message',\n  'mms',\n  'ms-help',\n  'msnim',\n  'mumble',\n  'mvn',\n  'notes',\n  'oid',\n  'palm',\n  'paparazzi',\n  'platform',\n  'proxy',\n  'psyc',\n  'query',\n  'res',\n  'resource',\n  'rmi',\n  'rsync',\n  'rtmp',\n  'secondlife',\n  'sftp',\n  'sgn',\n  'skype',\n  'smb',\n  'soldat',\n  'spotify',\n  'ssh',\n  'steam',\n  'svn',\n  'teamspeak',\n  'things',\n  'udp',\n  'unreal',\n  'ut2004',\n  'ventrilo',\n  'view-source',\n  'webcal',\n  'wtai',\n  'wyciwyg',\n  'xfire',\n  'xri',\n  'ymsgr'\n];\n\n// Process autolinks '<protocol:...>'\n\n\n/*eslint max-len:0*/\nvar EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z.\\-]{1,25}):([^<>\\x00-\\x20]*)>/;\n\n\nfunction autolink(state, silent) {\n  var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) { return false; }\n\n  linkMatch = tail.match(AUTOLINK_RE);\n\n  if (linkMatch) {\n    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = normalizeLink(url);\n    if (!state.parser.validateLink(url)) { return false; }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({ type: 'link_close', level: state.level });\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  emailMatch = tail.match(EMAIL_RE);\n\n  if (emailMatch) {\n\n    url = emailMatch[0].slice(1, -1);\n\n    fullUrl = normalizeLink('mailto:' + url);\n    if (!state.parser.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({ type: 'link_close', level: state.level });\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n}\n\n// Regexps to match html elements\n\nfunction replace$1(regex, options) {\n  regex = regex.source;\n  options = options || '';\n\n  return function self(name, val) {\n    if (!name) {\n      return new RegExp(regex, options);\n    }\n    val = val.source || val;\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\n\nvar attr_name     = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;\n\nvar unquoted      = /[^\"'=<>`\\x00-\\x20]+/;\nvar single_quoted = /'[^']*'/;\nvar double_quoted = /\"[^\"]*\"/;\n\n/*eslint no-spaced-func:0*/\nvar attr_value  = replace$1(/(?:unquoted|single_quoted|double_quoted)/)\n                    ('unquoted', unquoted)\n                    ('single_quoted', single_quoted)\n                    ('double_quoted', double_quoted)\n                    ();\n\nvar attribute   = replace$1(/(?:\\s+attr_name(?:\\s*=\\s*attr_value)?)/)\n                    ('attr_name', attr_name)\n                    ('attr_value', attr_value)\n                    ();\n\nvar open_tag    = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\\s*\\/?>/)\n                    ('attribute', attribute)\n                    ();\n\nvar close_tag   = /<\\/[A-Za-z][A-Za-z0-9]*\\s*>/;\nvar comment     = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar processing  = /<[?].*?[?]>/;\nvar declaration = /<![A-Z]+\\s+[^>]*>/;\nvar cdata       = /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/;\n\nvar HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)\n  ('open_tag', open_tag)\n  ('close_tag', close_tag)\n  ('comment', comment)\n  ('processing', processing)\n  ('declaration', declaration)\n  ('cdata', cdata)\n  ();\n\n// Process html tags\n\n\nfunction isLetter$2(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\n\nfunction htmltag(state, silent) {\n  var ch, match, max, pos = state.pos;\n\n  if (!state.options.html) { return false; }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter$2(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) { return false; }\n\n  if (!silent) {\n    state.push({\n      type: 'htmltag',\n      content: state.src.slice(pos, pos + match[0].length),\n      level: state.level\n    });\n  }\n  state.pos += match[0].length;\n  return true;\n}\n\n// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\nfunction entity(state, silent) {\n  var ch, code, match, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        var decoded = decodeEntity(match[1]);\n        if (match[1] !== decoded) {\n          if (!silent) { state.pending += decoded; }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) { state.pending += '&'; }\n  state.pos++;\n  return true;\n}\n\n/**\n * Inline Parser `rules`\n */\n\nvar _rules$2 = [\n  [ 'text',            text ],\n  [ 'newline',         newline ],\n  [ 'escape',          escape ],\n  [ 'backticks',       backticks ],\n  [ 'del',             del ],\n  [ 'ins',             ins ],\n  [ 'mark',            mark ],\n  [ 'emphasis',        emphasis ],\n  [ 'sub',             sub ],\n  [ 'sup',             sup ],\n  [ 'links',           links ],\n  [ 'footnote_inline', footnote_inline ],\n  [ 'footnote_ref',    footnote_ref ],\n  [ 'autolink',        autolink ],\n  [ 'htmltag',         htmltag ],\n  [ 'entity',          entity ]\n];\n\n/**\n * Inline Parser class. Note that link validation is stricter\n * in Remarkable than what is specified by CommonMark. If you\n * want to change this you can use a custom validator.\n *\n * @api private\n */\n\nfunction ParserInline() {\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules$2.length; i++) {\n    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);\n  }\n\n  // Can be overridden with a custom validator\n  this.validateLink = validateLink;\n}\n\n/**\n * Skip a single token by running all rules in validation mode.\n * Returns `true` if any rule reports success.\n *\n * @param  {Object} `state`\n * @api privage\n */\n\nParserInline.prototype.skipToken = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var pos = state.pos;\n  var i, cached_pos;\n\n  if ((cached_pos = state.cacheGet(pos)) > 0) {\n    state.pos = cached_pos;\n    return;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (rules[i](state, true)) {\n      state.cacheSet(pos, state.pos);\n      return;\n    }\n  }\n\n  state.pos++;\n  state.cacheSet(pos, state.pos);\n};\n\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state`\n * @api private\n */\n\nParserInline.prototype.tokenize = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var end = state.posMax;\n  var ok, i;\n\n  while (state.pos < end) {\n\n    // Try all possible rules.\n    // On success, the rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, false);\n\n      if (ok) {\n        break;\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n/**\n * Parse the given input string.\n *\n * @param  {String} `str`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserInline.prototype.parse = function (str, options, env, outTokens) {\n  var state = new StateInline(str, this, options, env, outTokens);\n  this.tokenize(state);\n};\n\n/**\n * Validate the given `url` by checking for bad protocols.\n *\n * @param  {String} `url`\n * @return {Boolean}\n */\n\nfunction validateLink(url) {\n  var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file', 'data' ];\n  var str = url.trim().toLowerCase();\n  // Care about digital entities \"javascript&#x3A;alert(1)\"\n  str = replaceEntities(str);\n  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n    return false;\n  }\n  return true;\n}\n\n// Remarkable default options\n\nvar defaultConfig = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'block',\n        'inline',\n        'references',\n        'replacements',\n        'smartquotes',\n        'references',\n        'abbr2',\n        'footnote_tail'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fences',\n        'footnote',\n        'heading',\n        'hr',\n        'htmlblock',\n        'lheading',\n        'list',\n        'paragraph',\n        'table'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'del',\n        'emphasis',\n        'entity',\n        'escape',\n        'footnote_ref',\n        'htmltag',\n        'links',\n        'newline',\n        'text'\n      ]\n    }\n  }\n};\n\n// Remarkable default options\n\nvar fullConfig = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes:       '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight:     null,\n\n    maxNesting:    20            // Internal protection, recursion limit\n  },\n\n  components: {\n    // Don't restrict core/block/inline rules\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\n\n// Commonmark default options\n\nvar commonmarkConfig = {\n  options: {\n    html:         true,         // Enable HTML tags in source\n    xhtmlOut:     true,         // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkTarget:   '',           // set target to open link in\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'block',\n        'inline',\n        'references',\n        'abbr2'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fences',\n        'heading',\n        'hr',\n        'htmlblock',\n        'lheading',\n        'list',\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'emphasis',\n        'entity',\n        'escape',\n        'htmltag',\n        'links',\n        'newline',\n        'text'\n      ]\n    }\n  }\n};\n\n/**\n * Preset configs\n */\n\nvar config = {\n  'default': defaultConfig,\n  'full': fullConfig,\n  'commonmark': commonmarkConfig\n};\n\n/**\n * The `StateCore` class manages state.\n *\n * @param {Object} `instance` Remarkable instance\n * @param {String} `str` Markdown string\n * @param {Object} `env`\n */\n\nfunction StateCore(instance, str, env) {\n  this.src = str;\n  this.env = env;\n  this.options = instance.options;\n  this.tokens = [];\n  this.inlineMode = false;\n\n  this.inline = instance.inline;\n  this.block = instance.block;\n  this.renderer = instance.renderer;\n  this.typographer = instance.typographer;\n}\n\n/**\n * The main `Remarkable` class. Create an instance of\n * `Remarkable` with a `preset` and/or `options`.\n *\n * @param {String} `preset` If no preset is given, `default` is used.\n * @param {Object} `options`\n */\n\nfunction Remarkable(preset, options) {\n  if (typeof preset !== 'string') {\n    options = preset;\n    preset = 'default';\n  }\n\n  if (options && options.linkify != null) {\n    console.warn(\n      'linkify option is removed. Use linkify plugin instead:\\n\\n' +\n      'import Remarkable from \\'remarkable\\';\\n' +\n      'import linkify from \\'remarkable/linkify\\';\\n' +\n      'new Remarkable().use(linkify)\\n'\n    );\n  }\n\n  this.inline   = new ParserInline();\n  this.block    = new ParserBlock();\n  this.core     = new Core();\n  this.renderer = new Renderer();\n  this.ruler    = new Ruler();\n\n  this.options  = {};\n  this.configure(config[preset]);\n  this.set(options || {});\n}\n\n/**\n * Set options as an alternative to passing them\n * to the constructor.\n *\n * ```js\n * md.set({typographer: true});\n * ```\n * @param {Object} `options`\n * @api public\n */\n\nRemarkable.prototype.set = function (options) {\n  assign(this.options, options);\n};\n\n/**\n * Batch loader for components rules states, and options\n *\n * @param  {Object} `presets`\n */\n\nRemarkable.prototype.configure = function (presets) {\n  var self = this;\n\n  if (!presets) { throw new Error('Wrong `remarkable` preset, check name/content'); }\n  if (presets.options) { self.set(presets.options); }\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enable(presets.components[name].rules, true);\n      }\n    });\n  }\n};\n\n/**\n * Use a plugin.\n *\n * ```js\n * var md = new Remarkable();\n *\n * md.use(plugin1)\n *   .use(plugin2, opts)\n *   .use(plugin3);\n * ```\n *\n * @param  {Function} `plugin`\n * @param  {Object} `options`\n * @return {Object} `Remarkable` for chaining\n */\n\nRemarkable.prototype.use = function (plugin, options) {\n  plugin(this, options);\n  return this;\n};\n\n\n/**\n * Parse the input `string` and return a tokens array.\n * Modifies `env` with definitions data.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\nRemarkable.prototype.parse = function (str, env) {\n  var state = new StateCore(this, str, env);\n  this.core.process(state);\n  return state.tokens;\n};\n\n/**\n * The main `.render()` method that does all the magic :)\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {String} Rendered HTML.\n */\n\nRemarkable.prototype.render = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parse(str, env), this.options, env);\n};\n\n/**\n * Parse the given content `string` as a single string.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\nRemarkable.prototype.parseInline = function (str, env) {\n  var state = new StateCore(this, str, env);\n  state.inlineMode = true;\n  this.core.process(state);\n  return state.tokens;\n};\n\n/**\n * Render a single content `string`, without wrapping it\n * to paragraphs\n *\n * @param  {String} `str`\n * @param  {Object} `env`\n * @return {String}\n */\n\nRemarkable.prototype.renderInline = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parseInline(str, env), this.options, env);\n};\n\nexport { Remarkable, utils };\n"]},"metadata":{},"sourceType":"module"}