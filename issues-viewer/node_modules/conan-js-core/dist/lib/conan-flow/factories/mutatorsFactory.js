import { StatusLikeParser } from "../domain/status";
import { BindBackType } from "../logic/flowAnchor";
import { Proxyfier } from "../../conan-utils/proxyfier";
import { FlowEventLevel, FlowEventNature, FlowEventSource, FlowEventType } from "../domain/flowRuntimeEvents";
export class MutatorsFactory {
    static createDefaultStepsDef(flowAnchor) {
        return (getData) => ({
            $update(reducer) {
                let finalValue;
                let flowThread = flowAnchor.currentThread.flowThread;
                let tracker = flowThread.flowOrchestrator.createRuntimeTracker(flowThread.flowController, FlowEventSource.CONTEXT, FlowEventType.USER_CODE, finalValue).start();
                if (typeof reducer !== 'function') {
                    finalValue = reducer;
                }
                else {
                    finalValue = reducer(getData());
                }
                tracker.debug(`$update`, finalValue).end();
                return finalValue;
            }
        });
    }
    static createDefaultTransitionDef(flowAnchor) {
        return (() => ({
            $toStatus(toStatus) {
                let status = StatusLikeParser.parse(toStatus);
                let flowThread = flowAnchor.currentThread.flowThread;
                flowThread.flowOrchestrator.createRuntimeTracker(flowThread.flowController, FlowEventSource.CONTEXT, FlowEventType.USER_CODE, status).start().debug(`$toStatus`, status).end();
                return status;
            }
        }));
    }
    static createDefaultSteps(statusName, flowAnchor) {
        return this.createSteps(statusName, flowAnchor, this.createDefaultStepsDef(flowAnchor));
    }
    static createTransitions(statusName, flowAnchor, userTransitions) {
        let defaultTransitionDef = this.createDefaultTransitionDef(flowAnchor);
        return this.doCreateTransitions(statusName, flowAnchor, userTransitions ? [userTransitions, defaultTransitionDef] : [defaultTransitionDef]);
    }
    static createSteps(statusName, flowAnchor, userStepsDef) {
        let defaultStepDef = this.createDefaultStepsDef(flowAnchor);
        return this.doCreateSteps(statusName, flowAnchor, userStepsDef ? [userStepsDef, defaultStepDef] : [defaultStepDef]);
    }
    static doCreateSteps(statusName, flowAnchor, allStepsDef) {
        let dataProducerFn = flowAnchor.getDataFn(statusName);
        let allSteps = {};
        allStepsDef.forEach(it => {
            let thisStep = it(dataProducerFn);
            allSteps = Object.assign(Object.assign({}, allSteps), thisStep);
        });
        return this.bindToAnchor(statusName, flowAnchor, allSteps, BindBackType.STEP);
    }
    static doCreateTransitions(statusName, flowAnchor, allTransitionsDef) {
        let statusDataProducerFn = flowAnchor.getStatusDataProducerFn();
        let allTransitions = {};
        allTransitionsDef.forEach(it => {
            let thisTransitions = it(statusDataProducerFn);
            allTransitions = Object.assign(Object.assign({}, allTransitions), thisTransitions);
        });
        return this.bindToAnchor(statusName, flowAnchor, allTransitions, BindBackType.TRANSITION);
    }
    static bindToAnchor(expectedStatusName, flowAnchor, toBind, type) {
        return Proxyfier.proxy(toBind, (originalCall, metadata) => {
            let flowController = flowAnchor.currentThread.flowThread.flowController;
            let tracker = flowAnchor.currentThread.flowThread.flowOrchestrator.createRuntimeTracker(flowController, FlowEventSource.CONTEXT, FlowEventType.USER_REACTIONS, flowController.flowDef.nature).start();
            let isMainNature = flowController.flowDef.nature === FlowEventNature.MAIN;
            let level = isMainNature && metadata.methodName !== '$update' ? FlowEventLevel.MILESTONE : FlowEventLevel.DEBUG;
            tracker.withLevel(level, `calling: ${metadata.methodName}`, (typeof metadata.payload === "object" ? metadata.payload : '[reducer]'));
            let newState = originalCall();
            flowAnchor.bindBack(expectedStatusName, {
                statusName: flowAnchor.currentStatus.name,
                methodName: metadata.methodName,
                payload: metadata.payload,
                result: newState,
            }, type);
            tracker.end();
            return newState;
        });
    }
}
//# sourceMappingURL=mutatorsFactory.js.map