import { StatusLikeParser } from "../domain/status";
import { StatusEventType } from "../domain/flowEvents";
export class FlowEventsTracker {
    constructor() {
        this.eventsByStatus = {};
        this.events = [];
    }
    addTransition(transition, isStep) {
        let lastEvent;
        let intoStatus = StatusLikeParser.parse(transition.into);
        if (!isStep) {
            lastEvent = {
                type: StatusEventType.TRANSITION,
                fromStatus: this.currentStatus.name,
                intoStatus: intoStatus,
                transitionName: transition.transitionName,
                transitionPayload: transition.payload
            };
        }
        else {
            lastEvent = {
                type: StatusEventType.STEP,
                reducerName: transition.transitionName,
                newData: intoStatus.data,
                reducerPayload: transition.payload
            };
        }
        this.lastEvent = lastEvent;
        this.process(lastEvent);
    }
    addStateFromStatus(stateEvent) {
        this.lastEvent = stateEvent;
        this.process(stateEvent);
    }
    addProcessingStatus(statusRequest, isStep) {
        let lastEvent;
        if (!isStep) {
            lastEvent = {
                type: StatusEventType.PROCESSING_STATUS,
                status: statusRequest.status
            };
        }
        else {
            lastEvent = {
                type: StatusEventType.PROCESSING_STATE,
                data: statusRequest.status.data
            };
        }
        this.currentStatus = statusRequest.status;
        this.lastEvent = lastEvent;
        this.process(lastEvent);
    }
    settleProcessingStatus(statusRequest, isStep) {
        if (!isStep) {
            if (this.lastEvent.status !== statusRequest.status) {
                throw new Error(`unexpected error settling events`);
            }
            this.lastEvent.type = StatusEventType.STATUS;
            this.addStateFromStatus({
                data: statusRequest.status.data,
                type: StatusEventType.STATE
            });
        }
        else {
            if (this.lastEvent.data !== statusRequest.status.data) {
                throw new Error(`unexpected error settling events`);
            }
            this.lastEvent.type = StatusEventType.STATE;
            this.eventsByStatus[this.currentStatus.name].lastState = statusRequest.status.data;
        }
    }
    process(lastEvent) {
        if (this.eventsByStatus[this.currentStatus.name] == null) {
            this.eventsByStatus[this.currentStatus.name] = {
                allEvents: [],
                statusName: this.currentStatus.name,
                lastState: undefined
            };
        }
        let eventWithStatusInfo = {
            event: lastEvent,
            statusName: this.currentStatus.name
        };
        this.eventsByStatus[this.currentStatus.name].allEvents.push(eventWithStatusInfo);
        if (lastEvent.type === StatusEventType.STATE || lastEvent.type === StatusEventType.PROCESSING_STATE) {
            this.eventsByStatus[this.currentStatus.name].lastState = lastEvent.data;
        }
        this.events.push(eventWithStatusInfo);
    }
    serializeStatesWithStatus(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATE] }));
    }
    serializeStates(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATE] })).map(it => it.event);
    }
    serializeStatuses(filterOptions) {
        return this.serializeWithStatusInfo(Object.assign(Object.assign({}, filterOptions), { eventTypes: [StatusEventType.STATUS] })).map(it => it.event);
    }
    serialize(filterOptions) {
        return this.serializeWithStatusInfo(filterOptions).map(it => it.event);
    }
    serializeWithStatusInfo(filterOptions) {
        if (!filterOptions) {
            return this.events;
        }
        let filtered = [];
        this.events.forEach(eventWithStatusInfo => {
            let toBeIncluded = true;
            if (!toBeIncluded)
                return;
            if (filterOptions.excludeInit) {
                if (this.eventsByStatus['$init'].allEvents.indexOf(eventWithStatusInfo) > -1) {
                    toBeIncluded = false;
                }
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.excludeStop) {
                if (this.eventsByStatus['$stop'] && this.eventsByStatus['$stop'].allEvents.indexOf(eventWithStatusInfo) > -1) {
                    toBeIncluded = false;
                }
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.statuses) {
                filterOptions.statuses.forEach(status => {
                    if (toBeIncluded)
                        return;
                    if (this.eventsByStatus[status].allEvents.indexOf(eventWithStatusInfo) === -1) {
                        toBeIncluded = false;
                    }
                });
            }
            if (!toBeIncluded)
                return;
            if (filterOptions.eventTypes) {
                if (filterOptions.eventTypes.indexOf(eventWithStatusInfo.event.type) === -1) {
                    toBeIncluded = false;
                }
            }
            if (toBeIncluded) {
                filtered.push(eventWithStatusInfo);
            }
        });
        return filtered;
    }
    getLastStates() {
        let lastStates = {};
        Object.keys(this.eventsByStatus).forEach(statusKey => {
            lastStates[statusKey] = this.eventsByStatus[statusKey].lastState;
        });
        return lastStates;
    }
    getLastState(statusName) {
        let eventsByStatus = this.eventsByStatus[statusName];
        if (eventsByStatus == null)
            return undefined;
        return eventsByStatus.lastState;
    }
}
//# sourceMappingURL=flowEventsTracker.js.map