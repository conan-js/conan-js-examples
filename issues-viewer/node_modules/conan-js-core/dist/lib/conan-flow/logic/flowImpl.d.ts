import { Mutators, VoidMutators } from "../domain/mutators";
import { FlowDef, ICallback, IConsumer, IKeyValuePairs } from "../../index";
import { FlowAnchor } from "./flowAnchor";
import { FlowOrchestrator } from "./flowOrchestrator";
import { Status, StatusLike } from "../domain/status";
import { FlowEventNature } from "../domain/flowRuntimeEvents";
import { Asap } from "../../conan-utils/asap";
import { Transition } from "../domain/transitions";
import { ReactionCb, ReactionDef } from "../def/reactionDef";
import { StatusDef } from "../def/status/statusDef";
import { Flow } from "../domain/flow";
import { FlowEventsTracker } from "./flowEventsTracker";
import { Context } from "../domain/context";
import { DeferLike } from "../domain/defer";
export declare class FlowImpl<STATUSES, MUTATORS extends Mutators<STATUSES> = VoidMutators<STATUSES>> implements Flow<STATUSES, MUTATORS> {
    readonly flowDef: FlowDef<STATUSES, MUTATORS>;
    private readonly flowAnchor;
    private readonly flowOrchestrator;
    isRunning: boolean;
    private flowThread;
    constructor(flowDef: FlowDef<STATUSES, MUTATORS>, flowAnchor: FlowAnchor<STATUSES, MUTATORS>, flowOrchestrator: FlowOrchestrator);
    start(initialStatus?: StatusLike<STATUSES>): this;
    requestStatus(statusLike: StatusLike<STATUSES>): void;
    requestState(statusName: string, data: any): void;
    requestTransition(transition: Transition): this;
    requestStep(statusName: string, reducerName: string, payload: any, data: any): void;
    stop(eventsCb?: IConsumer<FlowEventsTracker<STATUSES>>): this;
    alwaysOn<STATUS extends keyof STATUSES & keyof MUTATORS>(stateName: STATUS, def: ReactionCb<STATUSES, STATUS, MUTATORS>): this;
    onceOnInit(def: ReactionCb<STATUSES, any, MUTATORS>): this;
    onceOnStop(def: ReactionCb<STATUSES, any, MUTATORS>): this;
    onceOn<STATUS extends keyof STATUSES & keyof MUTATORS>(stateName: STATUS, def: ReactionCb<STATUSES, STATUS, MUTATORS>): this;
    addReaction<STATUS extends keyof STATUSES & MUTATORS>(statusName: STATUS, reaction: ReactionDef<STATUSES, STATUS, MUTATORS>): this;
    private addReactionNext;
    getReactions<STATUS extends keyof STATUSES & keyof MUTATORS>(statusName: STATUS): ReactionDef<STATUSES, STATUS, MUTATORS>[];
    getCurrentStatusName(): string;
    getEvents(): FlowEventsTracker<STATUSES>;
    getName(): string;
    getState(): any;
    getStatusData(): {
        [STATUS in keyof STATUSES]?: STATUSES[STATUS];
    };
    onInit(): StatusDef<STATUSES, any>;
    on<STATUS extends keyof STATUSES>(statusName: STATUS): StatusDef<STATUSES, STATUS>;
    getStatusDefs(): IKeyValuePairs<StatusDef<STATUSES, any>>;
    removeReaction<STATUS extends keyof STATUSES & keyof MUTATORS>(statusName: STATUS, reactionToRemove: ReactionDef<STATUSES, STATUS, MUTATORS>): void;
    processReactions<STATUS extends keyof STATUSES & keyof MUTATORS>(statusName: STATUS): this;
    getStateData(): any;
    reactOnStatusChanged(customReaction: IConsumer<Status<STATUSES>>): this;
    runIf<STATUS extends keyof STATUSES & keyof MUTATORS>(statusName: STATUS, reaction: ReactionDef<STATUSES, STATUS, MUTATORS>, elseIf?: ICallback): void;
    private doRun;
    assertOn<STATUS extends keyof STATUSES>(status: STATUS, then?: IConsumer<Context<STATUSES, STATUS, MUTATORS>>): this;
    chainInto<STATUS_FROM extends keyof STATUSES, STATUS_TO extends keyof STATUSES>(statusFrom: STATUS_FROM, statusTo: STATUS_TO, mutatorsCb: IConsumer<MUTATORS[STATUS_FROM]>): Asap<Context<STATUSES, STATUS_TO, MUTATORS>>;
    deferInto<STATUS_FROM extends keyof STATUSES, STATUS_TO extends keyof STATUSES>(statusFrom: STATUS_FROM, statusTo: STATUS_TO, mutatorsCbAsapLike: DeferLike<MUTATORS[STATUS_FROM]>): Asap<Context<STATUSES, STATUS_TO, MUTATORS>>;
    changeLoggingNature(nature: FlowEventNature): void;
}
