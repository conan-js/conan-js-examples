import { FlowEventTiming, FlowEventLevel } from "../domain/flowRuntimeEvents";
export class FlowRuntimeTracker {
    constructor(orchestrator, event) {
        this.orchestrator = orchestrator;
        this.event = event;
    }
    end(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.END, shortDesc, payload);
    }
    cancel(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.CANCEL, shortDesc, payload);
    }
    start(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.START, shortDesc, payload);
    }
    debug(shortDesc, payload) {
        return this.doTick(FlowEventLevel.DEBUG, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    info(shortDesc, payload) {
        return this.doTick(FlowEventLevel.INFO, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    milestone(shortDesc, payload) {
        return this.doTick(FlowEventLevel.MILESTONE, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    withLevel(level, shortDesc, payload) {
        return this.doTick(level, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    doTick(level, timing, shortDesc, payload) {
        let event = Object.assign(Object.assign(Object.assign({}, this.event), { shortDesc,
            timing,
            level }), (payload != null ? { payload } : undefined));
        this.orchestrator.onRuntimeEvent(this, event);
        return this;
    }
}
//# sourceMappingURL=flowRuntimeTracker.js.map