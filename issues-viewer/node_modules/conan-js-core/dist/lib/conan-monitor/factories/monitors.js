import { MonitorFacade } from "../domain/monitorFacade";
import { MonitorImpl } from "../logic/monitorImpl";
import { Threads } from "../../conan-thread/factories/threads";
import { MonitorStatus } from "../domain/monitorInfo";
import { FlowEventNature, FlowEventTiming, FlowEventType } from "../../conan-flow/domain/flowRuntimeEvents";
export class Monitors {
    static create(data) {
        let asyncThread = this.createAsyncThread(data);
        let mainThread = Threads.create(Object.assign(Object.assign({}, data), { nature: data.nature, pipelineListener: (event) => {
                if (event.runtimeEvent === FlowEventType.MONITORING) {
                    if (event.timing === FlowEventTiming.START) {
                        asyncThread.do.tick(event.payload);
                    }
                    else if (event.timing === FlowEventTiming.END) {
                        asyncThread.do.unTick(event.payload, false);
                    }
                    else if (event.timing === FlowEventTiming.CANCEL) {
                        asyncThread.do.unTick(event.payload, true);
                    }
                    return;
                }
            } }));
        let monitorImpl = new MonitorImpl(mainThread, asyncThread);
        return new MonitorFacade(monitorImpl, mainThread.actions);
    }
    static createAsyncThread(data) {
        return Threads.create({
            name: `async[${data.name}]`,
            actions: thread => ({
                tick(toMonitor) {
                    thread.reducers.$update(current => ({
                        status: MonitorStatus.ASYNC_START,
                        currentAction: toMonitor,
                        inProgressActions: [...current.inProgressActions, toMonitor]
                    }));
                },
                unTick(toMonitor, cancelled) {
                    thread.reducers.$update(current => {
                        return ({
                            status: cancelled ? MonitorStatus.ASYNC_CANCELLED : MonitorStatus.ASYNC_FULFILLED,
                            currentAction: toMonitor,
                            inProgressActions: current.inProgressActions.filter(it => it !== toMonitor)
                        });
                    });
                    if (thread.getData().inProgressActions.length === 0)
                        thread.reducers.$update(current => ({
                            inProgressActions: [],
                            currentAction: undefined,
                            status: MonitorStatus.IDLE
                        }));
                }
            }),
            initialData: {
                inProgressActions: [],
                status: MonitorStatus.IDLE,
                currentAction: undefined
            },
            nature: FlowEventNature.AUX
        });
    }
}
//# sourceMappingURL=monitors.js.map