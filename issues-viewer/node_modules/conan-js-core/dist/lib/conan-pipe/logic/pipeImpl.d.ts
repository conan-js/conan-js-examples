import { ThreadFacade } from "../../conan-thread/domain/threadFacade";
import { Asap, IBiConsumer, IConsumer, Reducers } from "../..";
import { Thread } from "../../conan-thread/logic/thread";
import { DataReactionDef, DataReactionLock } from "../../conan-thread/domain/dataReaction";
import { FlowEventsTracker } from "../../conan-flow/logic/flowEventsTracker";
import { Context } from "../../conan-flow/domain/context";
import { ThreadFlow } from "../../conan-thread/factories/threads";
import { DefaultStepFn } from "../../conan-flow/domain/steps";
import { DefaultActionsFn } from "../../conan-flow/domain/actions";
import { PipeThreadDef } from "../domain/pipeThreadDef";
import { FlowEventNature, FlowEventType } from "../../conan-flow/domain/flowRuntimeEvents";
import { FlowRuntimeTracker } from "../../conan-flow/logic/flowRuntimeTracker";
import { StateDef } from "../../conan-thread/domain/stateDef";
export declare class PipeImpl<DATA, REDUCERS extends Reducers<DATA> = {}, ACTIONS = void> implements ThreadFacade<DATA, REDUCERS, ACTIONS> {
    private readonly name;
    private readonly pipeConnector;
    private readonly pipeThreadDef?;
    private baseThread;
    constructor(name: string, pipeConnector: IConsumer<ThreadFacade<DATA, REDUCERS, ACTIONS>>, pipeThreadDef?: PipeThreadDef<DATA, REDUCERS, ACTIONS>);
    addReaction(def: DataReactionDef<DATA>): DataReactionLock;
    chain(mutatorsCb: IConsumer<REDUCERS>): Asap<DATA>;
    getData(): DATA;
    getEvents(): FlowEventsTracker<{
        nextData: DATA;
    }>;
    getName(): string;
    next(cb: (onNext: Context<ThreadFlow<DATA>, "nextData", {
        nextData: REDUCERS;
    }>) => void): void;
    start(): this;
    stop(eventsConsumer: (events: any) => void): this;
    get reducers(): REDUCERS & DefaultStepFn<DATA>;
    get isRunning(): boolean;
    get do(): DefaultActionsFn<DATA> & ACTIONS & DefaultStepFn<DATA> & REDUCERS;
    get actions(): ACTIONS;
    get thread(): Thread<DATA, REDUCERS>;
    changeLoggingNature(nature: FlowEventNature): void;
    log(msg: string): void;
    once(reaction: IConsumer<DATA>, name?: string): this;
    createRuntimeTracker(runtimeEvent: FlowEventType, payload?: any): FlowRuntimeTracker;
    monitor<T>(toMonitor: Asap<T>, thenCallback: IBiConsumer<T, REDUCERS & DefaultStepFn<T>>, name?: string, payload?: any): Asap<DATA>;
    addReactionNext(def: DataReactionDef<DATA>): this;
    getDefinition(): StateDef<DATA, REDUCERS, ACTIONS>;
}
