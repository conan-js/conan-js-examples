import * as React from "react";
import { MonitorStatus } from "../../conan-monitor/domain/monitorInfo";
export const ReactStateContext = React.createContext(null);
export class StateMapConnect extends React.Component {
    constructor(props) {
        super(props);
        this._isMounted = false;
        this.lastMonitorInfo = undefined;
        this.lastState = undefined;
        let needsDefault = true;
        let name = this.props.into.prototype ? this.props.into.prototype : this.props.into.name;
        this._mainDataReactionLock = this.props.from.addDataReaction({
            name: `connect | ${name}`,
            dataConsumer: (data) => {
                this.lastState = data;
                let lastProps = this.props.mapper(data, Object.assign({}, this.props.from.actions), this.lastMonitorInfo);
                if (this._isMounted) {
                    this.setState(lastProps);
                }
                else {
                    needsDefault = false;
                    this.state = lastProps;
                }
            },
        });
        this._asyncDataReactionLock = this.props.from.addAsyncReaction({
            name: `connect monitor| ${name}`,
            dataConsumer: (monitorInfo) => {
                this.lastMonitorInfo = monitorInfo;
                let lastProps = this.props.mapper(this.lastState, Object.assign({}, this.props.from.actions), monitorInfo);
                if (this._isMounted) {
                    this.setState(lastProps);
                }
                else {
                    needsDefault = false;
                    this.state = lastProps;
                }
            }
        });
        if (needsDefault && this.props.fallbackValue) {
            this.state = this.props.fallbackValue(this.props.from.actions);
        }
    }
    componentDidMount() {
        this._isMounted = true;
    }
    componentWillUnmount() {
        this._isMounted = false;
        this._mainDataReactionLock.release();
        if (this._asyncDataReactionLock) {
            this._asyncDataReactionLock.release();
        }
    }
    render() {
        let Comp = this.props.into;
        return (React.createElement(ReactStateContext.Provider, { value: this.props.from },
            React.createElement(Comp, Object.assign({}, this.state))));
    }
}
export const StateConnect = (props) => {
    return (React.createElement(StateMapConnect, { mapper: (data, actions, monitorInfo) => ({ data, actions, monitorInfo }), into: props.into, from: props.from, fallbackValue: (actions) => ({
            data: props.fallbackValue,
            actions,
            monitorInfo: {
                status: MonitorStatus.IDLE
            }
        }) }));
};
export const stateConnect = (from, into, fallbackValue) => {
    return React.createElement(StateConnect, { from: from, into: into, fallbackValue: fallbackValue });
};
export const stateMapConnect = (from, into, mapper, fallbackValue) => {
    return React.createElement(StateMapConnect, { from: from, into: into, fallbackValue: fallbackValue, mapper: mapper });
};
//# sourceMappingURL=stateConnect.js.map