import * as React from "react";
import { StateConnect, StateMapConnect } from "./connect/stateConnect";
import { StateLive } from "./live/stateLive";
import { MonitorFacade } from "../conan-monitor/domain/monitorFacade";
import { Pipes } from "../conan-pipe/factories/pipes";
import { ThreadFacade } from "../conan-thread/domain/threadFacade";
import { Objects } from "../conan-utils/objects";
import { FlowEventNature } from "../conan-flow/domain/flowRuntimeEvents";
export class ConanState {
    constructor(state) {
        this.state = state;
    }
    getName() {
        return this.state.getName();
    }
    connectMap(toConnect, mapper) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: mapper });
    }
    connectData(toConnect) {
        return React.createElement(StateMapConnect, { from: this, into: toConnect, mapper: (data) => data });
    }
    connect(toConnect) {
        return React.createElement(StateConnect, { from: this, into: toConnect });
    }
    connectLive(renderer, fallbackValue) {
        return React.createElement(StateLive, { from: this, renderer: renderer, fallbackValue: fallbackValue });
    }
    addAsyncReaction(def) {
        if (this.isThreadBased()) {
            return;
        }
        return this.asMonitor().addAsyncReaction(def);
    }
    addDataReaction(def) {
        return this.state.addReaction(def);
    }
    get do() {
        return this.state.do;
    }
    start() {
        this.state.start();
        return this;
    }
    stop(eventsConsumer) {
        this.state.stop(eventsConsumer);
        return this;
    }
    get actions() {
        return this.state.actions;
    }
    getData() {
        return this.state.getData();
    }
    asyncMerge(baseValue, monitorMerger, dataMerger) {
        if (this.isThreadBased()) {
            throw new Error(`this conan state is not ready for async`);
        }
        this.asMonitor().activateAsyncLog();
        let mergedThread = Pipes.fromMonitor(`monitor[${this.getName()}]`, this.state, monitorMerger, dataMerger, {
            initialData: baseValue,
            nature: FlowEventNature.HELPER
        });
        return new ConanState(new ThreadFacade(mergedThread, this.actions));
    }
    filter(mapper) {
        let state = Pipes.filter(`filter=>${this.getName()}`, this.isThreadBased() ? this.asThread() : this.asMonitor().mainThread, mapper);
        return new ConanState(state);
    }
    map(mapper) {
        let state = Pipes.map(`map=>${this.getName()}`, this.isThreadBased() ? this.asThread() : this.asMonitor().mainThread, mapper);
        return new ConanState(state);
    }
    merge(toMerge$, merger) {
        let state = Pipes.merge(`merge=>${this.getName()}`, this.isThreadBased() ? this.asThread() : this.asMonitor().mainThread, merger, toMerge$.asThread(), (right, left, current) => merger(left, right, current));
        return new ConanState(state);
    }
    tuple(toMerge$) {
        let state = Pipes.tupleCombine(`mergeTuple=>${this.getName()}`, this.isThreadBased() ? this.asThread() : this.asMonitor().mainThread, toMerge$.asThread());
        return new ConanState(state);
    }
    isThreadBased() {
        return !this.isMonitorBased();
    }
    isMonitorBased() {
        return this.state instanceof MonitorFacade;
    }
    asThread() {
        if (this.isThreadBased()) {
            return this.state;
        }
        return this.asMonitor().mainThread;
    }
    asMonitor() {
        return this.state;
    }
    static combine(name, fromState, pipeThreadDef) {
        let threadFacade = Pipes.combine(name, Objects.mapKeys(fromState, conanState => conanState.asThread()), pipeThreadDef);
        return new ConanState(threadFacade);
    }
}
//# sourceMappingURL=conanState.js.map