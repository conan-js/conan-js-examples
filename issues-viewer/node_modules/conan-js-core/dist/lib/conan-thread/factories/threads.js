import { ThreadImpl } from "../logic/thread";
import { Flows } from "../../conan-flow/factories/flows";
import { ThreadFacade } from "../domain/threadFacade";
import { AsapParser } from "../../conan-utils/asap";
import { Proxyfier } from "../../conan-utils/proxyfier";
import { MethodFinder } from "../../conan-utils/methodFinder";
import { FlowEventNature } from "../../conan-flow/domain/flowRuntimeEvents";
export class Threads {
    static create(data, actions) {
        let flow = Flows.createController(Object.assign(Object.assign({ name: data.name, statuses: {
                nextData: Object.assign(Object.assign({}, (data.reducers ? { steps: data.reducers } : undefined)), (data.reactions ? { reactions: data.reactions } : undefined))
            } }, (!data.hasOwnProperty('initialData') ? undefined : {
            initialStatus: AsapParser.from(data.initialData).map(data => ({
                name: 'nextData',
                data
            }))
        })), { pipelineListener: data.pipelineListener, nature: data.nature ? data.nature : FlowEventNature.MAIN }));
        let threadImpl = new ThreadImpl(flow, data);
        if (data.actions && data.autoBind) {
            throw new Error(`you can only use actions or autoBind. Both in conjunction is illegal`);
        }
        let threadFacade;
        if (actions != null) {
            threadFacade = new ThreadFacade(threadImpl, actions);
        }
        else if (data.autoBind) {
            let methodsToProxy = [];
            let autoBindWrapper = Object.assign({}, data.autoBind);
            Object.keys(threadImpl.reducers).forEach(reducerWithDollar => {
                let actionName = reducerWithDollar.substring(1, reducerWithDollar.length);
                if (MethodFinder.exists(data.autoBind, actionName)) {
                    autoBindWrapper[actionName] = (...params) => {
                        return data.autoBind[actionName](...params);
                    };
                    methodsToProxy.push(actionName);
                }
                else {
                    autoBindWrapper[actionName] = (...params) => {
                        return threadImpl.chain(reducers => reducers[reducerWithDollar](...params));
                    };
                }
            });
            threadFacade = new ThreadFacade(threadImpl, Proxyfier.proxy(autoBindWrapper, (original, metadata) => {
                if (methodsToProxy.indexOf(metadata.methodName) === -1) {
                    return original();
                }
                return threadImpl.monitor(original(), (value, reducers) => reducers[`$${metadata.methodName}`](value), metadata.methodName, metadata.payload);
            }));
        }
        else {
            let actions = data.actions ? data.actions(threadImpl) : {};
            Object.keys(threadImpl.reducers).forEach(reducerKey => {
                let matchingActionName = reducerKey.substring(1, reducerKey.length);
                if (!actions[matchingActionName]) {
                    actions[matchingActionName] = (...params) => {
                        return threadImpl.chain(reducers => reducers[reducerKey](...params), `${threadFacade.getName()}.do.${matchingActionName} ()`);
                    };
                }
            });
            actions['updateAsap'] = (reducerAsap, name) => {
                let asap;
                if (!('then' in reducerAsap)) {
                    asap = reducerAsap(threadImpl.getData());
                }
                else {
                    asap = reducerAsap;
                }
                return threadImpl.monitor(asap, (value, reducers) => reducers.$update(value), name == null ? 'updateAsap' : name);
            };
            threadFacade = new ThreadFacade(threadImpl, actions);
        }
        if (!data.cancelAutoStart) {
            threadFacade.start();
        }
        return threadFacade;
    }
}
//# sourceMappingURL=threads.js.map