"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var InjectableType,React=require("react");class DynamicOrStatics{static result(t,e){return"function"==typeof t?t(e):t}}class Strings{static firstCharToLowerCase(t){return t.substring(0,1).toLowerCase()+t.substring(1,t.length)}static firstCharToUpperCase(t){return t.substring(0,1).toUpperCase()+t.substring(1,t.length)}static camelCaseWithPrefix(t,e){return t+this.firstCharToUpperCase(e)}static repeat(t,e){let a="";for(let n=0;n<e;n++)a+=t;return a}static padEnd(t,e){if(null==t)return t;let a=e-t.length;if(a<1){let a="...",n=1,r=n+(t.length+a.length-e);return t.substring(0,n)+a+t.substring(r,t.length)}return t+" ".repeat(a)}}class DiUtils{static beanName(t){return Strings.firstCharToLowerCase(t.name)}}!function(t){t.DYNAMIC="dynamic",t.NAME="name",t.TYPE="type"}(InjectableType||(InjectableType={}));class MetadataCrudUtils{constructor(t,e){this.spaceName=t,this.defaultProvider=e}updateMetadata(t,e){let a=this.getOrCreateMetadata(t);if(null==a)throw Error("can't get or create metaData");return e(a),a}assignMetaDataToConstructor(t,e){let a=this.getPrototype(t);null==a.$a&&(a.$a={}),null==a.$a[this.spaceName]&&(a.$a[this.spaceName]={});let n=MetadataCrudUtils.extractName(t);a.$a[this.spaceName][n]=e}getAnnotationsMetaData(t){let e=t;e.$a||(e=this.getPrototype(t));let a=e.$a;if(null==a)return null;let n=a[this.spaceName];return null==n?null:n[MetadataCrudUtils.extractName(t)]}getOrCreateMetadata(t){if(null==this.getAnnotationsMetaData(t)){let e=this.defaultProvider();this.assignMetaDataToConstructor(t,e)}return this.getAnnotationsMetaData(t)}getPrototype(t){return"object"==typeof t?t:"object"==typeof t.prototype?t.prototype:this.getPrototype(Object.getPrototypeOf(t))}static extractName(t){let e=t.name;return null==e&&(e=t.constructor.name),e.substring(0,1).toLowerCase()+e.substring(1,e.length)}}let diAnnotationsCrud=new MetadataCrudUtils("$di",()=>({diAnnotations:[]}));function InjectByType(t,e){return(a,n,r)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:r,injectable:t,type:InjectableType.TYPE,cascadeProperties:e}))}}function InjectDynamic(t,e){return(a,n,r)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:r,injectable:t,type:InjectableType.DYNAMIC,cascadeProperties:e}))}}function InjectByName(t,e){return console.log("Inject by name",t),(a,n,r)=>{diAnnotationsCrud.updateMetadata(a,a=>a.diAnnotations.push({onConstructorParamIndex:r,injectable:t,type:InjectableType.NAME,cascadeProperties:e}))}}const STRIP_COMMENTS=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,ARGUMENT_NAMES=/([^\s,]+)/g;class Functions{static extractArgNames(t){if(0===t.length)return[];let e=t.toString().replace(STRIP_COMMENTS,""),a=e.slice(e.indexOf("(")+1,e.indexOf(")")).match(ARGUMENT_NAMES);return null===a&&(a=[]),a}}class DiAnnotationsMetadataFactory{create(t){let e=DiUtils.beanName(t),a=Functions.extractArgNames(t),n={},r=diAnnotationsCrud.getAnnotationsMetaData(t);return r&&r.diAnnotations.forEach(t=>{let e=a[t.onConstructorParamIndex];n[e]={name:e,type:t.type,payload:t.injectable,propsProvider:t.cascadeProperties}}),{dependencyName:e,argumentNames:a,diParams:n,constructor:t}}}class DiRuntime{constructor(t,e){this.diInvocationResolver=t,this.diInvocationBuilderFactory=e}invoke(t,e,a){if("object"==typeof t)return t;let n=this.diInvocationBuilderFactory.root(t).if(null!=e,t=>t.withTransitiveBeans(e)).build(),r=this.diInvocationResolver.resolve(n,a,this).result;if(null==r)throw Error("Can't invoke");return r}invokeWithProps(t,e,a,n){let r=this.diInvocationBuilderFactory.root(t).withProperties(e).if(null!=a,t=>t.withTransitiveBeans(a)).build(),s=this.diInvocationResolver.resolve(r,n,this).result;if(null==s)throw Error("Can't invoke");return s}}DiRuntime.PROPS_PROPERTY_NAME="$props";class DiInvocationResolver{constructor(t,e,a){this.diInvocationFactory=t,this.diCache=e,this.diEnricher=a}resolve(t,e,a){if(this.causesCircularDependency(t))return{circularDependencyEndOf:t.diMetadata.dependencyName,result:null,pendingDependencies:{}};let n=null,r=this.diCache.resolve(t.diMetadata.dependencyName,()=>(n=this.doCreate(t,e,a),this.diEnricher&&(n.result=this.diEnricher(t.diMetadata,n.result)),Object.keys(n.pendingDependencies).indexOf(t.diMetadata.dependencyName)>-1&&n.pendingDependencies[t.diMetadata.dependencyName].forEach(e=>{this.diCache.resolve(e,null)[t.diMetadata.dependencyName]=n.result}),n.result));return null==n?{result:r,pendingDependencies:{}}:n}causesCircularDependency(t){return t.inProcessDiInvocations.indexOf(t.diMetadata.dependencyName)>-1}doCreate(t,e,a){const n=(t,e)=>{let a=t.diMetadata.constructor;return a.prototype&&a.prototype.constructor.name?e?new a(...e):new a:e?a(...e):a()};if(0===t.diMetadata.argumentNames.length){return{result:n(t,void 0),pendingDependencies:{}}}let r=[],s={};return this.invokeChildren(t,e,a).forEach(e=>{r.push(e.result),null!=e.circularDependencyEndOf&&DiInvocationResolver.addValueToKeyValuePairs(s,e.circularDependencyEndOf,t.diMetadata.dependencyName),e.pendingDependencies&&Object.keys(e.pendingDependencies).forEach(t=>{DiInvocationResolver.addValuesToKeyValuePairs(s,t,e.pendingDependencies[t])})}),{result:n(t,r),pendingDependencies:s}}static addValueToKeyValuePairs(t,e,a){t[e]||(t[e]=[]),t[e].indexOf(a)>-1||t[e].push(a)}static addValuesToKeyValuePairs(t,e,a){t[e]?a.forEach(a=>DiInvocationResolver.addValueToKeyValuePairs(t,e,a)):t[e]=a}invokeChildren(t,e,a){let n=[];return t.diMetadata.argumentNames.forEach(r=>{let s=this.resolveParamDef(t,r);n.push(this.invokeChild(t,s,e,a))}),n}resolveParamDef(t,e){let a=t.diMetadata.diParams[e];return null==a?{name:e,propsProvider:null,payload:e,type:InjectableType.NAME}:a}invokeChild(t,e,a,n){return e.name===DiRuntime.PROPS_PROPERTY_NAME?this.resolveChildProps(t):e.type===InjectableType.TYPE?this.resolveChildByType(t,e,a,n):e.type===InjectableType.DYNAMIC?this.resolveDynamicChild(t,e,a,n):this.resolveChildByName(t,e,a,n)}resolveChildProps(t){if(null==t.properties)throw Error("can't resolve properties for $props - There are no properties passed to the beanRuntime");return{result:t.properties,pendingDependencies:{}}}resolveChildByType(t,e,a,n){return this.resolve(this.diInvocationFactory.childrenOf(t,e.payload,e.propsProvider),a,n)}resolveDynamicChild(t,e,a,n){return this.resolveChildByType(t,{payload:e.payload(),type:InjectableType.TYPE,propsProvider:e.propsProvider,name:e.name},a,n)}resolveChildByName(t,e,a,n){let r=e.payload;if(null==t.transitiveBeans||null==t.transitiveBeans[r]){if(null!=a[r]){return{result:n.invoke(a[r],t.transitiveBeans,a),pendingDependencies:{}}}throw Error(`can't resolve param '${r}' - There are no transitive beans passed into the runtime`)}return{result:t.transitiveBeans[r],pendingDependencies:{}}}}class DiInvocationBuilderFactory{constructor(t){this.diAnnotationsMetadataFactory=t}childrenOf(t,e,a){let n=t.inProcessDiInvocations.slice(0);return n.push(t.diMetadata.dependencyName),new DiInvocationBuilder(this.diAnnotationsMetadataFactory,e).withInProcessDiInvocations(n).withTransitiveBeans(t.transitiveBeans).if(null!=a,t=>t.withProperties(a()))}root(t){return new DiInvocationBuilder(this.diAnnotationsMetadataFactory,t)}}class DiInvocationFactory{constructor(t){this.diInvocationBuilderFactory=t}childrenOf(t,e,a){return this.diInvocationBuilderFactory.childrenOf(t,e,a).build()}}class DiInvocationBuilder{constructor(t,e){this.diAnnotationsMetadataFactory=t,this._constructor=e,this.inProcessDiInvocations=[],this.transitiveBeans={},this.properties=null}if(t,e){return t&&e(this),this}withInProcessDiInvocations(t){return this.inProcessDiInvocations=t,this}withTransitiveBeans(t){return this.transitiveBeans=t,this}withProperties(t){return this.properties=t,this}build(){return{diMetadata:this.diAnnotationsMetadataFactory.create(this._constructor),inProcessDiInvocations:this.inProcessDiInvocations,transitiveBeans:this.transitiveBeans,properties:this.properties}}}class KeyValueCache{constructor(){this.cache={}}resolve(t,e){if(this.cache[t])return this.cache[t];if(null==e)throw Error("Can't resolve cache");let a=e();return this.cache[t]=a,a}}class DiRuntimeFactory{static create(t){return new DiRuntime(DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER(new KeyValueCache,t||null),DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY)}}DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY=new DiInvocationBuilderFactory(new DiAnnotationsMetadataFactory),DiRuntimeFactory.cacheTBR=(()=>new KeyValueCache),DiRuntimeFactory.DI_INVOCATION_RESOLVER_PROVIDER=((t,e)=>new DiInvocationResolver(new DiInvocationFactory(DiRuntimeFactory.DI_INVOCATION_BUILDER_FACTORY),DiRuntimeFactory.cacheTBR(),e));class DiContextFactory{static createContext(t,e){let a,n=DiRuntimeFactory.create(),r=Object.assign(Object.assign({},t),e);a=e?[...Object.keys(t),...Object.keys(e)]:Object.keys(t);let s={},i=Object.assign(Object.assign({},t),e);return a.forEach(t=>{let e=r[t];s[t]=n.invoke(e,s,i)}),s}}!function(t){t.IDLE="IDLE",t.ASYNC_START="ASYNC_START",t.ASYNC_FULFILLED="ASYNC_FULFILLED",t.ASYNC_CANCELLED="ASYNC_CANCELLED"}(exports.MonitorStatus||(exports.MonitorStatus={}));const ReactStateContext=React.createContext(null);class StateMapConnect extends React.Component{constructor(t){super(t),this._isMounted=!1,this.lastMonitorInfo=void 0,this.lastState=void 0;let e=!0,a=this.props.into.prototype?this.props.into.prototype:this.props.into.name;this._mainDataReactionLock=this.props.from.addDataReaction({name:`connect | ${a}`,dataConsumer:t=>{this.lastState=t;let a=this.props.mapper(t,Object.assign({},this.props.from.actions),this.lastMonitorInfo);this._isMounted?this.setState(a):(e=!1,this.state=a)}}),this._asyncDataReactionLock=this.props.from.addAsyncReaction({name:`connect monitor| ${a}`,dataConsumer:t=>{this.lastMonitorInfo=t;let a=this.props.mapper(this.lastState,Object.assign({},this.props.from.actions),t);this._isMounted?this.setState(a):(e=!1,this.state=a)}}),e&&this.props.fallbackValue&&(this.state=this.props.fallbackValue(this.props.from.actions))}componentDidMount(){this._isMounted=!0}componentWillUnmount(){this._isMounted=!1,this._mainDataReactionLock.release(),this._asyncDataReactionLock&&this._asyncDataReactionLock.release()}render(){let t=this.props.into;return React.createElement(ReactStateContext.Provider,{value:this.props.from},React.createElement(t,Object.assign({},this.state)))}}const StateConnect=t=>React.createElement(StateMapConnect,{mapper:(t,e,a)=>({data:t,actions:e,monitorInfo:a}),into:t.into,from:t.from,fallbackValue:e=>({data:t.fallbackValue,actions:e,monitorInfo:{status:exports.MonitorStatus.IDLE}})}),stateConnect=(t,e,a)=>React.createElement(StateConnect,{from:t,into:e,fallbackValue:a}),stateMapConnect=(t,e,a,n)=>React.createElement(StateMapConnect,{from:t,into:e,fallbackValue:n,mapper:a});function useFlow(t,e,a){React.useEffect(()=>{t.reactOnStatusChanged(t=>{e(e=>a?a(t,e):t.name)})},[])}function useFlowStatus(t,e,a,n){React.useEffect(()=>{t.alwaysOn(e,t=>{a(e=>n?n(t.getData(),e):t.getData())})},[])}function useConanState(t,e){let a=t.getData();const[n,r]=React.useState(null==a?e:a);return React.useEffect(()=>{const e=t.addDataReaction({dataConsumer:r,name:`useConanState[${t.getName()}]`});return()=>e.release()},[]),[n,t.actions,({children:e})=>React.createElement(ReactStateContext.Provider,{value:t},e)]}function useContextConanState(){let t=useConanState(React.useContext(ReactStateContext));return[t[0],t[1]]}class ContextStateMapConnect extends React.Component{render(){return React.createElement(ReactStateContext.Consumer,null,t=>{if(null==t)throw new Error("trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?");return React.createElement(StateMapConnect,{from:t,into:this.props.into,mapper:this.props.mapper,fallbackValue:this.props.fallbackValue})})}}class ContextStateConnect extends React.Component{render(){return React.createElement(ReactStateContext.Consumer,null,t=>{if(null==t)throw new Error("trying to access the state from the context, but it was not found, did you specify the state up in the rendering tree?");return React.createElement(StateConnect,{from:t,into:this.props.into,fallbackValue:this.props.fallbackValue})})}}const contextStateConnect=(t,e)=>React.createElement(ContextStateConnect,{into:t,fallbackValue:e}),contextStateMapConnect=(t,e,a)=>React.createElement(ContextStateMapConnect,{into:t,fallbackValue:a,mapper:e}),ContextStateLive=t=>{return React.createElement(ContextStateConnect,{into:e=>t.renderer(e.data,e.actions),fallbackValue:t.fallbackValue})},StateLive=t=>{return React.createElement(StateConnect,{from:t.from,into:e=>{let a=t.renderer(e.data,e.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:t.fallbackValue})},contextStateLive=(t,e)=>{return React.createElement(ContextStateConnect,{into:e=>{let a=t(e.data,e.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:e})},stateLive=(t,e,a)=>{return React.createElement(StateConnect,{from:t,into:t=>{let a=e(t.data,t.actions);return Array.isArray(a)?React.createElement(React.Fragment,null,a):a},fallbackValue:a})};var FlowEventNature,FlowEventSource,FlowEventLevel,FlowEventTiming,FlowEventType,ReactionType,StatusEventType,BindBackType;!function(t){t.MAIN="MAIN",t.HELPER="HELPER",t.ASYNC="ASYNC",t.AUX="AUX",t.ASAP="ASAP"}(FlowEventNature||(FlowEventNature={})),function(t){t.FLOW_CONTROLLER="FLOW_CONTROLLER",t.FLOW_THREAD="FLOW_THREAD",t.CONTEXT="CONTEXT",t.USER_MSG="USER_MSG",t.FLOW_FACTORY="FLOW_FACTORY"}(FlowEventSource||(FlowEventSource={})),function(t){t.DEBUG="DEBUG",t.TRACE="TRACE",t.INFO="INFO",t.MILESTONE="MILESTONE",t.WARN="WARN",t.ERROR="ERROR"}(FlowEventLevel||(FlowEventLevel={})),function(t){t.START="START",t.END="END",t.CANCEL="CANCEL",t.IN_PROCESS="IN_PROCESS"}(FlowEventTiming||(FlowEventTiming={})),function(t){t.MONITORING="MONITORING",t.PROCESSING_REACTIONS="PROCESSING_REACTIONS",t.STARTING="STARTING",t.ONCE_ON="ONCE_ON",t.RUN_IF="RUN_IF",t.RUN="RUN",t.ADDING_REACTION="ADDING_REACTION",t.REQUESTING_STATUS="REQUESTING_STATUS",t.SETTLING_STATUS="SETTLING_STATUS",t.REQUESTING_TRANSITION="REQUESTING_TRANSITION",t.CREATING="CREATING",t.USER_REACTIONS="USER_REACTIONS",t.USER_CODE="USER_CODE"}(FlowEventType||(FlowEventType={}));class MonitorFacade{constructor(t,e){this.monitor=t,this.actions=e}start(){return this.monitor.start(),this}addAsyncReaction(t){return this.monitor.addAsyncReaction(t)}addReaction(t){return this.monitor.addReaction(t)}get do(){return this.monitor.do}getEvents(){return this.monitor.getEvents()}getName(){return this.monitor.getName()}stop(t){this.monitor.stop(t)}getData(){return this.monitor.getData()}next(t){this.monitor.next(t)}get asyncThread(){return this.monitor.asyncThread}get mainThread(){return this.monitor.mainThread}activateAsyncLog(){this.monitor.asyncThread.thread.changeLoggingNature(FlowEventNature.ASYNC)}}class Objects{static mapKeys(t,e,a){let n={};return Object.keys(t).forEach(r=>{let s=a?a(r):r;n[s]=e(t[r])}),n}static foreachEntry(t,e){Object.keys(t).forEach(a=>{e(t[a],a)})}static keyfy(t,e){return t.reduce((t,a)=>Object.assign(Object.assign({},t),{[e(a)]:a}),{})}static navigate(t,e){let a=[],n=t;for(;n;)null!==(n=e(n))&&a.push(n);return a}static deepEqualsArrays(t,e){if(t.length!==e.length)return!1;for(let a of t)if(-1===e.indexOf(a))return!1;return!0}static deepEqualsObjects(t,e){for(let a of Object.keys(t))if(!Objects.deepEquals(t[a],e[a]))return!1;return!0}static deepEquals(t,e){return null==t&&null==e||(null!=t||null==e)&&((null==t||null!=e)&&("string"==typeof t&&"string"==typeof e?t===e:"number"==typeof t&&"number"==typeof e?t===e:"function"==typeof t&&"function"==typeof e?t===e:"boolean"==typeof t&&"boolean"==typeof e?t===e:void 0===t&&void 0===e?t===e:Array.isArray(t)&&Array.isArray(e)?Objects.deepEqualsArrays(t,e):!(Array.isArray(t)&&!Array.isArray(e))&&(!(!Array.isArray(t)&&Array.isArray(e))&&("object"==typeof t&&"object"==typeof e?Objects.deepEqualsObjects(t,e):t===e))))}}!function(t){t.ONCE="ONCE",t.ALWAYS="ALWAYS"}(ReactionType||(ReactionType={}));class ThreadImpl{constructor(t){this.flow=t}start(t){return this.flow.start(t?{name:"nextData",data:t}:void 0),this}next(t){this.flow.onceOn("nextData",t)}stop(t){this.flow.stop(t)}chain(t){return this.flow.chainInto("nextData","nextData",t).map(t=>t.getData())}monitor(t,e,a,n){let r=t.map(t=>a=>e(t,a)),s={payload:n,name:null==a?"anonymous":a,action:r};return this.flow.deferInto("nextData","nextData",s).map(t=>t.getData())}get isRunning(){return this.flow.isRunning}get reducers(){return this.flow.on("nextData").steps}addReaction(t){let e={name:t.name,reactionType:ReactionType.ALWAYS,action:e=>t.dataConsumer(e.getData())};return this.flow.addReaction("nextData",e),{release:()=>{this.flow.removeReaction("nextData",e)}}}getData(){return this.flow.getStatusData().nextData}getEvents(){return this.flow.getEvents()}getName(){return this.flow.getName()}changeLoggingNature(t){this.flow.changeLoggingNature(t)}}class StatusLikeParser{static parse(t){return"string"==typeof t?{name:t}:t}}class FlowRequest{constructor(t,e,a,n){this.flowThread=t,this.id=e,this.status=a,this.isStep=n,this.queuedReactions=[],this.queuedTransitions=[],this.queuedSteps=[],this.queuedStatuses=[],this.queuedStates=[],this.started=!1,this.processingStatus={id:this.id,status:this.status}}static statusRequest(t,e,a,n){return new FlowRequest(t,e,a,n)}static transitionRequest(t,e,a,n){return new FlowRequest(t,e,StatusLikeParser.parse(a.into),n)}start(){if(this.started)throw new Error("unexpected");this.started=!0,this.flowThread.processStateAndReactions(this.processingStatus,this.isStep),this.flowThread.flagAsSettled(this.processingStatus,this.isStep),this.flowThread.onStateRequestCompleted(this,this.queuedReactions,this.queuedStatuses,this.queuedStates,this.queuedTransitions,this.queuedSteps)}queueStatus(t){this.queuedStatuses.push(t)}queueTransition(t){return this.queuedTransitions.push(t),this}queueStep(t){return this.queuedSteps.push(t),this}queueState(t){this.queuedStates.push(t)}queueReaction(t,e){this.queuedReactions.push([t,e])}}class FlowThread{constructor(t,e,a){this.flowController=t,this.flowOrchestrator=e,this.flowEvents=a,this.ids={}}requestStatus(t,e){let a=StatusLikeParser.parse(t),n=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.REQUESTING_STATUS,t).start(`${a.name}`);if(this.assertValidStatus(a.name),null!=this.currentRequest)return void(e?(n.debug(`queueing state [${a.name}]`),this.currentRequest.queueState(a)):(n.debug(`queueing status [${a.name}]`),this.currentRequest.queueStatus(a)));let r=this.getNextId(a);this.currentRequest=FlowRequest.statusRequest(this,r+"",a,e),this.currentRequest.start(),n.end()}requestTransition(t,e){let a=StatusLikeParser.parse(t.into).name,n=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.REQUESTING_TRANSITION,t).start(`${t.transitionName}`);if(n.info(e?"step":"transition",[t.transitionName,t.payload]),this.assertValidStatus(a),null!=this.currentRequest)return void(e?(n.debug(`queueing step [${t.transitionName}]`),this.currentRequest.queueStep(t)):(n.debug(`queueing transition [${t.transitionName}]`),this.currentRequest.queueTransition(t)));let r=this.getNextId(StatusLikeParser.parse(t.into));this.currentRequest=FlowRequest.transitionRequest(this,r+"",t,e),this.onTransitionRequested(t,e),this.currentRequest.start(),n.end()}requestStep(t,e,a,n){this.assertValidStatus(t);let r=this.getCurrentStatusName();if(r!==t)throw new Error(`car't request step on [${t}] as the current status is[${r}]`);this.requestTransition({transitionName:e,payload:a,into:{name:t,data:n}},!0)}requestState(t,e){this.assertValidStatus(t);let a=this.getCurrentStatusName();if(a!==t)throw new Error(`car't request state on [${t}] as the current status is[${a}]`);this.requestStatus({name:t,data:e},!0)}tryToQueue(t,e){return null!=this.currentRequest&&(this.currentRequest.queueReaction(t,e),!0)}onTransitionRequested(t,e){this.flowEvents.addTransition(t,e)}getNextId(t,e=!1){null==this.ids[t.name]&&(this.ids[t.name]=0);let a=this.ids[t.name]+1;return e?a:(this.ids[t.name]=a,this.ids[t.name])}processStateAndReactions(t,e){this.flowEvents.addProcessingStatus(t,e),this.flowController.processReactions(t.status.name)}flagAsSettled(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.FLOW_THREAD,FlowEventType.SETTLING_STATUS,t).start(`${t.status.name}`);this.flowEvents.settleProcessingStatus(t,e),e?a.milestone("STATE",t.status.data):a.milestone(`STATUS - ${t.status.name}`,t.status.data),a.end()}onStateRequestCompleted(t,e,a,n,r,s){if(null==this.currentRequest)throw new Error(`can't complete the request for [${this.flowController.getName()} - ${t.status.name}] as is not flagged as currently in process`);if(this.currentRequest!=t)throw new Error(`can't complete the request for [${this.flowController.getName()} - ${t.status.name}] as it does not match [${this.currentRequest.status.name}]`);if(r.length>0&&a.length>0)throw new Error("can't have transitions and states forked at the same time!");if(this.currentRequest=void 0,r.length>1||a.length>1)throw new Error("TBI");r.forEach(t=>this.flowController.requestTransition(t)),a.forEach(t=>this.flowController.requestStatus(t)),n.forEach(t=>this.flowController.requestState(t.name,t.data)),s.forEach(t=>{let e=StatusLikeParser.parse(t.into);this.flowController.requestStep(e.name,t.transitionName,t.payload,e.data)}),e.forEach(t=>this.flowController.addReaction(t[0],t[1]))}createContext(t,e){let a=StatusLikeParser.parse(t);return{getData:this.flowController.getState.bind(this.flowController),getStatusData:this.flowController.getStatusData.bind(this.flowController),do:Object.assign(Object.assign({},this.flowController.on(a.name).transitions),this.flowController.on(a.name).steps),chain(t){e(t)},interruptFlow:()=>{this.flowController.stop()},log:t=>{let e=this.flowOrchestrator.createRuntimeTracker(this.flowController,FlowEventSource.USER_MSG,FlowEventType.USER_CODE,t).start(),a=e.milestone(void 0,t);return e.end(),a}}}getCurrentStatusName(){let t=this.flowEvents.currentStatus;return null==t?void 0:t.name}getCurrentState(){let t=this.flowEvents.currentStatus;return null==t?void 0:t.data}assertValidStatus(t){if(null==this.flowController.on(t))throw new Error(`error requesting a transition into [${t}] unknown status, valid statuses are: [${Object.keys(this.flowController.getStatusDefs()).join(", ")}]`)}}!function(t){t.TRANSITION="TRANSITION",t.STEP="STEP",t.STATUS="STATUS",t.PROCESSING_STATUS="PROCESSING_STATUS",t.STATE="STATE",t.PROCESSING_STATE="PROCESSING_STATE"}(StatusEventType||(StatusEventType={}));class FlowEventsTracker{constructor(){this.eventsByStatus={},this.events=[]}addTransition(t,e){let a,n=StatusLikeParser.parse(t.into);a=e?{type:StatusEventType.STEP,reducerName:t.transitionName,newData:n.data,reducerPayload:t.payload}:{type:StatusEventType.TRANSITION,fromStatus:this.currentStatus.name,intoStatus:n,transitionName:t.transitionName,transitionPayload:t.payload},this.lastEvent=a,this.process(a)}addStateFromStatus(t){this.lastEvent=t,this.process(t)}addProcessingStatus(t,e){let a;a=e?{type:StatusEventType.PROCESSING_STATE,data:t.status.data}:{type:StatusEventType.PROCESSING_STATUS,status:t.status},this.currentStatus=t.status,this.lastEvent=a,this.process(a)}settleProcessingStatus(t,e){if(e){if(this.lastEvent.data!==t.status.data)throw new Error("unexpected error settling events");this.lastEvent.type=StatusEventType.STATE,this.eventsByStatus[this.currentStatus.name].lastState=t.status.data}else{if(this.lastEvent.status!==t.status)throw new Error("unexpected error settling events");this.lastEvent.type=StatusEventType.STATUS,this.addStateFromStatus({data:t.status.data,type:StatusEventType.STATE})}}process(t){null==this.eventsByStatus[this.currentStatus.name]&&(this.eventsByStatus[this.currentStatus.name]={allEvents:[],statusName:this.currentStatus.name,lastState:void 0});let e={event:t,statusName:this.currentStatus.name};this.eventsByStatus[this.currentStatus.name].allEvents.push(e),t.type!==StatusEventType.STATE&&t.type!==StatusEventType.PROCESSING_STATE||(this.eventsByStatus[this.currentStatus.name].lastState=t.data),this.events.push(e)}serializeStatesWithStatus(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[StatusEventType.STATE]}))}serializeStates(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[StatusEventType.STATE]})).map(t=>t.event)}serializeStatuses(t){return this.serializeWithStatusInfo(Object.assign(Object.assign({},t),{eventTypes:[StatusEventType.STATUS]})).map(t=>t.event)}serialize(t){return this.serializeWithStatusInfo(t).map(t=>t.event)}serializeWithStatusInfo(t){if(!t)return this.events;let e=[];return this.events.forEach(a=>{let n=!0;n&&(t.excludeInit&&this.eventsByStatus.$init.allEvents.indexOf(a)>-1&&(n=!1),n&&(t.excludeStop&&this.eventsByStatus.$stop&&this.eventsByStatus.$stop.allEvents.indexOf(a)>-1&&(n=!1),n&&(t.statuses&&t.statuses.forEach(t=>{n||-1===this.eventsByStatus[t].allEvents.indexOf(a)&&(n=!1)}),n&&(t.eventTypes&&-1===t.eventTypes.indexOf(a.event.type)&&(n=!1),n&&e.push(a)))))}),e}getLastStates(){let t={};return Object.keys(this.eventsByStatus).forEach(e=>{t[e]=this.eventsByStatus[e].lastState}),t}getLastState(t){let e=this.eventsByStatus[t];if(null!=e)return e.lastState}}!function(t){t.STEP="STEP",t.TRANSITION="TRANSITION"}(BindBackType||(BindBackType={}));class FlowAnchor{createNewThread(t,e){let a=new FlowEventsTracker,n=new FlowThread(t,e,a);return this.currentThread={flowEvents:a,flowThread:n},n}getCurrentEvents(){return this.currentThread.flowEvents}get currentStatus(){if(this.currentThread)return this.currentThread.flowEvents.currentStatus}getStatusDataProducerFn(){return(t,e)=>{let a=this.currentThread.flowEvents.getLastStates();return-1===Object.keys(a).indexOf(t)?e:a[t]}}getDataFn(t){return()=>{if(null==this.currentThread)throw new Error("error getting the data function associated to this flow, this might happen if you try to mutate the state of the flow before it has been started.");let e=this.currentThread.flowEvents.currentStatus.name;if("$init"!==e){if(t!==e)throw new Error(`unexpected error trying to retrieve the last status for [${t}, but the current status is [${e}]]`);return this.currentThread.flowEvents.getLastState(t)}}}bindBack(t,e,a){if(!this.currentThread.flowThread.flowController.isRunning)return;let n=e.result&&"$stop"!=e.result.name,r=this.currentStatus&&"$init"!=this.currentStatus.name;if(n&&r&&(!this.currentStatus||this.currentStatus.name!==t))throw Error(`unable to request [${e.methodName}] as is meant for status [${t}], but the current status is [${this.currentStatus?this.currentStatus.name:"-"}]`);if(a===BindBackType.STEP){"$init"===this.currentThread.flowThread.getCurrentStatusName()?this.currentThread.flowThread.requestTransition({into:{name:t,data:e.result},payload:e.payload,transitionName:e.methodName},!1):this.currentThread.flowThread.requestStep(e.statusName,e.methodName,e.payload,e.result)}else this.currentThread.flowThread.requestTransition({into:e.result,payload:e.payload,transitionName:e.methodName},!1)}getStatusData(){return this.currentThread.flowEvents.getLastStates()}}class Proxyfier{static proxy(t,e){let a={},n=Object.getPrototypeOf(t),r="Object"===n.constructor.name?t:n;return Object.getOwnPropertyNames(r).forEach(n=>{if("constructor"===n)return;"function"==typeof r[n]&&(a[n]=((...a)=>{return e(()=>{return t[n](...a)},{methodName:n,payload:a})}))}),a}}class MutatorsFactory{static createDefaultStepsDef(t){return e=>({$update(a){let n,r=t.currentThread.flowThread,s=r.flowOrchestrator.createRuntimeTracker(r.flowController,FlowEventSource.CONTEXT,FlowEventType.USER_CODE,n).start();return n="function"!=typeof a?a:a(e()),s.debug("$update",n).end(),n}})}static createDefaultTransitionDef(t){return()=>({$toStatus(e){let a=StatusLikeParser.parse(e),n=t.currentThread.flowThread;return n.flowOrchestrator.createRuntimeTracker(n.flowController,FlowEventSource.CONTEXT,FlowEventType.USER_CODE,a).start().debug("$toStatus",a).end(),a}})}static createDefaultSteps(t,e){return this.createSteps(t,e,this.createDefaultStepsDef(e))}static createTransitions(t,e,a){let n=this.createDefaultTransitionDef(e);return this.doCreateTransitions(t,e,a?[a,n]:[n])}static createSteps(t,e,a){let n=this.createDefaultStepsDef(e);return this.doCreateSteps(t,e,a?[a,n]:[n])}static doCreateSteps(t,e,a){let n=e.getDataFn(t),r={};return a.forEach(t=>{let e=t(n);r=Object.assign(Object.assign({},r),e)}),this.bindToAnchor(t,e,r,BindBackType.STEP)}static doCreateTransitions(t,e,a){let n=e.getStatusDataProducerFn(),r={};return a.forEach(t=>{let e=t(n);r=Object.assign(Object.assign({},r),e)}),this.bindToAnchor(t,e,r,BindBackType.TRANSITION)}static bindToAnchor(t,e,a,n){return Proxyfier.proxy(a,(a,r)=>{let s=e.currentThread.flowThread.flowController,i=e.currentThread.flowThread.flowOrchestrator.createRuntimeTracker(s,FlowEventSource.CONTEXT,FlowEventType.USER_REACTIONS,s.flowDef.nature).start(),o=s.flowDef.nature===FlowEventNature.MAIN&&"$update"!==r.methodName?FlowEventLevel.MILESTONE:FlowEventLevel.DEBUG;i.withLevel(o,`calling: ${r.methodName}`,"object"==typeof r.payload?r.payload:"[reducer]");let c=a();return e.bindBack(t,{statusName:e.currentStatus.name,methodName:r.methodName,payload:r.payload,result:c},n),i.end(),c})}}const $INIT="$init",$STOP="$stop";class ReactionDefLikeParser{static parse(t,e,a){return"object"==typeof t?t:{name:a||"anonymous",reactionType:e,action:t}}}class FlowDefFactory{static create(t,e){let a=FlowDefFactory.statusesByName(t.statuses,e);return a[$INIT]={name:$INIT,steps:MutatorsFactory.createDefaultSteps($INIT,e),transitions:MutatorsFactory.createTransitions($INIT,e),reactions:t.$onInit?t.$onInit.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,"on init")):[]},a[$STOP]={name:$STOP,steps:MutatorsFactory.createDefaultSteps($STOP,e),transitions:MutatorsFactory.createTransitions($STOP,e),reactions:t.$onStop?t.$onStop.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,"on stop")):[]},Object.assign(Object.assign({statusesByStatusName:a,name:t.name,nature:t.nature?t.nature:FlowEventNature.MAIN},t.hasOwnProperty("initialStatus")?{starter:()=>t.initialStatus}:void 0),t.hasOwnProperty("logger")?{logger:t.logger}:void 0)}static statusesByName(t,e){let a={};return Array.isArray(t)?t.forEach(t=>{a[t]={name:t,steps:[],reactions:[]}}):Objects.foreachEntry(t,(t,n)=>{a[n]={name:n,steps:MutatorsFactory.createSteps(n,e,t.steps),transitions:MutatorsFactory.createTransitions(n,e,t.transitions),reactions:t.reactions?t.reactions.map(t=>ReactionDefLikeParser.parse(t,ReactionType.ALWAYS,`on[${n}]`)):[],getLastData:e.getDataFn(n)}}),a}}class FlowRuntimeTracker{constructor(t,e){this.orchestrator=t,this.event=e}end(t,e){return this.doTick(FlowEventLevel.TRACE,FlowEventTiming.END,t,e)}cancel(t,e){return this.doTick(FlowEventLevel.TRACE,FlowEventTiming.CANCEL,t,e)}start(t,e){return this.doTick(FlowEventLevel.TRACE,FlowEventTiming.START,t,e)}debug(t,e){return this.doTick(FlowEventLevel.DEBUG,FlowEventTiming.IN_PROCESS,t,e)}info(t,e){return this.doTick(FlowEventLevel.INFO,FlowEventTiming.IN_PROCESS,t,e)}milestone(t,e){return this.doTick(FlowEventLevel.MILESTONE,FlowEventTiming.IN_PROCESS,t,e)}withLevel(t,e,a){return this.doTick(t,FlowEventTiming.IN_PROCESS,e,a)}doTick(t,e,a,n){let r=Object.assign(Object.assign(Object.assign({},this.event),{shortDesc:a,timing:e,level:t}),null!=n?{payload:n}:void 0);return this.orchestrator.onRuntimeEvent(this,r),this}}class FlowOrchestrator{constructor(t){this.eventsProcessor=t}onRuntimeEvent(t,e){e.timing===FlowEventTiming.START?this.currentTracker=t:e.timing!==FlowEventTiming.END&&e.timing!==FlowEventTiming.CANCEL||(this.currentTracker=void 0),this.eventsProcessor.forEach(t=>t(e))}createRuntimeTracker(t,e,a,n){return new FlowRuntimeTracker(this,{flowController:t,source:e,runtimeEvent:a,payload:n,nature:t.flowDef.nature})}}class FlowLogger{constructor(t){this.filters=t}log(t){for(let e of this.filters)if(!e(t)){let e=t.flowController.flowDef.logger;if(!e)return!1;if(!e(t))return!1}let e=t.flowController.getCurrentStatusName();return e=e||"-",null!=t.payload?(console.log(Strings.padEnd(`${t.runtimeEvent}`,30),Strings.padEnd(`${t.flowController.getName()}`,50),Strings.padEnd(`${e}`,30),Strings.padEnd(`${t.nature}`,20),Strings.padEnd(`${t.level}`,20)),null==t.payload&&null==t.shortDesc||(null!=t.shortDesc&&null!=t.payload?(console.log(`  =>[${t.shortDesc}]`),console.log(" ",t.payload)):null!=t.shortDesc&&null!=!t.payload?console.log(`  =>[${t.shortDesc}]`):console.log(`  =>[${t.payload}]`)),console.log("------------------------------------------------------------------------------------------------------------------------------------------------")):null!=t.shortDesc&&console.log(Strings.padEnd(`${t.runtimeEvent}`,30),Strings.padEnd(`${t.flowController.getName()}`,50),Strings.padEnd(`${e}`,30),Strings.padEnd(`${t.level}`,20),Strings.padEnd(`${t.nature}`,20),Strings.padEnd(`=>${t.shortDesc}`,60)),!0}}class LoggerFilters{static logDebug(){return LoggerFilters.excludeByEventLevel(FlowEventLevel.TRACE)}static excludeByLogName(t){return e=>e.flowController.getName()!==t}static excludeByEventTiming(t){return e=>e.timing!==t}static excludeByEventLevel(t){return e=>e.level!==t}static excludeByNature(t){return e=>e.nature!==t}static excludeByStatusName(t){return e=>e.flowController.getCurrentStatusName()!==t}}const FLOW_LOGGER=new FlowLogger([LoggerFilters.excludeByEventTiming(FlowEventTiming.END),LoggerFilters.excludeByEventTiming(FlowEventTiming.START),LoggerFilters.excludeByEventLevel(FlowEventLevel.TRACE),LoggerFilters.excludeByEventLevel(FlowEventLevel.INFO),LoggerFilters.excludeByEventLevel(FlowEventLevel.DEBUG),LoggerFilters.excludeByNature(FlowEventNature.AUX),LoggerFilters.excludeByNature(FlowEventNature.HELPER),LoggerFilters.excludeByNature(FlowEventNature.ASAP),LoggerFilters.excludeByStatusName("$init")]);function isPromise(t){return null!=t&&("object"==typeof t&&("then"in t&&"function"==typeof t.then))}function isAsap(t){return t instanceof NowImpl||t instanceof LaterImpl}!function(t){t.NOW="NOW",t.LATER="LATER"}(exports.AsapType||(exports.AsapType={}));class NowImpl{constructor(t){this.rawValue=t,this.type=exports.AsapType.NOW}cancel(){return!1}then(t){return t(this.rawValue),this}map(t){return Asaps.now(t(this.rawValue))}merge(t){const[e,a]=Asaps.next("map",FlowEventNature.AUX);return this.then(a=>t(a).then(t=>e(t))),a}catch(t){return this}onCancel(t){return this}}class LaterImpl{constructor(t){this.flow=t,this.type=exports.AsapType.LATER}map(t){let[e,a]=Asaps.next("map",FlowEventNature.AUX);return this.then(a=>e(t(a))),this.onCancel(()=>a.cancel()),a}then(t){return"resolved"===this.flow.getCurrentStatusName()?t(this.flow.on("resolved").getLastData()):this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{then:[...e.then,t]})),this}resolve(t){if("cancelled"!==this.flow.getCurrentStatusName())try{this.flow.assertOn("resolving",e=>{e.getData().then.forEach(e=>{e(t)}),this.flow.on("resolving").transitions.$toStatus({name:"resolved",data:t})})}catch(e){console.error(e),this.flow.assertOn("resolving",a=>{a.getData().catch.forEach(a=>{a(e,t)}),a.do.$toStatus({name:"errored",data:t})})}}onCancel(t){if("cancelled"!==this.flow.getCurrentStatusName())return"resolving"===this.flow.getCurrentStatusName()&&this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{onCancel:[...e.onCancel,t]})),this;t()}cancel(){return"resolving"===this.flow.getCurrentStatusName()&&(this.flow.assertOn("resolving",t=>{t.getData().onCancel.forEach(t=>{t()}),this.flow.on("resolving").transitions.$toStatus({name:"cancelled"})}),!0)}merge(t){const[e,a]=Asaps.next("merge",FlowEventNature.AUX);return this.then(n=>t(n).then(t=>e(t)).onCancel(()=>a.cancel())).onCancel(()=>a.cancel()),a}catch(t){return"resolving"===this.flow.getCurrentStatusName()&&this.flow.on("resolving").steps.$update(e=>Object.assign(Object.assign({},e),{catch:[...e.catch,t]})),this}}class AsapParser{static from(t){return isAsap(t)?t:isPromise(t)?Asaps.fromPromise(t):Asaps.now(t)}}class Asaps{static now(t){return new NowImpl(t)}static fromPromise(t,e){let a=new LaterImpl(Flows.createController({name:`future[${e||"anonymous"}]`,statuses:{resolving:{},resolved:{},errored:{},cancelled:{}},initialStatus:{name:"resolving",data:{then:[],catch:[],onCancel:[]}},nature:FlowEventNature.ASAP}).start());return t.then(t=>a.resolve(t)),t.catch(t=>a.catch(t)),a}static delayed(t,e,a){return Asaps.fromPromise(new Promise(a=>setTimeout(()=>a(t),e)),`delay[${a||"anonymous"}]`)}static fetch(t){return Asaps.fromPromise(new Promise(e=>{fetch(t).then(t=>t.json()).then(function(t){e(t)})}),`fetch[${Strings.padEnd(t,15)}]`)}static next(t,e){let a=new LaterImpl(Flows.createController({name:`asap-${t||"anonymous"}`,statuses:{resolving:{},resolved:{},errored:{},cancelled:{}},initialStatus:{name:"resolving",data:{then:[],catch:[],onCancel:[]}},nature:e||FlowEventNature.ASAP}).start());return[t=>a.resolve(t),a]}}function deferParser(t,e){return isAsap(t)?{action:t,name:e.name,payload:e.payload}:t}class FlowImpl{constructor(t,e,a){this.flowDef=t,this.flowAnchor=e,this.flowOrchestrator=a,this.isRunning=!1}start(t){let e=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.STARTING,t).start();if(this.isRunning)throw new Error("can't request a flow that it has been started to start again");if(this.flowThread=this.flowAnchor.createNewThread(this,this.flowOrchestrator),this.isRunning=!0,null==t&&null==this.flowDef.starter)return this.requestStatus($INIT),this;let a=t||this.flowDef.starter(),n=t=>{this.addReaction($INIT,{action:()=>{e.debug("initialStatus",t),this.requestStatus(t)},reactionType:ReactionType.ONCE,name:"to initial state"}),this.addReaction($STOP,{name:"onStop=>notifyEvents",reactionType:ReactionType.ONCE,action:t=>{t.chain(()=>{e.debug("state machine stopped"),this.flowThread=null,this.isRunning=!1})}}),this.requestStatus($INIT)};return AsapParser.from(a).then(t=>n(t)),e.end(),this}requestStatus(t){let e=StatusLikeParser.parse(t).name;if(this.isRunning){if(null==this.on(e))throw new Error(`unable to request non existing status [${e}]`);this.flowThread.requestStatus(t,!1)}}requestState(t,e){this.isRunning&&this.flowThread.requestState(t,e)}requestTransition(t){if(this.isRunning)return this.flowThread.requestTransition(t,!1),this}requestStep(t,e,a,n){this.isRunning&&this.flowThread.requestStep(t,e,a,n)}stop(t){if(!this.isRunning)throw new Error("unexpected");return this.addReaction($STOP,{name:"onStop=>notifyEvents",reactionType:ReactionType.ONCE,action:()=>{t&&t(this.flowAnchor.getCurrentEvents())}}),this.requestStatus({name:$STOP}),this}alwaysOn(t,e){return this.addReaction(t,{name:"-",reactionType:ReactionType.ALWAYS,action:e})}onceOnInit(t){return this.onceOn($INIT,t)}onceOnStop(t){return this.onceOn($STOP,t)}onceOn(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.ONCE_ON,t).start();a.debug(`[onceOn(${t})`);let n=this.addReaction(t,{name:"[userCode]",reactionType:ReactionType.ONCE,action:e});return a.end(),n}addReaction(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.ADDING_REACTION,e.name).start(),n=!0;if(this.isRunning){if(this.flowThread.tryToQueue(t,e))return a.debug([`queueing adding reaction: ${e.name}`]),a.end(),this;this.runIf(t,{action:t=>{e.action(t),e.reactionType===ReactionType.ONCE&&(n=!1)},reactionType:e.reactionType,name:e.name})}if(n){let a=this.on(t);if(null==a)throw new Error(`unable to add reactions for unknown event [${t}]`);this.addReactionNext(a,e)}return a.end(),this}addReactionNext(t,e){return t.reactions.push(e),this}getReactions(t){let e=this.on(t);if(null==e)throw new Error(`can't getReactions for unknown status[${t}]`);return e.reactions}getCurrentStatusName(){if(void 0!=this.flowThread)return this.flowThread.getCurrentStatusName()}getEvents(){return this.flowAnchor.getCurrentEvents()}getName(){return this.flowDef.name}getState(){return this.flowThread.getCurrentState()}getStatusData(){return this.flowAnchor.getStatusData()}onInit(){return this.on($INIT)}on(t){return this.flowDef.statusesByStatusName[t]}getStatusDefs(){return this.flowDef.statusesByStatusName}removeReaction(t,e){let a=this.on(t),n=a.reactions;n&&(a.reactions=n.filter(t=>t!==e))}processReactions(t){let e,a=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.PROCESSING_REACTIONS,t).start();return this.getReactions(t).forEach(a=>{a.reactionType===ReactionType.ONCE&&this.removeReaction(t,a),a.action(this.flowThread.createContext(t,t=>e=t))}),e&&e(),a.end(t),this}getStateData(){throw new Error("TBI")}reactOnStatusChanged(t){return Object.keys(this.getStatusDefs()).forEach(e=>{this.addReaction(e,{name:"-",reactionType:ReactionType.ALWAYS,action:a=>t({name:e,data:a.getData()})})}),this}runIf(t,e,a){let n=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.RUN_IF,e.name).start();if(!this.isRunning)return a&&a(),void n.end();let r=this.getCurrentStatusName();if(null==r)return a&&a(),void n.end();r===t?this.doRun(e,t):a&&a(),n.end()}doRun(t,e){let a=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.RUN,t.name).start();a.debug(`${t.name}`),t.action(this.flowThread.createContext(e,t=>t())),a.end()}assertOn(t,e){let a=this.getCurrentStatusName();if(a!==t)throw new Error(`asserting that we are on the status [${t}]. But we are currently on [${a}]`);return e&&this.onceOn(t,t=>e(t)),this}chainInto(t,e,a){const[n,r]=Asaps.next(`chain[${this.getName()}]-[${t}->${e}]`,FlowEventNature.AUX);if("$init"!==this.getCurrentStatusName())this.assertOn(t),this.addReactionNext(this.on(e),{name:"once on next",reactionType:ReactionType.ONCE,action:t=>n(t)}),this.onceOn(t,t=>a(t.do));else{let t=this.getStatusDefs()[e];this.onceOn("$init",()=>a(t.steps))}return r}deferInto(t,e,a){let n=`[${this.getName()}]::${t}=>${e}`,r=deferParser(a,{name:n,payload:n}),s=this.flowOrchestrator.createRuntimeTracker(this,FlowEventSource.FLOW_CONTROLLER,FlowEventType.MONITORING,{asap:r.action,name:r.name,payload:r.payload}).start();return r.action.type===exports.AsapType.LATER&&s.milestone(`START monitoring - ${r.name}`,r.payload),r.action.merge(a=>(r.action.type===exports.AsapType.LATER&&s.debug(`STOP monitoring - ${r.name}`),s.end(),this.chainInto(t,e,a))).onCancel(()=>{s.cancel()})}changeLoggingNature(t){this.flowDef.nature=t}}class FlowFacadeImpl{constructor(t,e){this.flow=t,this.actions=e,this.do=e}addReaction(t,e){return this.flow.addReaction(t,e),this}alwaysOn(t,e){return this.flow.alwaysOn(t,e),this}assertOn(t,e){return this.flow.assertOn(t,e),this}chainInto(t,e,a){this.flow.chainInto(t,e,a)}getCurrentStatusName(){return this.flow.getCurrentStatusName()}getEvents(){return this.flow.getEvents()}getName(){return this.flow.getName()}getState(){return this.flow.getState()}getStatusData(){return this.flow.getStatusData()}on(t){return this.flow.on(t)}onceOn(t,e){return this.flow.onceOn(t,e),this}onceOnInit(t){return this.flow.onceOnInit(t),this}onceOnStop(t){return this.flow.onceOnStop(t),this}start(t){return this.flow.start(t),this}stop(t){return this.flow.stop(t),this}get isRunning(){return this.flow.isRunning}onInit(){return this.flow.onInit()}reactOnStatusChanged(t){return this.flow.reactOnStatusChanged(t),this}deferInto(t,e,a){return this.flow.deferInto(t,e,a)}removeReaction(t,e){this.flow.removeReaction(t,e)}changeLoggingNature(t){this.flow.changeLoggingNature(t)}}const FlowOrchestrator$=t=>new FlowOrchestrator([t=>FLOW_LOGGER.log(t),...t]);class Flows{static create(t){let e=this.createController(t);return this.createFacade(e,t.actions)}static createFacade(t,e){return new FlowFacadeImpl(t,e?e(t):void 0)}static createController(t){let e=new FlowAnchor,a=FlowOrchestrator$(t.pipelineListener?[t.pipelineListener]:[]),n=new FlowImpl(FlowDefFactory.create(t,e),e,a);return a.createRuntimeTracker(n,FlowEventSource.FLOW_FACTORY,FlowEventType.CREATING,t).start().end(),n}}class ThreadFacade{constructor(t,e){this.thread=t,this.actions=e}chain(t){this.thread.chain(t)}next(t){this.thread.next(t)}start(){return this.thread.start(),this}stop(t){return this.thread.stop(t),this}get do(){let t=this.reducers;return Object.assign(Object.assign({},t),this.actions)}get reducers(){return this.thread.reducers}addReaction(t){return this.thread.addReaction(t)}get isRunning(){return this.thread.isRunning}getData(){return this.thread.getData()}getEvents(){return this.thread.getEvents()}getName(){return this.thread.getName()}changeLoggingNature(t){this.thread.changeLoggingNature(t)}}class MethodFinder{static exists(t,e){return null!=t&&this.find(t,e).length>0}static find(t,e=""){let a=Object.getPrototypeOf(t),n="Object"===a.constructor.name?t:a;return Object.getOwnPropertyNames(n).filter(t=>t.startsWith(e))}}class Threads{static create(t){let e,a=Flows.createController(Object.assign(Object.assign({name:t.name,statuses:{nextData:Object.assign(Object.assign({},t.reducers?{steps:t.reducers}:void 0),t.reactions?{reactions:t.reactions}:void 0)}},t.hasOwnProperty("initialData")?{initialStatus:AsapParser.from(t.initialData).map(t=>({name:"nextData",data:t}))}:void 0),{pipelineListener:t.pipelineListener,nature:t.nature?t.nature:FlowEventNature.MAIN})),n=new ThreadImpl(a);if(t.actions&&t.autoBind)throw new Error("you can only use actions or autoBind. Both in conjunction is illegal");if(t.autoBind){let a=[],r=Object.assign({},t.autoBind);Object.keys(n.reducers).forEach(e=>{let s=e.substring(1,e.length);MethodFinder.exists(t.autoBind,s)?(r[s]=((...e)=>t.autoBind[s](...e)),a.push(s)):r[s]=((...t)=>n.chain(a=>a[e](...t)))}),e=new ThreadFacade(n,Proxyfier.proxy(r,(t,e)=>-1===a.indexOf(e.methodName)?t():n.monitor(t(),(t,a)=>a[`$${e.methodName}`](t),e.methodName,e.payload)))}else{let a=t.actions?t.actions(n):{};Object.keys(n.reducers).forEach(t=>{let e=t.substring(1,t.length);a[e]||(a[e]=((...e)=>n.chain(a=>a[t](...e))))}),e=new ThreadFacade(n,a)}return t.cancelAutoStart||e.start(),e}}class PipeImpl{constructor(t,e,a){this.name=t,this.pipeConnector=e,this.pipeThreadDef=a}addReaction(t){return this.baseThread.addReaction(t)}chain(t){return this.baseThread.chain(t)}getData(){return this.baseThread.getData()}getEvents(){return this.baseThread.getEvents()}getName(){return this.baseThread.getName()}next(t){this.baseThread.next(t)}start(){if(null==this.baseThread){let t=Object.assign({name:this.name},this.pipeThreadDef);this.baseThread=Threads.create(t),this.pipeConnector(this.baseThread)}else this.baseThread.start();return this}stop(t){return this.baseThread.stop(void 0),this}get reducers(){return this.baseThread.reducers}get isRunning(){return this.baseThread.isRunning}get do(){return this.baseThread.do}get actions(){return this.baseThread.actions}get thread(){return this.baseThread.thread}changeLoggingNature(t){return this.baseThread.changeLoggingNature(t)}}class Pipes{static fromMonitor(t,e,a,n,r){return Pipes.filter(t,Pipes.merge(t,e.asyncThread,a,e.mainThread,n,r),(t,e)=>!Objects.deepEquals(t,e),{nature:FlowEventNature.AUX})}static map(t,e,a,n){return new PipeImpl(t,t=>e.addReaction({name:"mapper",dataConsumer:e=>t.do.update(a(e))}),n).start()}static merge(t,e,a,n,r,s){let i=Threads.create({name:"last states",nature:FlowEventNature.AUX}),o=Threads.create({name:"last states",nature:FlowEventNature.AUX}),c=Threads.create({name:"last states",nature:FlowEventNature.AUX});return new PipeImpl(t,t=>{t.addReaction({name:"append state",dataConsumer:t=>i.do.update(t)}),[[e,a,o,c],[n,r,c,o]].forEach(e=>{let a=e[0],n=e[1],r=e[2],s=e[3];a.addReaction({name:"merge",dataConsumer:e=>{r.reducers.$update(e),t.do.update(n(e,s.getData(),i.getData()))}})})},s).start()}static tupleCombine(t,e,a,n){let r=Threads.create({name:"last states",nature:FlowEventNature.AUX}),s=Threads.create({name:"last states",nature:FlowEventNature.AUX});return new PipeImpl(`combineArray => [${e.getName()}, ${a.getName()}]`,n=>{n.addReaction({name:t,dataConsumer:t=>{r.do.update(t[0]),s.do.update(t[1])}}),[[e,s,"left"],[a,r,"right"]].forEach(t=>{let e=t[0],a=t[1],r=t[2];e.addReaction({name:`tuple=>${r}`,dataConsumer:t=>{let e;if("left"===r){e=[t,a.getData()]}else{e=[a.getData(),t]}n.do.update(e)}})})},n).start()}static combine(t,e,a){return new PipeImpl(t,t=>Objects.foreachEntry(e,(e,a)=>e.addReaction({name:"combine",dataConsumer:e=>{t.reducers.$update(t=>Object.assign(Object.assign({},t),{[a]:e}))}})),a).start()}static filter(t,e,a,n){let r=Threads.create({name:"last states",nature:FlowEventNature.AUX});return new PipeImpl(t,t=>{t.addReaction({name:"save state",dataConsumer:t=>r.reducers.$update(t)}),e.addReaction({name:"pipe-filter",dataConsumer:e=>{let n=r.getData();a(e,n)&&t.reducers.$update(e)}})},n).start()}}class ConanState{constructor(t){this.state=t}getName(){return this.state.getName()}connectMap(t,e){return React.createElement(StateMapConnect,{from:this,into:t,mapper:e})}connectData(t){return React.createElement(StateMapConnect,{from:this,into:t,mapper:t=>t})}connect(t){return React.createElement(StateConnect,{from:this,into:t})}connectLive(t,e){return React.createElement(StateLive,{from:this,renderer:t,fallbackValue:e})}addAsyncReaction(t){if(!this.isThreadBased())return this.asMonitor().addAsyncReaction(t)}addDataReaction(t){return this.state.addReaction(t)}get do(){return this.state.do}start(){return this.state.start(),this}stop(t){return this.state.stop(t),this}get actions(){return this.state.actions}getData(){return this.state.getData()}asyncMerge(t,e,a){if(this.isThreadBased())throw new Error("this conan state is not ready for async");this.asMonitor().activateAsyncLog();let n=Pipes.fromMonitor(`monitor[${this.getName()}]`,this.state,e,a,{initialData:t,nature:FlowEventNature.HELPER});return new ConanState(new ThreadFacade(n,this.actions))}filter(t){let e=Pipes.filter(`filter=>${this.getName()}`,this.isThreadBased()?this.asThread():this.asMonitor().mainThread,t);return new ConanState(e)}map(t){let e=Pipes.map(`map=>${this.getName()}`,this.isThreadBased()?this.asThread():this.asMonitor().mainThread,t);return new ConanState(e)}merge(t,e){let a=Pipes.merge(`merge=>${this.getName()}`,this.isThreadBased()?this.asThread():this.asMonitor().mainThread,e,t.asThread(),(t,a,n)=>e(a,t,n));return new ConanState(a)}tuple(t){let e=Pipes.tupleCombine(`mergeTuple=>${this.getName()}`,this.isThreadBased()?this.asThread():this.asMonitor().mainThread,t.asThread());return new ConanState(e)}isThreadBased(){return!this.isMonitorBased()}isMonitorBased(){return this.state instanceof MonitorFacade}asThread(){return this.isThreadBased()?this.state:this.asMonitor().mainThread}asMonitor(){return this.state}static combine(t,e,a){let n=Pipes.combine(t,Objects.mapKeys(e,t=>t.asThread()),a);return new ConanState(n)}}class MonitorImpl{constructor(t,e){this.mainThread=t,this.asyncThread=e}start(){return this.mainThread.start(),this}addReaction(t){return this.mainThread.addReaction(t)}addAsyncReaction(t){return this.asyncThread.addReaction(t)}get do(){return this.mainThread.do}getEvents(){return this.mainThread.getEvents()}getName(){return this.mainThread.getName()}stop(t){this.mainThread.stop(t)}getData(){return this.mainThread.getData()}next(t){this.mainThread.next(t)}}class Monitors{static create(t){let e=this.createAsyncThread(t),a=Threads.create(Object.assign(Object.assign({},t),{nature:t.nature,pipelineListener:t=>{t.runtimeEvent!==FlowEventType.MONITORING||(t.timing===FlowEventTiming.START?e.do.tick(t.payload):t.timing===FlowEventTiming.END?e.do.unTick(t.payload,!1):t.timing===FlowEventTiming.CANCEL&&e.do.unTick(t.payload,!0))}})),n=new MonitorImpl(a,e);return new MonitorFacade(n,a.actions)}static createAsyncThread(t){return Threads.create({name:`async[${t.name}]`,actions:t=>({tick(e){t.reducers.$update(t=>({status:exports.MonitorStatus.ASYNC_START,currentAction:e,inProgressActions:[...t.inProgressActions,e]}))},unTick(e,a){t.reducers.$update(t=>({status:a?exports.MonitorStatus.ASYNC_CANCELLED:exports.MonitorStatus.ASYNC_FULFILLED,currentAction:e,inProgressActions:t.inProgressActions.filter(t=>t!==e)})),0===t.getData().inProgressActions.length&&t.reducers.$update(t=>({inProgressActions:[],currentAction:void 0,status:exports.MonitorStatus.IDLE}))}}),initialData:{inProgressActions:[],status:exports.MonitorStatus.IDLE,currentAction:void 0},nature:FlowEventNature.AUX})}}class Conan{static light(t,e,a=FlowEventNature.MAIN){return new ConanState(Monitors.create(Object.assign({name:t,initialData:e},a?{nature:a}:void 0)))}static state(t){return new ConanState(Monitors.create(t))}}class Lists{static mergeCombine(t,e,a,n){let r=[],s=!1;return r=e.map(e=>{for(let r of t)if(a(r,e))return s=!0,n(r,e);return e}),s?r:e}}exports.AsapParser=AsapParser,exports.Asaps=Asaps,exports.Conan=Conan,exports.ConanState=ConanState,exports.ContextStateConnect=ContextStateConnect,exports.ContextStateLive=ContextStateLive,exports.ContextStateMapConnect=ContextStateMapConnect,exports.DiAnnotationsMetadataFactory=DiAnnotationsMetadataFactory,exports.DiContextFactory=DiContextFactory,exports.DynamicOrStatics=DynamicOrStatics,exports.Flows=Flows,exports.InjectByName=InjectByName,exports.InjectByType=InjectByType,exports.InjectDynamic=InjectDynamic,exports.Lists=Lists,exports.ReactStateContext=ReactStateContext,exports.StateConnect=StateConnect,exports.StateLive=StateLive,exports.StateMapConnect=StateMapConnect,exports.contextStateConnect=contextStateConnect,exports.contextStateLive=contextStateLive,exports.contextStateMapConnect=contextStateMapConnect,exports.diAnnotationsCrud=diAnnotationsCrud,exports.isAsap=isAsap,exports.stateConnect=stateConnect,exports.stateLive=stateLive,exports.stateMapConnect=stateMapConnect,exports.useConanState=useConanState,exports.useContextConanState=useContextConanState,exports.useFlow=useFlow,exports.useFlowStatus=useFlowStatus;