export class Objects {
    static mapKeys(from, valueMapper, keyMapper) {
        let result = {};
        Object.keys(from).forEach(key => {
            let newKey = keyMapper ? keyMapper(key) : key;
            result[newKey] = valueMapper(from[key]);
        });
        return result;
    }
    static foreachEntry(from, cb) {
        Object.keys(from).forEach(key => {
            cb(from[key], key);
        });
    }
    static keyfy(from, keyProvider) {
        return from.reduce((acc, it) => {
            return Object.assign(Object.assign({}, acc), { [keyProvider(it)]: it });
        }, {});
    }
    static navigate(from, iterator) {
        let result = [];
        let next = from;
        while (next) {
            next = iterator(next);
            if (next !== null) {
                result.push(next);
            }
        }
        return result;
    }
    static deepEqualsArrays(left, right) {
        if (left.length !== right.length)
            return false;
        for (let leftItem of left) {
            if (right.indexOf(leftItem) === -1)
                return false;
        }
        return true;
    }
    static deepEqualsObjects(left, right) {
        for (let key of Object.keys(left)) {
            if (!Objects.deepEquals(left[key], right[key])) {
                return false;
            }
        }
        return true;
    }
    static deepEquals(left, right) {
        if ((left == null) && (right == null))
            return true;
        if ((left == null) && (right != null))
            return false;
        if ((left != null) && (right == null))
            return false;
        if ((typeof left === "string") && (typeof right === "string"))
            return left === right;
        if ((typeof left === "number") && (typeof right === "number"))
            return left === right;
        if ((typeof left === "function") && (typeof right === "function"))
            return left === right;
        if ((typeof left === "boolean") && (typeof right === "boolean"))
            return left === right;
        if ((typeof left === "undefined") && (typeof right === "undefined"))
            return left === right;
        if (Array.isArray(left) && (Array.isArray(right)))
            return Objects.deepEqualsArrays(left, right);
        if (Array.isArray(left) && (!Array.isArray(right)))
            return false;
        if (!Array.isArray(left) && (Array.isArray(right)))
            return false;
        if ((typeof left === "object") && (typeof right === "object"))
            return Objects.deepEqualsObjects(left, right);
        return left === right;
    }
}
//# sourceMappingURL=objects.js.map