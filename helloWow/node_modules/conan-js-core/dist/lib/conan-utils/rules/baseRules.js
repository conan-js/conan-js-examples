import { CombinedRule, LOGIC_OPERATOR, RuleLikeParser, SimpleRule } from "./_rules";
class BasePredicates {
    static isUndefined() {
        return BasePredicates.compareByReference(undefined);
    }
    static isNull() {
        return BasePredicates.compareByReference(null);
    }
    static isNullUn() {
        return (value) => value == null;
    }
    static compareByReference(toCompareWith) {
        return (value) => value === toCompareWith;
    }
    static isInitialised() {
        return (value) => value != null;
    }
}
export class BaseRules {
    static if(name, predicate) {
        return new SimpleRule(name, predicate);
    }
    static ifNot(name, predicate) {
        return new SimpleRule(name, predicate, true);
    }
    static ifUndefined() {
        return BaseRules.if('ifUndefined', BasePredicates.isUndefined());
    }
    static ifNull() {
        return BaseRules.if('ifNull', BasePredicates.isNull());
    }
    static ifNullUn() {
        return BaseRules.if('ifNullUn', BasePredicates.isNullUn());
    }
    static ifInitialised() {
        return BaseRules.if('ifInitialised', BasePredicates.isInitialised());
    }
    static compareByReference(name, toCompareWith) {
        return BaseRules.if(name, BasePredicates.compareByReference(toCompareWith));
    }
    static combineAnd(name, ...rules) {
        let rulesParsed = rules.map(RuleLikeParser.parse);
        return new CombinedRule(name, rulesParsed, LOGIC_OPERATOR.AND);
    }
    static combineOr(name, ...rules) {
        return new CombinedRule(name, rules.map(RuleLikeParser.parse), LOGIC_OPERATOR.OR);
    }
    static join(mapper, joiner) {
        return BaseRules.if(`join{${joiner.name}`, (value) => {
            let nextValue = mapper(value);
            return joiner.test(nextValue);
        });
    }
}
//# sourceMappingURL=baseRules.js.map