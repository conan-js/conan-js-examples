export declare type IFunction<I, O> = (input: I) => O;
export declare type ITriFunction<I1, I2, I3, O> = (input1: I1, input2: I2, input3: I3) => O;
export declare type IReducer<T> = IFunction<T, T>;
export declare type IPredicate<T> = IFunction<T, boolean>;
export declare type IFunctionVarArg<T> = (...args: any[]) => T;
export declare type IBiFunction<A, B, R> = (a: A, b: B) => R;
export declare type ICallback = () => void;
export declare type IConsumer<T> = (toConsume: T) => void;
export declare type IBiConsumer<A, B> = (a: A, b: B) => void;
export declare type ITriConsumer<A, B, C> = (a: A, b: B, c: C) => void;
export declare type IProducer<T> = () => T;
export interface IKeyValuePairs<T> {
    [p: string]: T;
}
export declare type WithMetadataArray<VALUE, METADATA> = WithMetadata<VALUE, METADATA>[];
export declare type WithMetadataKeyValuePairs<VALUE, METADATA> = IKeyValuePairs<WithMetadata<VALUE, METADATA>>;
export interface WithMetadata<VALUE, METADATA> {
    metadata: METADATA;
    value: VALUE;
}
export declare type IPartial<T> = IOptSetKeyValuePairs<keyof T, any>;
export declare type ISetKeyValuePairs<NAMES extends keyof any, T> = {
    [N in NAMES]: T;
};
export declare type IOptSetKeyValuePairs<NAMES extends keyof any, T> = {
    [N in NAMES]?: T;
};
export declare type IConstructorProxy<TO_PROXY> = {
    [K in keyof TO_PROXY]: (TO_PROXY[keyof TO_PROXY] | IVarArgConstructor<TO_PROXY[keyof TO_PROXY]> | string);
};
export interface IConstructor<T, D> {
    new (deps: D): T;
}
export interface IVarArgConstructor<T> {
    new (...args: any[]): T;
}
export declare type ProvidedOrStaticOf<RESULT extends {}, BASED_ON> = IFunction<BASED_ON, RESULT> | RESULT;
export declare class DynamicOrStatics {
    static result<BASED_ON, RESULT>(dynamicOrStatic: ProvidedOrStaticOf<BASED_ON, RESULT>, basedOn: BASED_ON): RESULT;
}
