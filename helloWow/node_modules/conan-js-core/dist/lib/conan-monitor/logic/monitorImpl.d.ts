import { ThreadFacade } from "../../conan-thread/domain/threadFacade";
import { Reducers } from "../../conan-thread/domain/reducers";
import { MonitorActions } from "../domain/monitorActions";
import { DataReactionDef, DataReactionLock } from "../../conan-thread/domain/dataReaction";
import { MonitorInfo } from "../domain/monitorInfo";
import { DefaultStepFn } from "../../conan-flow/domain/steps";
import { FlowEventsTracker } from "../../conan-flow/logic/flowEventsTracker";
import { Context } from "../../conan-flow/domain/context";
import { ThreadFlow } from "../../conan-thread/factories/threads";
import { FlowFacade } from "../../conan-flow/domain/flowFacade";
import { MetaMutators, MetaStatuses } from "../domain/metaFlow";
import { Asap, IConsumer } from "../../index";
export interface Monitor<DATA, REDUCERS extends Reducers<DATA> = {}, ACTIONS = any> {
    transaction(code: IConsumer<ACTIONS>): Asap<DATA>;
    mainThread: ThreadFacade<DATA, REDUCERS, ACTIONS>;
    asyncThread: ThreadFacade<MonitorInfo, {}, MonitorActions>;
    metaFlow: FlowFacade<MetaStatuses, MetaMutators>;
    start(): this;
    addReaction(def: DataReactionDef<DATA>): DataReactionLock;
    once(reaction: IConsumer<DATA>, name: string): this;
    addAsyncReaction(def: DataReactionDef<DATA>): DataReactionLock;
    do: REDUCERS & DefaultStepFn<DATA> & ACTIONS;
    getEvents(): FlowEventsTracker<{
        nextData: DATA;
    }>;
    next(cb: (onNext: Context<ThreadFlow<DATA>, 'nextData', {
        nextData: REDUCERS;
    }>) => void): void;
    getName(): string;
    stop(eventsConsumer: (events: any) => void): void;
    stop(eventsConsumer: (events: any) => void): void;
    getData(): DATA;
    chain(operation: IConsumer<REDUCERS>, name?: string): Asap<DATA>;
    openTransaction(name?: string): void;
    closeTransaction(callback?: IConsumer<DATA>): void;
}
export declare class MonitorImpl<DATA, REDUCERS extends Reducers<DATA> = {}, ACTIONS = any> implements Monitor<DATA, REDUCERS, ACTIONS> {
    readonly mainThread: ThreadFacade<DATA, REDUCERS, ACTIONS>;
    readonly asyncThread: ThreadFacade<MonitorInfo, {}, MonitorActions>;
    readonly metaFlow: FlowFacade<MetaStatuses, MetaMutators>;
    private currentTransaction;
    constructor(mainThread: ThreadFacade<DATA, REDUCERS, ACTIONS>, asyncThread: ThreadFacade<MonitorInfo, {}, MonitorActions>, metaFlow: FlowFacade<MetaStatuses, MetaMutators>);
    start(): this;
    addReaction(def: DataReactionDef<DATA>): DataReactionLock;
    addAsyncReaction(def: DataReactionDef<MonitorInfo>): DataReactionLock;
    get do(): REDUCERS & DefaultStepFn<DATA> & ACTIONS;
    getEvents(): FlowEventsTracker<{
        nextData: DATA;
    }>;
    getName(): string;
    stop(eventsConsumer: (events: any) => void): void;
    getData(): DATA;
    next(cb: (onNumberUpdated: Context<ThreadFlow<DATA>, 'nextData', {
        nextData: REDUCERS;
    }>) => void): void;
    once(reaction: IConsumer<DATA>, name?: string): this;
    chain(operation: IConsumer<REDUCERS>, name?: string): Asap<DATA>;
    openTransaction(name?: string): void;
    closeTransaction(callback?: IConsumer<DATA>): void;
    transaction(code: IConsumer<ACTIONS>, name?: string): Asap<DATA>;
}
