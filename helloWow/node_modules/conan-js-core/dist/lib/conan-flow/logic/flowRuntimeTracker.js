import { FlowEventTiming, FlowEventLevel } from "../domain/flowRuntimeEvents";
export class FlowRuntimeTracker {
    constructor(orchestrator, event) {
        this.orchestrator = orchestrator;
        this.event = event;
    }
    end(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.END, shortDesc, payload);
    }
    cancel(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.CANCEL, shortDesc, payload);
    }
    continue(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.CONTINUE, shortDesc, payload);
    }
    start(shortDesc, payload) {
        return this.doTick(FlowEventLevel.TRACE, FlowEventTiming.START, shortDesc, payload);
    }
    debug(shortDesc, payload) {
        return this.doTick(FlowEventLevel.DEBUG, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    info(shortDesc, payload) {
        return this.doTick(FlowEventLevel.INFO, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    milestone(shortDesc, payload) {
        return this.doTick(FlowEventLevel.MILESTONE, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    withLevel(level, shortDesc, payload) {
        return this.doTick(level, FlowEventTiming.IN_PROCESS, shortDesc, payload);
    }
    fork(type, level, shortDesc, payload) {
        let forkedTracker = this.orchestrator.createRuntimeTracker(this.event.flowController, this.event.source, type, payload).start();
        forkedTracker.withLevel(level, shortDesc, payload);
        forkedTracker.end();
    }
    doTick(level, timing, shortDesc, payload, type) {
        let event = Object.assign(Object.assign(Object.assign(Object.assign({}, this.event), (type != null ? { type } : undefined)), { shortDesc,
            timing,
            level }), (payload != null ? { payload } : undefined));
        this.orchestrator.onRuntimeEvent(this, event);
        return this;
    }
}
//# sourceMappingURL=flowRuntimeTracker.js.map